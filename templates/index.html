<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Micro Quant</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
  <!-- Time scale adapter for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
  <!-- Config via data attributes (avoids HTML entity issues) -->
  <div id="app-cfg" data-symbols="{{ symbols_csv }}" data-default="{{ default_symbol_plain }}" data-ai="{{ 1 if news_ai_available else 0 }}" style="display:none"></div>
  <!-- Minimal modal container for full news text -->
  <div id="newsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-box">
      <div class="modal-head">
        <h3 id="newsModalTitle">Full Article</h3>
        <button id="newsModalClose" class="modal-close" aria-label="Close">×</button>
      </div>
      <div id="newsModalBody" class="modal-body"></div>
    </div>
  </div>
  <style>
    :root {
      --gold: #d4a017;
      --accent: #1976d2; /* vivid blue */
      --accent2: #ff9800; /* orange */
      --buy: #2ecc71; /* green */
      --sell: #e74c3c; /* red */
      --muted: #555;
      --bg: #ffffff;
      --panel: #f7f9fc;
      --text: #111;
      --line: #e0e6ef;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: var(--bg); color: var(--text); }
    header { display:flex; justify-content:space-between; align-items:center; padding: 12px 20px; background: linear-gradient(90deg, var(--accent), var(--accent2)); color: #fff; }
    .brand { display:flex; align-items:center; gap:6px; }
    header h2 { margin: 0; font-weight: 600; }
    #ticker { font-variant-numeric: tabular-nums; }
    .container { padding: 16px 20px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
    label { color: var(--muted); }
    input, select { background: #fff; color: var(--text); border: 1px solid var(--line); border-radius: 6px; padding: 6px 8px; }
    #status { margin-top: 8px; color: var(--muted); }
    #chart-wrap { width: 100%; max-width: 100%; background: var(--panel); padding: 12px; border:1px solid var(--line); border-radius: 8px; box-sizing: border-box; }
    #lwChart { width: 100%; min-height: 520px; height: clamp(520px, 72vh, 920px); }
    /* Overlay canvas to draw period lines over Lightweight Charts */
    #lwChart { position: relative; }
    .lw-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
    #chart { width: 100% !important; height: clamp(420px, 68vh, 840px); }
    #indicator-wrap { margin-top: 12px; display: grid; gap: 12px; width: 100%; }
    .indicator-panel { background: var(--panel); border:1px solid var(--line); border-radius:8px; padding:8px 12px; }
    .indicator-panel h4 { margin:0 0 6px; font-size:13px; color:var(--muted); font-weight:600; letter-spacing:0.4px; text-transform:uppercase; }
    #indicator-wrap canvas { width: 100% !important; height: 190px !important; }
    .news-card { border:1px solid var(--line); border-radius:10px; padding:12px 14px; background:#fff; margin:10px 0; box-shadow:0 1px 2px rgba(0,0,0,0.04); display:flex; flex-direction:column; gap:8px; }
    .news-card h4 { margin:0; font-size:15px; color:var(--text); font-weight:600; }
    .news-meta { font-size:12px; color:var(--muted); display:flex; gap:8px; flex-wrap:wrap; }
    .news-summary { font-size:13px; color:var(--text); line-height:1.4; }
    .news-actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .news-ai-btn { padding:6px 10px; font-size:12px; }
    .news-answers { display:none; flex-wrap:wrap; gap:6px; margin-top:4px; }
    .news-answers.active { display:flex; }
    .news-answer { padding:4px 8px; border-radius:6px; font-size:12px; font-weight:600; border:1px solid var(--line); background:var(--panel); color:var(--muted); }
    .news-answer.yes { border-color:#2ecc71; color:#1b5e20; background:rgba(46, 204, 113, 0.12); }
    .news-answer.no { border-color:#e74c3c; color:#b71c1c; background:rgba(231, 76, 60, 0.12); }
    .news-answer.unknown { border-color:#b0bec5; color:#546e7a; background:rgba(84, 110, 122, 0.12); }
    .news-answer span { font-weight:500; }
    /* Simple modal for full news text */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .modal-box { background:#fff; max-width: 920px; width: min(92vw, 920px); max-height: 82vh; overflow:auto; border-radius:10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
    .modal-head { display:flex; justify-content: space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--line); }
    .modal-head h3 { margin:0; font-size:16px; }
    .modal-body { padding: 14px 16px; line-height:1.5; white-space: pre-wrap; }
    .modal-close { background: transparent; border: 0; font-size: 20px; cursor: pointer; color: #444; }
    /* RoboForex affiliate widgets (non-intrusive, dismissible) */
    .rf-floating { position: fixed; z-index: 9998; background:#fff; border:1px solid var(--line); border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,0.15); overflow:hidden; }
    .rf-top { top: 8px; right: 12px; }
    .rf-bottom { bottom: 8px; left: 50%; transform: translateX(-50%); }
    .rf-br { bottom: 12px; right: 12px; }
    .rf-head { position:absolute; top:4px; right:6px; display:flex; gap:6px; }
    .rf-btn { border:0; background:rgba(0,0,0,0.5); color:#fff; width:18px; height:18px; line-height:18px; border-radius:3px; font-size:12px; cursor:pointer; }
    .rf-btn:hover { background:rgba(0,0,0,0.7); }
    .rf-hidden { display:none !important; }
    .rf-placeholder { font-size:12px; color:var(--muted); display:block; padding:4px 0; }
    .rf-inline { display:flex; align-items:center; gap:6px; background:#fff; border:1px solid var(--line); border-radius:8px; padding:4px 8px; box-shadow:0 3px 10px rgba(0,0,0,0.08); margin-left:16px; }
    .rf-inline button { border:0; background:transparent; color:var(--muted); cursor:pointer; font-size:16px; line-height:1; padding:0 4px; }
    .rf-inline button:hover { color:#000; }
    .rf-inline iframe { border:0; }
    .pill { padding: 4px 10px; border: 1px solid var(--line); border-radius: 999px; background:#fff; }
    .btn { padding: 10px 14px; background: var(--accent); color: #fff; border: 0; border-radius: 6px; cursor: pointer; }
    .btn.secondary { background: #607d8b; }
    .btn-buy { background: var(--buy); font-weight:600; }
    .btn-sell { background: var(--sell); font-weight:600; }
    .btn:disabled { opacity: 0.6; cursor: default; }
    .grid { display:grid; grid-template-columns: minmax(0, 1fr) 360px; gap: 16px; align-items:start; }
    .control-top { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin:12px 0 16px; }
    .control-group { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .control-group.trade { margin-left:auto; }
    pre { margin:0; }
    .switch { display:inline-flex; align-items:center; gap:6px; font-size:13px; color:var(--text); cursor:pointer; user-select:none; }
    .switch input[type="checkbox"] { width:18px; height:18px; accent-color: var(--accent); cursor:pointer; }
      .lw-pane { width: 100%; height: 190px; }
    .stl-row { align-items: center; }
    .stl-field { display:grid; grid-template-columns: 64px 240px; align-items:center; column-gap:8px; }
    .stl-field .stl-lbl { text-align:right; white-space:nowrap; }
    .stl-field input[type="datetime-local"] { width: 240px; max-width: 100%; height: 32px; padding: 6px 8px; }
  </style>
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico" />
  </head>
  <body>
    <header>
      <div class="brand">
        <img src="/static/logo.png" alt="Micro Quant" style="height:40px; width:auto; border-radius:4px;" />
        <h2>Micro Quant</h2>
      </div>
      <iframe width="604" height="40" frameborder="0" class="efx" src="https://staticmy.roboforex-cn.com/en/partners/informers_get/?width=600&width_type=slider&speed=4&color_bg=%23ffffff&color_bd=%23dbe5e8&arrows=on&data_type=askbid&EURUSD=&GBPUSD=&USDCHF=&USDJPY=&USDCAD=&AUDUSD=&NZDUSD=&EURGBP=&EURJPY=&EURCHF=&GBPJPY=&GBPCHF=&type=quotestape" style="margin-left:12px; vertical-align:middle;"></iframe>
      <div style="display:flex; gap:16px; align-items:center;">
        <div id="signalBar" style="display:flex; gap:8px; align-items:center;">
          <span id="signalDot" style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#999;"></span>
          <span id="signalText">Signal: —</span>
          <button class="btn secondary" id="btnRunStratTop" style="padding:6px 10px">Run</button>
          <button class="btn secondary" id="btnAutoStrat" style="padding:6px 10px">Auto Off</button>
          <button class="btn" id="btnTradeSignalTop" style="padding:6px 10px" disabled>Trade Signal</button>
        </div>
        <div id="ticker">—</div>
      </div>
    </header>
    <div class="container">
    <div class="control-top">
      <div class="control-group">
        <label>Symbol
          <select id="symbol">
        {% for sym in symbols %}
            <option value="{{ sym }}"{% if sym == default_symbol %} selected{% end %}>{{ sym }}</option>
        {% end %}
          </select>
        </label>
        <label>Timeframe
          <select id="tf">
            <option value="M1"{% if default_tf == 'M1' %} selected{% end %}>M1</option>
            <option value="M5"{% if default_tf == 'M5' %} selected{% end %}>M5</option>
            <option value="M15"{% if default_tf == 'M15' %} selected{% end %}>M15</option>
            <option value="M30"{% if default_tf == 'M30' %} selected{% end %}>M30</option>
            <option value="H1"{% if default_tf == 'H1' %} selected{% end %}>H1</option>
            <option value="H4"{% if default_tf == 'H4' %} selected{% end %}>H4</option>
            <option value="D1"{% if default_tf == 'D1' %} selected{% end %}>D1</option>
            <option value="W1"{% if default_tf == 'W1' %} selected{% end %}>W1 (Weekly)</option>
            <option value="MN1"{% if default_tf == 'MN1' %} selected{% end %}>MN1 (Monthly)</option>
            <option value="Y1"{% if default_tf == 'Y1' %} selected{% end %}>Y1 (Yearly)</option>
          </select>
        </label>
        <label>Bars
          <input id="count" type="number" min="10" max="5000" value="{{ default_count }}" />
        </label>
        <span class="pill">
          Chart:
          <label><input type="radio" name="ctype" value="line"{% if default_chart_type == 'line' %} checked{% end %}> Line</label>
          <label><input type="radio" name="ctype" value="candlestick"{% if default_chart_type != 'line' %} checked{% end %}> Candlestick</label>
        </span>
        <label class="switch" title="Shift end of chart from right border">
          <input type="checkbox" id="chkChartShift"{% if default_chart_shift != '0' %} checked{% end %} />
          <span>Chart shift</span>
        </label>
      </div>
      <div class="control-group">
        <button class="btn" id="btnFetch">Fetch + Save</button>
        <button class="btn secondary" id="btnRefresh">Refresh</button>
        <button class="btn secondary" id="btnAuto">Start Auto</button>
      </div>
      <div class="control-group">
        <button class="btn secondary" id="btnFetchCurrentBg">Current TF</button>
        <button class="btn secondary" id="btnFetchSymbolAll">Symbol × TFs</button>
        <button class="btn secondary" id="btnFetchAll">All Symbols</button>
      </div>
      <div class="control-group trade">
        <div id="stlOverlayControls" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-right:auto;"></div>
        <label style="display:flex; align-items:center; gap:6px;">Vol
          <input id="volume" type="number" step="0.01" min="0.01" value="{{ default_volume }}" style="width:100px;" />
        </label>
        <label style="display:flex; align-items:center; gap:6px;">SL
          <input id="sl" type="number" step="0.01" min="0" placeholder="optional" value="{{ default_sl }}" style="width:120px;" />
        </label>
        <label style="display:flex; align-items:center; gap:6px;">TP
          <input id="tp" type="number" step="0.01" min="0" placeholder="optional" value="{{ default_tp }}" style="width:120px;" />
        </label>
        <button class="btn btn-buy" id="btnBuy">Buy</button>
        <button class="btn btn-sell" id="btnSell">Sell</button>
        <button class="btn secondary" id="btnClose">Close All</button>
      </div>
    </div>
    <div id="status"></div>

    <div class="grid">
      <div>
        <div id="chart-wrap">
          <canvas id="chart" height="400"></canvas>
          <div id="lwChart" style="display:none; height:520px;"></div>
        </div>
        <div id="indicator-wrap">
          <div class="indicator-panel">
            <h4>STL Speed / Accel</h4>
            <div id="lwDeriv" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>RSI (14)</h4>
            <div id="lwRsi" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>MACD (12, 26, 9)</h4>
            <div id="lwMacd" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>Volume</h4>
            <div id="lwVol" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>ATR (14)</h4>
            <div id="lwAtr" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>ADX (14)</h4>
            <div id="lwAdx" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>Account Balance</h4>
            <div id="lwBalance" class="lw-pane"></div>
          </div>
        </div>
      </div>
      <div>
        <!-- News panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px; max-height:320px; overflow:auto;">
          <div class="row" id="newsHeader" style="justify-content:space-between; position:sticky; top:0; background:var(--panel); z-index:10; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
            <strong style="color:var(--accent)">News &amp; Intel</strong>
            <div class="row" style="gap:6px;">
              <button class="btn secondary" id="btnNews" style="padding:6px 10px">Refresh News</button>
              <button class="btn secondary" id="btnNewsFull" style="padding:6px 10px">Full Text</button>
            </div>
          </div>
          <div id="newsStatus" style="font-size:12px; color:var(--muted); margin:-4px 0 8px 0;"></div>
          <div id="symbolInfoBox" style="font-size:13px; line-height:1.45; color:var(--muted); margin-bottom:8px;">
            <em>Snapshot will appear here…</em>
          </div>
          <div id="newsBox" style="font-size:14px; line-height:1.35; color:var(--text);"><em style="color:var(--muted)">No news yet…</em></div>
        </div>
        <!-- Analysis panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <div style="display:flex; flex-direction:column; gap:10px;">
            <strong style="color:var(--accent)">Analysis</strong>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Template</span>
                <select id="healthStrategy" style="min-width:220px; padding:4px 6px;"></select>
              </label>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">News to use</span>
                <input id="healthNewsCount" type="number" min="1" max="20" value="3" style="width:72px;" />
              </label>
              <button class="btn secondary" id="btnHealthCheck" style="padding:6px 10px;">Basic Health Check</button>
              <span id="healthFreshIndicator" class="pill" style="display:inline-block; font-size:12px;">—</span>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Bars</span>
                <input id="techHealthBars" type="number" min="1" max="500" style="width:72px;" />
              </label>
              <button class="btn secondary" id="btnTechHealth" style="padding:6px 10px;">Tech Snapshot</button>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Tech template</span>
                <select id="techAiStrategy" style="min-width:220px; padding:4px 6px;">
                  <option value="tech_snapshot_10q.json">Tech Snapshot (10)</option>
                </select>
              </label>
              <button class="btn" id="btnTechAiHealth" style="padding:6px 10px;">Tech+AI Check</button>
              <span id="techFreshIndicator" class="pill" style="display:inline-block; font-size:12px;">—</span>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Leverage</span>
                <input id="aiLeverage" type="number" min="1" max="100" value="10" style="width:80px;" />
              </label>
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Trade AI model</span>
                <select id="aiModelSelect" style="min-width:220px; padding:4px 6px;">
                  <option value="gpt-5">gpt-5 (default)</option>
                  <option value="gpt-4o">gpt-4o</option>
                  <option value="gpt-4o-mini">gpt-4o-mini</option>
                  <option value="deepseek-chat">deepseek-chat</option>
                  <option value="deepseek-reasoner">deepseek-reasoner</option>
                </select>
              </label>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <button class="btn btn-buy" id="btnAiBuy" style="padding:6px 10px;">AI Buy</button>
              <button class="btn btn-sell" id="btnAiSell" style="padding:6px 10px;">AI Sell</button>
            </div>
            <div id="aiTradePlanBox" style="font-size:13px; color:var(--text);"></div>
            <div class="row" style="margin-top:8px;">
              <button class="btn secondary" id="btnExecutePlan" disabled style="padding:6px 10px;">Execute Plan</button>
            </div>
          </div>
        </div>
        <!-- STL panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <div class="row" style="justify-content:space-between; gap:8px;">
            <strong style="color:var(--accent)">STL Decomposition</strong>
            <div style="display:flex; gap:6px; flex-wrap:wrap;">
              <button class="btn secondary" id="btnStlCurrent" style="padding:6px 10px;">Recalculate</button>
              <button class="btn secondary" id="btnStlSymbolAll" style="padding:6px 10px;">Symbol × TFs</button>
              <button class="btn secondary" id="btnStlTfAll" style="padding:6px 10px;">TF × Symbols</button>
              <button class="btn secondary" id="btnStlAll" style="padding:6px 10px;">All</button>
            </div>
          </div>
          <div class="row" style="gap:10px; margin-top:8px; flex-wrap:wrap;">
            <label class="switch">
              <input type="checkbox" id="chkStlAutoPeriod"{% if default_stl_auto_period != '0' %} checked{% end %} />
              <span>Auto period</span>
            </label>
            <label>Period
              <input type="number" id="stlPeriodInput" min="3" value="{{ default_stl_manual_period }}" disabled />
            </label>
            <label class="switch">
              <input type="checkbox" id="chkStlDerivative" checked />
              <span>Show STL speed</span>
            </label>
            <label class="switch">
              <input type="checkbox" id="chkStlAcceleration" />
              <span>Show STL accel</span>
            </label>
            <label class="switch">
              <input type="checkbox" id="chkStlPeriodLines" />
              <span>Period lines</span>
            </label>
          </div>
          <div class="row stl-row" style="gap:10px; margin-top:8px; flex-wrap:wrap; align-items:center;">
            <label class="switch">
              <input type="checkbox" id="chkStlAllData" checked />
              <span>Use all data</span>
            </label>
            <label class="stl-field"><span class="stl-lbl">From</span><input type="datetime-local" id="stlStart" disabled />
            </label>
            <label class="stl-field"><span class="stl-lbl">To</span><input type="datetime-local" id="stlEnd" disabled />
            </label>
          </div>
          <div class="row" style="gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center;">
            <label style="flex:1; min-width:220px; display:flex; align-items:center; gap:8px;">
              <span style="white-space:nowrap;">Saved runs</span>
              <select id="stlRuns" style="flex:1; min-width:140px;">
                <option value="">Latest (auto)</option>
              </select>
            </label>
            <button class="btn secondary" id="btnStlDelete" style="padding:6px 10px; align-self:center;" disabled>Delete</button>
          </div>
          <div id="stlStatus" style="font-size:13px; color:var(--muted); margin-top:6px;">STL overlay not loaded yet.</div>
        </div>
        <!-- Strategy panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <div class="row">
            <strong style="color:var(--accent)">Strategy: SMA Crossover</strong>
            <label>Fast <input id="fast" type="number" min="2" value="{{ default_fast }}" /></label>
            <label>Slow <input id="slow" type="number" min="3" value="{{ default_slow }}" /></label>
            <button class="btn" id="btnRunStrat">Run Strategy</button>
            <button class="btn secondary" id="btnTradeSignal" disabled>Trade Signal</button>
          </div>
          <div id="stratStatus" style="color:var(--muted)">Signal: —</div>
        </div>
        <div id="rfRightForecasts" style="margin-top:12px; padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px;"
          class="rf-hidden"
          data-rf-type="iframe"
          data-rf-src="https://staticmy.roboforex-cn.com/en/partners/informers_get/?width=300&theme_2=classic&amount=5&type=forecasts"
          data-rf-width="100%"
          data-rf-height="260"
          data-rf-placeholder="RoboForex forecasts widget disabled.">
          <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:14px;">
            <strong style="color:var(--accent)">RoboForex Market Forecasts</strong>
            <div class="rf-head" style="position:static;">
              <button class="rf-btn" id="rfRightForecastsClose" title="Hide">×</button>
            </div>
          </div>
        <div style="margin:10px 0 12px 0;">
          <a href="https://roboforex.com/"
             class="efx"
             target="_blank"
             rel="noopener noreferrer sponsored"
             style="display:block; width:100%; max-width:100%; box-sizing:border-box; text-align:center; padding:10px 12px; font-size:13px; font-weight:600; color:#fff; text-decoration:none; border-radius:10px; background:linear-gradient(90deg, var(--accent), var(--accent2)); box-shadow:0 6px 18px rgba(0,0,0,0.12); overflow:hidden;">
            Data Source Provider
          </a>
        </div>
        </div>
        <!-- Positions moved to bottom (independent panel) -->
        <div style="margin-top:12px;">
          <div class="row">
            <strong style="color:var(--accent)">Positions</strong>
            <button class="btn secondary" id="btnPos" style="margin-left:auto;">Refresh</button>
          </div>
          <pre id="positionsBox" style="margin-top:6px; background:var(--panel); padding:8px; border:1px solid var(--line); border-radius:8px; height:300px; overflow:auto;"></pre>
        </div>
        
        
        </div>
      </div>
    </div>
    <!-- Health Check Modal -->
    <div id="healthModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:1000;">
      <div style="background:#fff; border-radius:8px; border:1px solid var(--line); padding:12px; width:min(760px, 94vw); max-height:86vh; overflow:auto;">
        <div class="row" style="justify-content:space-between; align-items:center; position:sticky; top:0; background:#fff; z-index:5; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
          <strong style="color:var(--accent)">Health Check</strong>
          <button class="btn secondary" id="btnHealthClose" style="padding:6px 10px;">Close</button>
        </div>
        <div id="healthInfo" style="color:var(--muted); font-size:13px; margin-top:6px;"></div>
        <div style="margin-top:8px;">
          <div style="font-weight:600; color:var(--muted); margin-bottom:4px;">Recent</div>
          <div id="healthHistoryBox" style="border:1px solid var(--line); border-radius:8px; background:var(--panel); padding:8px; max-height:200px; overflow:auto;"></div>
          <div class="row" style="gap:8px; margin-top:6px;">
            <button class="btn secondary" id="btnHealthMore" style="padding:6px 10px;">More</button>
            <button class="btn" id="btnHealthStart" style="padding:6px 10px;">Start</button>
          </div>
        </div>
        <div id="healthResultsBox" style="margin-top:10px;"></div>
      </div>
    </div>
    <!-- Technical Health Modal -->
    <div id="techModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:1000;">
      <div style="background:#fff; border-radius:8px; border:1px solid var(--line); padding:16px; width:min(720px, 94vw); max-height:86vh; overflow:auto;">
        <div class="row" style="justify-content:space-between; align-items:center; position:sticky; top:0; background:#fff; z-index:5; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
          <strong style="color:var(--accent)">Technical Snapshot</strong>
          <button class="btn secondary" id="btnTechClose" style="padding:6px 10px;">Close</button>
        </div>
        <div id="techSummaryMeta" style="margin-top:4px; font-size:13px; color:var(--muted);"></div>
        <div id="techSummaryBox" style="margin-top:12px; display:flex; flex-direction:column; gap:12px;"></div>
      </div>
    </div>
    </div>
    <!-- AI Trade Plan Modal -->
    <div id="tradeModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:1000;">
      <div style="background:#fff; border-radius:8px; border:1px solid var(--line); padding:12px; width:min(760px, 94vw); max-height:86vh; overflow:auto;">
        <div class="row" style="justify-content:space-between; align-items:center; position:sticky; top:0; background:#fff; z-index:5; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
          <strong style="color:var(--accent)">AI Trade Plan</strong>
          <button class="btn secondary" id="btnTradeClose" style="padding:6px 10px;">Close</button>
        </div>
        <div id="tradeInfo" style="color:var(--muted); font-size:13px; margin-top:6px;"></div>
        <div style="margin-top:8px;">
          <div style="font-weight:600; color:var(--muted); margin-bottom:4px;">Recent</div>
          <div id="tradeHistoryBox" style="border:1px solid var(--line); border-radius:8px; background:var(--panel); padding:8px; max-height:200px; overflow:auto;"></div>
          <div class="row" style="gap:8px; margin-top:6px;">
            <button class="btn secondary" id="btnTradeMore" style="padding:6px 10px;">More</button>
            <button class="btn" id="btnTradeStart" style="padding:6px 10px;">Start</button>
          </div>
        </div>
        <div id="tradeResultsBox" style="margin-top:10px;"></div>
      </div>
    </div>

    <!-- Affiliate floating widgets -->
    <div id="rfBottomBanner" class="rf-floating rf-bottom rf-hidden" style="width:728px; height:90px;"
      data-rf-type="img"
      data-rf-src="https://my.roboforex.com/files/banners/88_en_rbfx_728x90__4947e7b6af364ea64a0f748b2a63fa14.jpg"
      data-rf-width="728"
      data-rf-height="90"
      data-rf-placeholder="RoboForex banner disabled.">
      <div class="rf-head">
        <button class="rf-btn" id="rfBottomBannerClose" title="Hide">×</button>
      </div>
      <a id="rfBottomBannerLink" href="https://roboforex.com/?utm_source=domain&amp;utm_medium=affbanerimg&amp;utm_content=size728_90&amp;utm_campaign=affunlimited_choice&amp;a=efx" target="_blank" rel="noopener noreferrer sponsored">
      </a>
    </div>

    

    

    <script>
      const el = (id) => document.getElementById(id);
      const esc = (s) => String(s ?? '').replace(/[&<>"']/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
      let DEBUG_LOGS = false;
      try {
        if (window.DEBUG_LOGS === true) {
          DEBUG_LOGS = true;
        } else if (typeof localStorage !== 'undefined' && localStorage.getItem('debugLogs') === '1') {
          DEBUG_LOGS = true;
        }
      } catch (_) {
        DEBUG_LOGS = false;
      }
      const debugLog = (...args) => { if (DEBUG_LOGS) console.log(...args); };
      const debugWarn = (...args) => { if (DEBUG_LOGS) console.warn(...args); };
      const status = (msg) => {
        el('status').textContent = msg || '';
        if (msg && DEBUG_LOGS) console.log('[App]', msg);
      };
      // Update top signal UI (dot color and Trade button)
      let lastSignal = 'hold';
      function updateSignalUI(sig, reason) {
        lastSignal = sig || 'hold';
        const dot = document.getElementById('signalDot');
        const btn = document.getElementById('btnTradeSignalTop');
        let color = '#999';
        if (lastSignal === 'buy') color = getComputedStyle(document.documentElement).getPropertyValue('--buy').trim() || '#2ecc71';
        if (lastSignal === 'sell') color = getComputedStyle(document.documentElement).getPropertyValue('--sell').trim() || '#e74c3c';
        if (dot) dot.style.background = color;
        if (btn) btn.disabled = !(lastSignal === 'buy' || lastSignal === 'sell');
        if (reason && DEBUG_LOGS) console.log('[Strategy]', lastSignal, reason);
      }

      // Read config from data-attributes (CSV → array)
      const cfgNode = document.getElementById('app-cfg');
      const _csv = cfgNode ? (cfgNode.getAttribute('data-symbols') || '') : '';
      const _def = cfgNode ? (cfgNode.getAttribute('data-default') || '') : '';
      const NEWS_AI_AVAILABLE = cfgNode ? (cfgNode.getAttribute('data-ai') === '1') : false;
      const APP_SYMBOLS = _csv ? _csv.split(',').map(s => s.trim()).filter(Boolean) : ['XAUUSD'];
      const APP_DEFAULT_SYMBOL = _def || (APP_SYMBOLS.length ? APP_SYMBOLS[0] : 'XAUUSD');
      debugLog('[App] Config symbols/default:', APP_SYMBOLS, APP_DEFAULT_SYMBOL);
      const DEFAULT_TF = "{{ default_tf }}";
      const DEFAULT_BARS = Number("{{ default_count }}") || 500;
      const DEFAULT_STL_AUTO_PERIOD = "{{ default_stl_auto_period }}";
      const DEFAULT_STL_MANUAL_PERIOD = Number("{{ default_stl_manual_period }}") || 30;
      const DEFAULT_CHART_SHIFT = "{{ default_chart_shift }}";
      const ALL_TFS = ['M1','M5','M15','M30','H1','H4','D1','W1','MN1','Y1'];
      const DEFAULT_TECH_WINDOW = 7;
      const TF_SECONDS = {
        M1: 60,
        M5: 300,
        M15: 900,
        M30: 1800,
        H1: 3600,
        H4: 14400,
        D1: 86400,
        W1: 604800,
        MN1: 2629746,
        Y1: 31556952,
      };
      const techHealthBarsInput = el('techHealthBars');
      const chartShiftInput = el('chkChartShift');
      let chartShiftOn = (DEFAULT_CHART_SHIFT !== '0');
      const getRightOffset = () => (chartShiftOn ? 20 : 0);
      const healthStrategySelect = el('healthStrategy');

      // Strong client-side memory for last selection (fallback if DB prefs are stale)
      const isValidSymbol = (s) => APP_SYMBOLS.includes(String(s || '').toUpperCase());
      const isValidTf = (tf) => ALL_TFS.includes(String(tf || '').toUpperCase());
      (function applyLocalSelectionFallback() {
        try {
          const lsSym = (localStorage.getItem('last_symbol') || '').toUpperCase();
          const lsTf = (localStorage.getItem('last_tf') || '').toUpperCase();
          const symSel = document.getElementById('symbol');
          const tfSel = document.getElementById('tf');
          if (symSel && isValidSymbol(lsSym)) { symSel.value = lsSym; }
          if (tfSel && isValidTf(lsTf)) { tfSel.value = lsTf; }
        } catch (_) { /* ignore */ }
      })();
      const HEALTH_STRATEGIES = [
        { value: 'forex_pair_compact_10q.json', label: 'FX Comprehensive (10)', kinds: ['forex_pair'] },
        { value: 'metal_pair_compact_10q.json', label: 'Metals Comprehensive (10)', kinds: ['forex_pair'] },
        { value: 'metal_pair_neutral_30q.json', label: 'Metals Neutral (30)', kinds: ['forex_pair'] },
        { value: 'forex_pair_neutral_30q.json', label: 'FX Neutral (30)', kinds: ['forex_pair'] },
        { value: 'forex_pair_30q_yes_no.json', label: 'FX Pair Yes/No (30)', kinds: ['forex_pair'] },
        { value: 'forex_30q_yes_no.json', label: 'FX Single Yes/No (30)', kinds: ['forex_pair'] },
        { value: 'stocks_compact_10q.json', label: 'Stocks Comprehensive (10)', kinds: ['stock'] },
        { value: 'stocks_30q_health_yes_no.json', label: 'Stocks Yes/No (30)', kinds: ['stock'] },
        // Intentionally exclude 'tech_snapshot_10q.json' from the Basic dropdown;
        // it's invoked via the separate Tech+AI button.
      ];
      let techHealthUserOverride = false;
      let healthStrategyUserOverride = false;
      const nextTimeframe = (tf) => {
        const idx = ALL_TFS.indexOf(tf);
        if (idx === -1 || idx >= ALL_TFS.length - 1) return null;
        return ALL_TFS[idx + 1];
      };
      const defaultTechWindow = (tf) => {
        const next = nextTimeframe(tf);
        const baseSeconds = TF_SECONDS[tf];
        const nextSeconds = next ? TF_SECONDS[next] : null;
        if (Number.isFinite(baseSeconds) && Number.isFinite(nextSeconds) && nextSeconds > baseSeconds) {
          const ratio = Math.round(nextSeconds / baseSeconds);
          if (Number.isFinite(ratio) && ratio > 0) return Math.max(ratio, 10);
        }
        return Math.max(DEFAULT_TECH_WINDOW, 10);
      };
      const applyTechWindowDefault = (force = false) => {
        if (!techHealthBarsInput) return;
        if (!force && techHealthUserOverride) return;
        const computed = defaultTechWindow(currentTf());
        techHealthUserOverride = false;
        techHealthBarsInput.value = String(computed);
      };
      const resolveTechWindow = () => {
        if (!techHealthBarsInput) return defaultTechWindow(currentTf());
        const raw = Number(techHealthBarsInput.value);
        if (Number.isFinite(raw) && raw > 0) {
          const clamped = Math.max(10, Math.min(500, Math.round(raw)));
          if (techHealthBarsInput.value !== String(clamped)) {
            techHealthBarsInput.value = String(clamped);
          }
          return clamped;
        }
        applyTechWindowDefault(true);
        return defaultTechWindow(currentTf());
      };
      if (healthStrategySelect) {
        healthStrategySelect.innerHTML = HEALTH_STRATEGIES
          .map((item) => `<option value="${item.value}">${esc(item.label)}</option>`)
          .join('');
      }
      const findStrategyMeta = (value) => HEALTH_STRATEGIES.find((item) => item.value === value);
      const defaultStrategyForKind = (kind) => {
        if (kind === 'forex_pair') {
          // For non-metals FX pairs, prefer the comprehensive 10Q template
          const fxDefault = HEALTH_STRATEGIES.find((item) => item.value === 'forex_pair_compact_10q.json');
          if (fxDefault) return fxDefault;
        }
        return HEALTH_STRATEGIES.find((item) => item.kinds.includes(kind)) || HEALTH_STRATEGIES[0];
      };
      const isMetalPair = (sym) => {
        const s = (sym || '').toUpperCase();
        if (!/^[A-Z]{6,7}$/.test(s)) return false;
        const base = s.slice(0,3);
        return base === 'XAU' || base === 'XAG';
      };
      const ensureStrategyForKind = (kind) => {
        if (!healthStrategySelect) return;
        const currentValue = healthStrategySelect.value;
        const currentMeta = findStrategyMeta(currentValue);
        // Prefer metals template for XAU/XAG pairs when user hasn't chosen explicitly
        const sym = (typeof currentSymbol === 'function') ? currentSymbol() : (symbolSelect && symbolSelect.value) || '';
        const preferMetal = kind === 'forex_pair' && isMetalPair(sym);
        const desiredValue = preferMetal ? 'metal_pair_compact_10q.json' : (defaultStrategyForKind(kind)?.value);
        if (!healthStrategyUserOverride || !currentMeta || !currentMeta.kinds.includes(kind) || (preferMetal && currentValue !== desiredValue)) {
          if (desiredValue) {
            healthStrategyUserOverride = false;
            healthStrategySelect.value = desiredValue;
          }
        }
      };

      const DEFAULT_CHART_TYPE = "{{ default_chart_type }}";
      const symbolSelect = document.getElementById('symbol');
      const tfSelect = document.getElementById('tf');
      const countInput = document.getElementById('count');
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      const lwContainer = document.getElementById('lwChart');
      let curType = (DEFAULT_CHART_TYPE === 'line') ? 'line' : 'candlestick';
      let chart = null;
      let lwChart = null;
      let lwLastTimes = [];
      let periodBoundaryTimes = [];
      let periodAnchorTime = null;
      let usePeriodGrid = false; // disable vertical grid; use markers instead
      let lwOverlayDpr = (window.devicePixelRatio || 1);
      let lwSeries = null;
      let lwBollingerUpper = null;
      let lwBollingerLower = null;
      let lwBollingerMid = null;
      let lwObserver = null;
      let lwTimeRangeSubscribed = false;
      let currentTimeRange = null;
      let currentLogicalRange = null;
      let stlTrendSeries = null;
      let stlSeasonSeries = null;
      let stlResidSeries = null;
      let stlLastMeta = null;
      let stlLastRows = [];
      let stlAllData = true;
      let stlPendingCompute = false;
      let stlDatasetRange = null;
      let stlSelectedRunId = null;
      let stlTargetStart = null;
      let stlTargetEnd = null;
      let stlLastPeriod = null;
      let stlTrendPoints = [];
      let stlSeasonPoints = [];
      let stlResidPoints = [];
      let stlSpeedPoints = [];
      let stlAccelPoints = [];
      const stlAllToggle = el('chkStlAllData');
      const stlAutoToggle = el('chkStlAutoPeriod');
      const stlPeriodInput = el('stlPeriodInput');
      const stlStartInput = el('stlStart');
      const stlEndInput = el('stlEnd');
      const stlRunsSelect = el('stlRuns');
      const stlDeleteBtn = el('btnStlDelete');
      const stlOverlayControls = el('stlOverlayControls');
      const STL_OVERLAY_TFS = ['M1','M5','M15','M30','H1','H4','D1','W1','MN1','Y1'];
      const STL_OVERLAY_COLORS = {
        M1: '#006064',
        M5: '#00838f',
        M15: '#7e57c2',
        M30: '#5e35b1',
        H1: '#1e88e5',
        H4: '#fb8c00',
        D1: '#43a047',
        W1: '#f4511e',
        MN1: '#6d4c41',
        Y1: '#8d6e63',
      };
      const stlOverlaySeries = new Map();
      const stlOverlayData = new Map();
      const stlOverlayInputs = new Map();
      const stlOverlayLoading = new Map();
      const stlOverlayPending = new Set();
      let stlAutoPeriod = !(DEFAULT_STL_AUTO_PERIOD === '0' || DEFAULT_STL_AUTO_PERIOD === 'false');
      let stlManualPeriod = DEFAULT_STL_MANUAL_PERIOD;
      const stlPeriodLinesToggle = el('chkStlPeriodLines');
      const stlDerivativeToggle = el('chkStlDerivative');
      const stlAccelerationToggle = el('chkStlAcceleration');
      let showPeriodLines = false;

      const volumeCanvas = document.getElementById('volChart');
      const rsiCanvas = document.getElementById('rsiChart');
      const macdCanvas = document.getElementById('macdChart');
      const volumeCtx = volumeCanvas ? volumeCanvas.getContext('2d') : null;
      const rsiCtx = rsiCanvas ? rsiCanvas.getContext('2d') : null;
      const macdCtx = macdCanvas ? macdCanvas.getContext('2d') : null;
      let volumeChart = null;
      let rsiChart = null;
      let macdChart = null;

      let lastPriceRows = [];

      let indicatorRangeMs = null;

      // Lightweight Charts indicator panes

      let lwVolChart = null, lwVolSeries = null;

      let lwRsiChart = null, lwRsiSeries = null;

      let lwMacdChart = null, lwMacdHist = null, lwMacdLine = null, lwMacdSignal = null;

      let lwAtrChart = null, lwAtrSeries = null;
      let lwAdxChart = null, lwAdxLine = null, lwAdxPlus = null, lwAdxMinus = null;

      let lwDerivChart = null, lwDerivSpeedSeries = null, lwDerivAccelSeries = null;

      // Overlay canvas for dashed period lines on the candlestick chart
      let lwOverlay = null, lwOverlayCtx = null;
      let chartPeriodWindows = [];

      let lwSyncing = false;
      let lwRangeTimer = null;
      let lwSubscriptionsEnabled = false;
      let lwVolSubscribed = false, lwRsiSubscribed = false, lwMacdSubscribed = false; // sync disabled
      let lwDerivSubscribed = false;
      let lwAtrSubscribed = false, lwAdxSubscribed = false;
      let lwVolHasData = false, lwRsiHasData = false, lwMacdHasData = false;
      let lwDerivHasSpeed = false, lwDerivHasAccel = false;

      // Cached indicators for chip computation
      let lastRsiValues = [];
      let lastMacdObj = { macd: [], signal: [], histogram: [] };
      let lastAtrValues = [];
      let lastAdxObj = { adx: [], plusDI: [], minusDI: [] };
      let lastVolumesArr = [];
      let indicatorSignals = {};

      const PREF_ENDPOINT = '/api/preferences';
      let prefQueue = {};
      let prefTimer = null;
      let chartRefreshTimer = null;
      
      let lwInitialFitted = false;

      const btnNews = el('btnNews');
      const btnNewsFull = el('btnNewsFull');
      const newsStatus = el('newsStatus');
      let newsRefreshTimer = null;
      let lastNewsUpdatedAt = null;
      const NEWS_BUTTON_DEFAULT = btnNews ? btnNews.textContent || 'Refresh News' : 'Refresh News';

      const setNewsStatus = (message, tone = 'info') => {
        if (!newsStatus) return;
        let color = 'var(--muted)';
        if (tone === 'ok') color = 'var(--accent)';
        if (tone === 'error') color = 'var(--sell)';
        if (tone === 'warn') color = '#fb8c00';
        newsStatus.style.color = color;
        newsStatus.textContent = message || '';
      };

      const currentSymbol = () => (symbolSelect && symbolSelect.value ? symbolSelect.value.trim().toUpperCase() : APP_DEFAULT_SYMBOL);
      const currentTf = () => (tfSelect && tfSelect.value ? tfSelect.value.trim().toUpperCase() : DEFAULT_TF);
      const currentBarsLimit = () => Math.max(10, Number(countInput && countInput.value ? countInput.value : DEFAULT_BARS) || DEFAULT_BARS);
      applyTechWindowDefault(true);
      ensureStrategyForKind(isFxPair(currentSymbol()) ? 'forex_pair' : 'stock');

      // Trade AI model preference
      const aiModelSelect = el('aiModelSelect');
      const getTradeAiModel = () => {
        const val = aiModelSelect && aiModelSelect.value ? aiModelSelect.value.trim() : '';
        return val || 'gpt-5';
      };
      if (aiModelSelect) {
        aiModelSelect.value = 'gpt-5';
        aiModelSelect.addEventListener('change', () => {
          const model = getTradeAiModel();
          try { queuePrefUpdate('trade_ai_model', model); } catch (e) {}
        });
        // Load saved preference (non-blocking)
        (async () => {
          try {
            const r = await fetch(`${PREF_ENDPOINT}?keys=trade_ai_model`, { cache: 'no-store' });
            const js = await r.json();
            const saved = js && js.prefs && js.prefs.trade_ai_model;
            if (saved && typeof saved === 'string') {
              aiModelSelect.value = saved;
            }
          } catch {}
        })();
      }

      const isoToLocalInput = (iso) => {
        if (!iso) return '';
        const date = new Date(iso);
        if (Number.isNaN(date.getTime())) return '';
        const pad = (v) => String(v).padStart(2, '0');
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      };

      const localInputToIso = (value) => {
        if (!value) return null;
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return null;
        return date.toISOString();
      };

      function updateStlInputsFromState() {
        if (stlAllToggle) stlAllToggle.checked = !!stlAllData;
        if (stlAutoToggle) stlAutoToggle.checked = !!stlAutoPeriod;
        if (stlPeriodInput) {
          stlPeriodInput.disabled = !!stlAutoPeriod;
          const effective = Number.isFinite(stlManualPeriod) && stlManualPeriod > 0 ? Math.round(stlManualPeriod) : DEFAULT_STL_MANUAL_PERIOD;
          stlPeriodInput.value = effective;
        }
        if (stlPeriodLinesToggle) stlPeriodLinesToggle.checked = !!showPeriodLines;
        const disableRange = !!stlAllData;
        if (stlStartInput) {
          stlStartInput.disabled = disableRange;
          stlStartInput.value = disableRange ? '' : (stlTargetStart ? isoToLocalInput(stlTargetStart) : stlStartInput.value);
        }
        if (stlEndInput) {
          stlEndInput.disabled = disableRange;
          stlEndInput.value = disableRange ? '' : (stlTargetEnd ? isoToLocalInput(stlTargetEnd) : stlEndInput.value);
        }
        if (stlRunsSelect && stlRunsSelect.options.length === 0) {
          stlRunsSelect.innerHTML = '<option value=\"\">Latest (auto)</option>';
        }
      if (stlDeleteBtn) stlDeleteBtn.disabled = !stlSelectedRunId;
      }

      const formatDateShort = (iso) => {
        if (!iso) return '';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return iso;
        return d.toISOString().slice(0, 10);
      };

      const formatDateTime = (iso) => {
        if (!iso) return '';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return iso;
        return d.toISOString().slice(0, 16).replace('T', ' ');
      };

      const formatEpochDateTime = (epochSec) => {
        if (!Number.isFinite(epochSec)) return '';
        const d = new Date(epochSec * 1000);
        if (Number.isNaN(d.getTime())) return '';
        return d.toISOString().slice(0, 16).replace('T', ' ');
      };

      const formatTechNumber = (value) => {
        if (!Number.isFinite(value)) return '—';
        const abs = Math.abs(value);
        if (abs >= 100000) return value.toFixed(0);
        if (abs >= 1000) return value.toFixed(2);
        if (abs >= 100) return value.toFixed(3);
        if (abs >= 1) return value.toFixed(4);
        if (abs >= 0.01) return value.toFixed(6);
        return value.toFixed(8);
      };

      function populateStlRuns(runs, selectedId) {
        if (!stlRunsSelect) return;
        stlRunsSelect.innerHTML = '';
        stlRunsSelect.appendChild(new Option('Latest (auto)', ''));
        if (Array.isArray(runs)) {
          runs.forEach((run) => {
            if (!run) return;
            const label = `${formatDateShort(run.start_ts)} → ${formatDateShort(run.end_ts)} • P${run.period}`;
            const opt = new Option(label, String(run.id));
            if (selectedId && String(run.id) === String(selectedId)) opt.selected = true;
            stlRunsSelect.appendChild(opt);
          });
        }
        if (!selectedId) stlRunsSelect.value = '';
        if (stlDeleteBtn) stlDeleteBtn.disabled = !stlRunsSelect.value;
      }

      function updateIndicatorCharts(rows) {
        if (Array.isArray(rows) && rows.length) {
          lastPriceRows = rows.slice();
        } else {
          lastPriceRows = [];
        }
        if (currentTimeRange) {
          applyIndicatorViewport(currentTimeRange, currentLogicalRange);
        } else {
          indicatorRangeMs = null;
          updateIndicatorDisplay(lastPriceRows);
        }
        // Compute and cache indicator values for chips
        try {
          lastVolumesArr = rows.map((r) => {
            const cand = [r.real_volume, r.tick_volume, r.volume]
              .map((v) => Number(v))
              .filter((v) => Number.isFinite(v) && v > 0);
            return cand.length ? cand[0] : 0;
          });
          const closes = rows.map((r) => Number.isFinite(Number(r.close)) ? Number(r.close) : 0);
          lastRsiValues = computeRSI(closes) || [];
          lastMacdObj = computeMACD(closes) || { macd: [], signal: [], histogram: [] };
          // ATR/ADX
          ensureLwAtr();
          ensureLwAdx();
          const atrObj = computeAtrSeries(rows) || { atr: [], tr: [] };
          lastAtrValues = atrObj.atr || [];
          const adxObj = computeAdxSeries(rows, atrObj.tr) || { adx: [], plusDI: [], minusDI: [] };
          lastAdxObj = adxObj;
          if (lwAtrSeries) {
            const pts = rows.map((row, i) => ({ time: Math.floor(new Date(row.ts).getTime() / 1000), value: Number(lastAtrValues[i] || 0) }));
            lwAtrSeries.setData(pts.filter(p => Number.isFinite(p.value)));
          }
          if (lwAdxLine && lwAdxPlus && lwAdxMinus) {
            const toPts = (arr) => rows.map((row, i) => {
              const v = Number(arr[i]);
              return (Number.isFinite(v) ? { time: Math.floor(new Date(row.ts).getTime() / 1000), value: v } : null);
            }).filter(Boolean);
            lwAdxLine.setData(toPts(lastAdxObj.adx || []));
            lwAdxPlus.setData(toPts(lastAdxObj.plusDI || []));
            lwAdxMinus.setData(toPts(lastAdxObj.minusDI || []));
          }
          // Recompute signals and redraw chips
          computeIndicatorSignals();
          redrawPeriodLines();
        } catch (err) { /* ignore signal computation errors */ }
      }
      const flushPrefQueue = async () => {
        if (!Object.keys(prefQueue).length) {
          prefTimer = null;
          return;
        }
        const payload = prefQueue;
        prefQueue = {};
        prefTimer = null;
        try {
          await fetch(PREF_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            cache: 'no-store',
            body: JSON.stringify(payload),
          });
        } catch (err) {
          debugWarn('[App] Preference update failed', err);
        }
      };

      const queuePrefUpdate = (key, value) => {
        if (!key) return;
        prefQueue[key] = value ?? '';
        if (!prefTimer) {
          prefTimer = setTimeout(flushPrefQueue, 400);
        }
      };

      const scheduleChartRefresh = (reason) => {
        if (chartRefreshTimer) {
          clearTimeout(chartRefreshTimer);
        }
        chartRefreshTimer = setTimeout(async () => {
          chartRefreshTimer = null;
          try {
            debugLog('[App] Refreshing chart due to', reason);
            await refreshChart();
          } catch (err) {
            debugWarn('[App] Chart refresh failed for', reason, err);
          }
        }, 400);
      };

      const scheduleNewsRefresh = (reason) => {
        if (newsRefreshTimer) {
          clearTimeout(newsRefreshTimer);
        }
        newsRefreshTimer = setTimeout(async () => {
          newsRefreshTimer = null;
          try {
            debugLog('[App] Refreshing news due to', reason);
            await refreshNews({ reason, disableButton: false });
          } catch (err) {
            debugWarn('[App] News refresh failed for', reason, err);
          }
        }, 350);
      };

      const newsAnalysisCache = new Map();
      let healthState = { kind: null, offset: 0, strategy: null, excludeStrategy: null };
      const chartPeriodPluginId = 'periodOverlay';
      if (window.Chart && window.Chart.register && !window.__periodOverlayRegistered) {
        const periodOverlayPlugin = {
          id: chartPeriodPluginId,
          beforeDraw(chart) {
            if (!chartPeriodWindows.length) return;
            const { ctx, chartArea, scales } = chart;
            if (!chartArea || !scales || !scales.x) return;
            const xScale = scales.x;
            const { top, bottom } = chartArea;
            ctx.save();
            chartPeriodWindows.forEach((windowInfo, idx) => {
              const startPx = xScale.getPixelForValue(windowInfo.start.valueOf());
              const endPx = xScale.getPixelForValue(windowInfo.end.valueOf());
              if (!Number.isFinite(startPx) || !Number.isFinite(endPx) || endPx <= startPx) {
                return;
              }
              const shadeColor = idx % 2 === 0 ? 'rgba(216, 67, 21, 0.05)' : 'rgba(216, 67, 21, 0.12)';
              ctx.fillStyle = shadeColor;
              ctx.fillRect(startPx, top, endPx - startPx, bottom - top);
              ctx.strokeStyle = 'rgba(216, 67, 21, 0.4)';
              ctx.setLineDash([6, 6]);
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(startPx, top);
              ctx.lineTo(startPx, bottom);
              ctx.stroke();
              if (idx === chartPeriodWindows.length - 1) {
                ctx.beginPath();
                ctx.moveTo(endPx, top);
                ctx.lineTo(endPx, bottom);
                ctx.stroke();
              }
            });
            ctx.setLineDash([]);
            ctx.restore();
          },
        };
        window.Chart.register(periodOverlayPlugin);
        window.__periodOverlayRegistered = true;
      }

      const newsArticleKey = (article) => {
        if (!article) return '';
        return (
          article.url ||
          article.id ||
          article.article_id ||
          `${article.title || article.headline || ''}|${article.publishedAt || article.published_at || article.date || ''}`
        );
      };

      const computeEMA = (series, period) => {
        const ema = new Array(series.length).fill(null);
        if (!Array.isArray(series) || series.length === 0) return ema;
        const multiplier = 2 / (period + 1);
        let sum = 0;
        let count = 0;
        let firstIdx = -1;
        for (let i = 0; i < series.length; i++) {
          const value = series[i];
          if (value == null) {
            continue;
          }
          if (firstIdx === -1) {
            firstIdx = i;
          }
          sum += value;
          count += 1;
          if (count === period) {
            const avg = sum / period;
            ema[i] = avg;
            let prev = avg;
            for (let j = i + 1; j < series.length; j++) {
              const nextVal = series[j];
              if (nextVal == null) {
                ema[j] = null;
                continue;
              }
              prev = ((nextVal - prev) * multiplier) + prev;
              ema[j] = prev;
            }
            break;
          }
        }
        return ema;
      };

      const computeRSI = (values, period = 14) => {
        const result = new Array(values.length).fill(null);
        if (!Array.isArray(values) || values.length <= period) return result;
        let gains = 0;
        let losses = 0;
        for (let i = 1; i <= period; i++) {
          const delta = values[i] - values[i - 1];
          if (delta >= 0) {
            gains += delta;
          } else {
            losses += Math.abs(delta);
          }
        }
        let avgGain = gains / period;
        let avgLoss = losses / period;
        result[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
        for (let i = period + 1; i < values.length; i++) {
          const delta = values[i] - values[i - 1];
          const gain = delta > 0 ? delta : 0;
          const loss = delta < 0 ? Math.abs(delta) : 0;
          avgGain = ((avgGain * (period - 1)) + gain) / period;
          avgLoss = ((avgLoss * (period - 1)) + loss) / period;
          if (avgLoss === 0) {
            result[i] = 100;
          } else {
            const rs = avgGain / avgLoss;
            result[i] = 100 - (100 / (1 + rs));
          }
        }
        return result;
      };

      const computeMACD = (values, fast = 12, slow = 26, signal = 9) => {
        const macdLine = new Array(values.length).fill(null);
        const signalLine = new Array(values.length).fill(null);
        const histogram = new Array(values.length).fill(null);
        if (!Array.isArray(values) || values.length === 0) {
          return { macd: macdLine, signal: signalLine, histogram };
        }
        const fastEma = computeEMA(values, fast);
        const slowEma = computeEMA(values, slow);
        for (let i = 0; i < values.length; i++) {
          const fastVal = fastEma[i];
          const slowVal = slowEma[i];
          if (fastVal != null && slowVal != null) {
            macdLine[i] = fastVal - slowVal;
          }
        }
        const signalEma = computeEMA(macdLine, signal);
        for (let i = 0; i < values.length; i++) {
          const sigVal = signalEma[i];
          if (sigVal != null) {
            signalLine[i] = sigVal;
          }
          const macdVal = macdLine[i];
          if (macdVal != null && sigVal != null) {
            histogram[i] = macdVal - sigVal;
          }
        }
        return { macd: macdLine, signal: signalLine, histogram };
      };

      const computeTrueRangeSeries = (rows) => {
        if (!Array.isArray(rows)) return [];
        const out = new Array(rows.length).fill(null);
        for (let i = 0; i < rows.length; i += 1) {
          const high = Number(rows[i]?.high);
          const low = Number(rows[i]?.low);
          if (!Number.isFinite(high) || !Number.isFinite(low)) {
            out[i] = null;
            continue;
          }
          const base = Math.abs(high - low);
          if (i === 0) {
            out[i] = base;
            continue;
          }
          const prevClose = Number(rows[i - 1]?.close);
          if (!Number.isFinite(prevClose)) {
            out[i] = base;
            continue;
          }
          const range2 = Math.abs(high - prevClose);
          const range3 = Math.abs(low - prevClose);
          out[i] = Math.max(base, range2, range3);
        }
        return out;
      };

      const computeAtrSeries = (rows, period = 14) => {
        const tr = computeTrueRangeSeries(rows);
        const atr = new Array(tr.length).fill(null);
        if (!tr.length) return { atr, tr };
        let sum = 0;
        for (let i = 0; i < tr.length; i += 1) {
          const value = Number(tr[i]);
          sum += Number.isFinite(value) ? value : 0;
          if (i >= period) {
            const drop = Number(tr[i - period]);
            sum -= Number.isFinite(drop) ? drop : 0;
          }
          if (i >= period - 1) {
            const denom = Math.min(period, i + 1);
            atr[i] = denom > 0 ? sum / denom : null;
          }
        }
        return { atr, tr };
      };

      const computeAdxSeries = (rows, trSeries, period = 14) => {
        const len = Array.isArray(rows) ? rows.length : 0;
        const adx = new Array(len).fill(null);
        const plusDI = new Array(len).fill(null);
        const minusDI = new Array(len).fill(null);
        if (!len) return { adx, plusDI, minusDI };
        const plusDM = new Array(len).fill(0);
        const minusDM = new Array(len).fill(0);
        for (let i = 1; i < len; i += 1) {
          const high = Number(rows[i]?.high);
          const low = Number(rows[i]?.low);
          const prevHigh = Number(rows[i - 1]?.high);
          const prevLow = Number(rows[i - 1]?.low);
          if (!Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(prevHigh) || !Number.isFinite(prevLow)) {
            plusDM[i] = 0;
            minusDM[i] = 0;
            continue;
          }
          const upMove = high - prevHigh;
          const downMove = prevLow - low;
          plusDM[i] = (upMove > downMove && upMove > 0) ? upMove : 0;
          minusDM[i] = (downMove > upMove && downMove > 0) ? downMove : 0;
        }
        let sumTR = 0;
        let sumPlus = 0;
        let sumMinus = 0;
        const dxWindow = [];
        let dxSum = 0;
        for (let i = 0; i < len; i += 1) {
          const trVal = Number(trSeries?.[i]);
          const plusVal = plusDM[i] || 0;
          const minusVal = minusDM[i] || 0;
          sumTR += Number.isFinite(trVal) ? trVal : 0;
          sumPlus += plusVal;
          sumMinus += minusVal;
          if (i >= period) {
            const oldTr = Number(trSeries?.[i - period]);
            sumTR -= Number.isFinite(oldTr) ? oldTr : 0;
            sumPlus -= plusDM[i - period] || 0;
            sumMinus -= minusDM[i - period] || 0;
          }
          if (i >= period - 1 && sumTR > 0) {
            const plusPct = (sumPlus / sumTR) * 100;
            const minusPct = (sumMinus / sumTR) * 100;
            plusDI[i] = plusPct;
            minusDI[i] = minusPct;
            const denom = plusPct + minusPct;
            const dx = denom === 0 ? 0 : (Math.abs(plusPct - minusPct) / denom) * 100;
            dxWindow.push(dx);
            dxSum += dx;
            if (dxWindow.length > period) {
              dxSum -= dxWindow.shift();
            }
            adx[i] = dxWindow.length ? dxSum / dxWindow.length : dx;
          }
        }
        return { adx, plusDI, minusDI };
      };

      const computeBollingerBands = (values, period = 20, stdMultiplier = 2) => {
        const upper = new Array(values.length).fill(null);
        const lower = new Array(values.length).fill(null);
        const middle = new Array(values.length).fill(null);
        if (!Array.isArray(values) || values.length < period) {
          return { upper, lower, middle };
        }
        const window = [];
        for (let i = 0; i < values.length; i++) {
          const val = values[i];
          if (val == null) {
            window.length = 0;
            continue;
          }
          window.push(val);
          if (window.length > period) {
            window.shift();
          }
          if (window.length === period) {
            const mean = window.reduce((acc, v) => acc + v, 0) / period;
            const variance = window.reduce((acc, v) => acc + (v - mean) ** 2, 0) / period;
            const std = Math.sqrt(variance);
            middle[i] = mean;
            upper[i] = mean + stdMultiplier * std;
            lower[i] = mean - stdMultiplier * std;
          }
        }
        return { upper, lower, middle };
      };

      const ensureVolumeChart = () => {
        if (volumeChart || !volumeCtx) return;
        volumeChart = new window.Chart(volumeCtx, {
          type: 'bar',
          parsing: false,
          data: {
            labels: [],
            datasets: [
              {
                label: 'Volume',
                data: [],
                backgroundColor: 'rgba(25, 118, 210, 0.35)',
                borderWidth: 0,
                barPercentage: 1.0,
                categoryPercentage: 1.0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                type: 'time',
                time: { tooltipFormat: 'MMM d HH:mm' },
                bounds: 'ticks',
                offset: false,
                ticks: { maxRotation: 0, autoSkip: true },
                grid: { display: false },
              },
              y: {
                position: 'right',
                beginAtZero: true,
                title: { display: false },
                grid: { color: '#e0e6ef' },
              },
            },
          },
        });
      };

      const ensureRsiChart = () => {
        if (rsiChart || !rsiCtx) return;
        rsiChart = new window.Chart(rsiCtx, {
          type: 'line',
          parsing: false,
          data: {
            labels: [],
            datasets: [
              {
                label: 'RSI',
                data: [],
                borderColor: '#8e24aa',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.15,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            interaction: { intersect: false, mode: 'index' },
            scales: {
              x: {
                type: 'time',
                time: { tooltipFormat: 'MMM d HH:mm' },
                bounds: 'ticks',
                offset: false,
                ticks: { maxRotation: 0, autoSkip: true },
                grid: { display: false },
              },
              y: {
                position: 'right',
                min: 0,
                max: 100,
                ticks: { stepSize: 20 },
                grid: { color: '#e0e6ef' },
              },
            },
          },
        });
      };

      const ensureLwVol = () => {
        if (!lwVolChart) {
          const elVol = document.getElementById('lwVol');
          if (!elVol) return;
          lwVolChart = LightweightCharts.createChart(elVol, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwVolSeries && lwVolChart) {
          lwVolSeries = lwVolChart.addHistogramSeries({
            base: 0,
            priceFormat: { type: 'volume' },
            color: 'rgba(120, 144, 156, 0.4)',
          });
        }
        if (!lwVolSubscribed && lwVolChart) {
          lwVolChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwVolChart);
          });
          lwVolSubscribed = true;
        }
      };

      // Account Balance pane
      let lwBalanceChart = null;
      let lwBalanceSeries = null;
      let lwBalanceSubscribed = false;
      const ensureLwBalance = () => {
        if (!lwBalanceChart) {
          const elBal = document.getElementById('lwBalance');
          if (!elBal) return;
          lwBalanceChart = LightweightCharts.createChart(elBal, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (lwBalanceChart && !lwBalanceSeries) {
          lwBalanceSeries = lwBalanceChart.addLineSeries({ color: '#1b5e20', lineWidth: 2 });
        }
        if (!lwBalanceSubscribed && lwBalanceChart) {
          lwBalanceChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwBalanceChart);
          });
          lwBalanceSubscribed = true;
        }
      };

      async function refreshBalanceSeries() {
        try {
          const r = await fetch('/api/account/balance_series?user=lachlan&limit=1000', { cache: 'no-store' });
          const js = await r.json();
          if (!r.ok || !js || js.ok !== true) return;
          ensureLwBalance();
          if (!lwBalanceSeries) return;
          const points = (js.rows || []).map(row => ({ time: Math.floor(new Date(row.ts).getTime()/1000), value: Number(row.balance) }));
          lwBalanceSeries.setData(points);
        } catch (e) {
          // ignore
        }
      }

      const ensureLwDeriv = () => {
        if (!lwDerivChart) {
          const elDeriv = document.getElementById('lwDeriv');
          if (!elDeriv) return;
          lwDerivChart = LightweightCharts.createChart(elDeriv, {
            rightPriceScale: { visible: true, scaleMargins: { top: 0.2, bottom: 0.2 } },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (lwDerivChart && !lwDerivSpeedSeries) {
          const dashed = (LightweightCharts && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dashed !== undefined)
            ? LightweightCharts.LineStyle.Dashed
            : (LightweightCharts && LightweightCharts.LineStyle ? LightweightCharts.LineStyle.Solid : 2);
          lwDerivSpeedSeries = lwDerivChart.addLineSeries({
            color: '#d84315',
            lineWidth: 2,
            lineStyle: dashed,
          });
        }
        if (lwDerivChart && !lwDerivAccelSeries) {
          const dotted = (LightweightCharts && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dotted !== undefined)
            ? LightweightCharts.LineStyle.Dotted
            : (LightweightCharts && LightweightCharts.LineStyle ? LightweightCharts.LineStyle.Solid : 3);
          lwDerivAccelSeries = lwDerivChart.addLineSeries({
            color: '#8e24aa',
            lineWidth: 1.5,
            lineStyle: dotted,
          });
        }
        if (!lwDerivSubscribed && lwDerivChart) {
          lwDerivChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwDerivChart);
          });
          lwDerivSubscribed = true;
        }
      };

      const ensureLwRsi = () => {
        if (!lwRsiChart) {
          const elRsi = document.getElementById('lwRsi');
          if (!elRsi) return;
          lwRsiChart = LightweightCharts.createChart(elRsi, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwRsiSeries && lwRsiChart) {
          lwRsiSeries = lwRsiChart.addLineSeries({ color: '#8e24aa', lineWidth: 2 });
        }
        if (!lwRsiSubscribed && lwRsiChart) {
          lwRsiChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwRsiChart);
          });
          lwRsiSubscribed = true;
        }
      };

const ensureLwMacd = () => {
  if (!lwMacdChart) {
          const elMacd = document.getElementById('lwMacd');
          if (!elMacd) return;
          lwMacdChart = LightweightCharts.createChart(elMacd, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (lwMacdChart && !lwMacdHist) {
          lwMacdHist = lwMacdChart.addHistogramSeries({ base: 0 });
        }
        if (lwMacdChart && !lwMacdLine) {
          lwMacdLine = lwMacdChart.addLineSeries({ color: '#1b9aaa', lineWidth: 2 });
        }
        if (lwMacdChart && !lwMacdSignal) {
          lwMacdSignal = lwMacdChart.addLineSeries({ color: '#ef6c00', lineWidth: 2 });
        }
        if (!lwMacdSubscribed && lwMacdChart) {
          lwMacdChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwMacdChart);
          });
          lwMacdSubscribed = true;
  }
};

      const ensureLwAtr = () => {
        if (!lwAtrChart) {
          const el = document.getElementById('lwAtr');
          if (!el) return;
          lwAtrChart = LightweightCharts.createChart(el, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwAtrSeries && lwAtrChart) {
          lwAtrSeries = lwAtrChart.addLineSeries({ color: '#455a64', lineWidth: 2 });
        }
        if (!lwAtrSubscribed && lwAtrChart) {
          lwAtrChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwAtrChart);
          });
          lwAtrSubscribed = true;
        }
      };

      const ensureLwAdx = () => {
        if (!lwAdxChart) {
          const el = document.getElementById('lwAdx');
          if (!el) return;
          lwAdxChart = LightweightCharts.createChart(el, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwAdxLine && lwAdxChart) {
          lwAdxLine = lwAdxChart.addLineSeries({ color: '#1976d2', lineWidth: 2 });
        }
        if (!lwAdxPlus && lwAdxChart) {
          lwAdxPlus = lwAdxChart.addLineSeries({ color: '#2ecc71', lineWidth: 1.5 });
        }
        if (!lwAdxMinus && lwAdxChart) {
          lwAdxMinus = lwAdxChart.addLineSeries({ color: '#e74c3c', lineWidth: 1.5 });
        }
        if (!lwAdxSubscribed && lwAdxChart) {
          lwAdxChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwAdxChart);
          });
          lwAdxSubscribed = true;
        }
      };

      function updateStlDerivativeSeries() {
        ensureLwDeriv();
        const showSpeed = !stlDerivativeToggle || !!stlDerivativeToggle.checked;
        const showAccel = !stlAccelerationToggle || !!stlAccelerationToggle.checked;
        if (lwDerivSpeedSeries) {
          lwDerivSpeedSeries.setData(showSpeed ? stlSpeedPoints : []);
        }
        if (lwDerivAccelSeries) {
          lwDerivAccelSeries.setData(showAccel ? stlAccelPoints : []);
        }
        const combinedValues = [];
        if (showSpeed) {
          stlSpeedPoints.forEach((pt) => combinedValues.push(Number(pt.value) || 0));
        }
        if (showAccel) {
          stlAccelPoints.forEach((pt) => combinedValues.push(Number(pt.value) || 0));
        }
        const maxAbs = combinedValues.reduce((acc, val) => Math.max(acc, Math.abs(val)), 0);
        const range = maxAbs > 0 ? maxAbs * 1.05 : 1;
        const provider = () => ({ priceRange: { minValue: -range, maxValue: range } });
        if (lwDerivSpeedSeries && typeof lwDerivSpeedSeries.setAutoscaleInfoProvider === 'function') {
          lwDerivSpeedSeries.setAutoscaleInfoProvider(provider);
        }
        if (lwDerivAccelSeries && typeof lwDerivAccelSeries.setAutoscaleInfoProvider === 'function') {
          lwDerivAccelSeries.setAutoscaleInfoProvider(provider);
        }
        if (lwDerivChart) {
          lwDerivChart.priceScale('right').applyOptions({ scaleMargins: { top: 0.2, bottom: 0.2 } });
        }
        lwDerivHasSpeed = showSpeed && stlSpeedPoints.length > 0;
        lwDerivHasAccel = showAccel && stlAccelPoints.length > 0;
      }

      const ensureLwOverlay = () => {
        if (!lwContainer) return;
        if (!lwOverlay) {
          lwOverlay = document.createElement('canvas');
          lwOverlay.id = 'lwOverlay';
          lwOverlay.className = 'lw-overlay';
          lwContainer.appendChild(lwOverlay);
          lwOverlayCtx = lwOverlay.getContext('2d');
        }
        resizeLwOverlay();
      };

      const resizeLwOverlay = () => {
        if (!lwOverlay || !lwContainer) return;
        const rect = lwContainer.getBoundingClientRect();
        const cssW = Math.max(1, Math.floor(rect.width || lwContainer.clientWidth || 0));
        const cssH = Math.max(1, Math.floor(rect.height || lwContainer.clientHeight || 0));
        const dpr = (window.devicePixelRatio || 1);
        lwOverlayDpr = dpr;
        // Size internal buffer by DPR for crisp alignment
        const bufW = Math.max(1, Math.floor(cssW * dpr));
        const bufH = Math.max(1, Math.floor(cssH * dpr));
        if (lwOverlay.width !== bufW) lwOverlay.width = bufW;
        if (lwOverlay.height !== bufH) lwOverlay.height = bufH;
        // Ensure CSS size matches container
        lwOverlay.style.width = cssW + 'px';
        lwOverlay.style.height = cssH + 'px';
        if (lwOverlayCtx) {
          // Reset and scale to CSS pixel space
          lwOverlayCtx.setTransform(1, 0, 0, 1, 0, 0);
          lwOverlayCtx.clearRect(0, 0, bufW, bufH);
          lwOverlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        redrawPeriodLines();
      };

      const clearLwOverlay = () => {
        if (!lwOverlayCtx || !lwOverlay) return;
        lwOverlayCtx.clearRect(0, 0, lwOverlay.width, lwOverlay.height);
      };

      const drawLwPeriodLines = (period) => {
        if (!showPeriodLines || !usePeriodGrid || !lwChart || !lwOverlayCtx || !lastPriceRows.length || !period || period < 1) {
          clearLwOverlay();
          // Still draw chips even when lines disabled
          drawSignalChips();
          return;
        }
        const vis = lwChart.timeScale().getVisibleRange();
        if (!vis || vis.from == null || vis.to == null) {
          clearLwOverlay();
          return;
        }
        const fromSec = vis.from;
        const toSec = vis.to;
        const cssH = Math.max(1, Math.floor(lwContainer.clientHeight || lwOverlay.clientHeight || 0));
        const ctx = lwOverlayCtx;
        // Clear in CSS pixel space
        ctx.save();
        ctx.setTransform(lwOverlayDpr, 0, 0, lwOverlayDpr, 0, 0);
        ctx.clearRect(0, 0, lwOverlay.width / lwOverlayDpr, lwOverlay.height / lwOverlayDpr);
        ctx.save();
        ctx.strokeStyle = 'rgba(216, 67, 21, 0.6)';
        ctx.setLineDash([6, 5]);
        ctx.lineWidth = 1;
        // Use precomputed boundary times anchored to a specific bar time
        const times = Array.isArray(periodBoundaryTimes) ? periodBoundaryTimes : [];
        for (const tSec of times) {
          if (tSec < fromSec - period * 60 || tSec > toSec + period * 60) continue;
          const x = lwChart.timeScale().timeToCoordinate(tSec);
          if (x == null || !Number.isFinite(x)) continue;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cssH);
          ctx.stroke();
        }
        ctx.restore();
        ctx.restore();
        // Draw chips after period lines
        drawSignalChips();
      };

      const redrawPeriodLines = () => {
        const p = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
        drawLwPeriodLines(Number.isFinite(p) ? p : null);
      };

      function computeIndicatorSignals() {
        const latestIdx = lastPriceRows.length - 1;
        if (latestIdx < 0) { indicatorSignals = {}; return; }
        const lastRow = lastPriceRows[latestIdx] || {};
        const closes = lastPriceRows.map(r => Number(r.close) || 0);
        const upCandle = Number(lastRow.close) >= Number(lastRow.open);
        // Helper: SMA
        const sma = (arr, n) => {
          const out = new Array(arr.length).fill(null);
          let sum = 0;
          for (let i=0;i<arr.length;i++) {
            sum += arr[i];
            if (i>=n) sum -= arr[i-n];
            if (i>=n-1) out[i] = sum / n;
          }
          return out;
        };
        // Helper: z-score over available values (ignoring nulls)
        const zscore = (val, arr) => {
          const x = arr.filter(v => Number.isFinite(v));
          if (!x.length) return 0;
          const mu = x.reduce((a,b)=>a+b,0)/x.length;
          const sd = Math.sqrt(x.reduce((a,b)=>a + Math.pow(b-mu,2),0) / x.length) || 1;
          return (val - mu) / sd;
        };
        // SMA 20/50 crossover
        const sma20 = sma(closes, 20);
        const sma50 = sma(closes, 50);
        let sigSma = '-';
        if (sma20[latestIdx] != null && sma50[latestIdx] != null) {
          sigSma = (sma20[latestIdx] > sma50[latestIdx]) ? 'BUY' : (sma20[latestIdx] < sma50[latestIdx]) ? 'SELL' : '-';
        }
        // STL residual z-score (contrarian): < -1.96 => BUY, > +1.96 => SELL
        let sigStl = '-';
        if (Array.isArray(stlResidPoints) && stlResidPoints.length) {
          const vals = stlResidPoints.map(p => Number(p.value)||0);
          const latest = Number(stlResidPoints[stlResidPoints.length-1].value)||0;
          const z = zscore(latest, vals);
          sigStl = z <= -1.96 ? 'BUY' : (z >= 1.96 ? 'SELL' : '-');
        }
        // STL speed z-score (momentum): > +1.96 => BUY, < -1.96 => SELL
        let sigStlSpd = '-';
        if (Array.isArray(stlSpeedPoints) && stlSpeedPoints.length) {
          const vals = stlSpeedPoints.map(p => Number(p.value)||0);
          const latest = Number(stlSpeedPoints[stlSpeedPoints.length-1].value)||0;
          const z = zscore(latest, vals);
          sigStlSpd = z >= 1.96 ? 'BUY' : (z <= -1.96 ? 'SELL' : '-');
        }
        // RSI threshold
        let sigRsi = '-';
        const rsi = Number(lastRsiValues[latestIdx]);
        if (Number.isFinite(rsi)) {
          sigRsi = rsi <= 30 ? 'BUY' : (rsi >= 70 ? 'SELL' : '-');
        }
        // MACD: line vs signal + histogram slope
        let sigMacd = '-';
        const m = Number(lastMacdObj.macd[latestIdx]);
        const s = Number(lastMacdObj.signal[latestIdx]);
        const h = Number(lastMacdObj.histogram[latestIdx]);
        const hPrev = Number(lastMacdObj.histogram[latestIdx-1]);
        if ([m,s,h].every(Number.isFinite)) {
          const rising = Number.isFinite(hPrev) ? (h > hPrev) : false;
          if (m > s && rising) sigMacd = 'BUY';
          else if (m < s && !rising) sigMacd = 'SELL';
        }
        // Volume: spike vs mean with candle direction
        let sigVol = '-';
        if (lastVolumesArr.length) {
          const meanV = lastVolumesArr.reduce((a,b)=>a+b,0) / Math.max(1,lastVolumesArr.length);
          const v = Number(lastVolumesArr[latestIdx]||0);
          if (Number.isFinite(v) && v >= 1.5 * meanV) {
            sigVol = upCandle ? 'BUY' : 'SELL';
          }
        }
        // ATR: high volatility breakout with candle direction (weak)
        let sigAtr = '-';
        const atr = Number(lastAtrValues[latestIdx]);
        if (Number.isFinite(atr)) {
          const avgAtr = lastAtrValues.filter(Number.isFinite).reduce((a,b)=>a+b,0) / Math.max(1,lastAtrValues.filter(Number.isFinite).length);
          if (Number.isFinite(avgAtr) && atr > 1.25 * avgAtr) sigAtr = upCandle ? 'BUY' : 'SELL';
        }
        // ADX: trend strength + direction via +DI / -DI
        let sigAdx = '-';
        const adx = Number(lastAdxObj.adx && lastAdxObj.adx[latestIdx]);
        const pdi = Number(lastAdxObj.plusDI && lastAdxObj.plusDI[latestIdx]);
        const mdi = Number(lastAdxObj.minusDI && lastAdxObj.minusDI[latestIdx]);
        if ([adx,pdi,mdi].every(Number.isFinite)) {
          if (adx >= 25) sigAdx = (pdi > mdi) ? 'BUY' : (pdi < mdi ? 'SELL' : '-');
        }
        indicatorSignals = {
          SMA: sigSma,
          STL: sigStl,
          STLSpeed: sigStlSpd,
          RSI: sigRsi,
          MACD: sigMacd,
          VOL: sigVol,
          ATR: sigAtr,
          ADX: sigAdx,
        };
      }

      function drawSignalChips() {
        if (!lwOverlay || !lwOverlayCtx || !lwChart) return;
        const ctx = lwOverlayCtx;
        const dpr = lwOverlayDpr || (window.devicePixelRatio || 1);
        const cssW = lwOverlay.width / dpr;
        const cssH = lwOverlay.height / dpr;
        // Chips are fixed to the top-left corner of the chart area
        const startY = 26; // move further down from top edge
        const lineH = 18;
        const padX = 6;
        const radius = 6;
        // Draw chips stack (SMA at top)
        const entries = Object.entries(indicatorSignals || {});
        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Background clear in a left strip only (avoid wiping the whole overlay)
        ctx.clearRect(0, 0, 260, Math.min(cssH, startY + (entries.length+1)*lineH + 8));
        let y = startY;
        const textColor = '#111';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        for (const [label, sig] of entries) {
          let bg = 'rgba(158,158,158,0.18)';
          let border = '#9e9e9e';
          if (sig === 'BUY') { bg = 'rgba(46,204,113,0.18)'; border = '#2ecc71'; }
          else if (sig === 'SELL') { bg = 'rgba(231,76,60,0.18)'; border = '#e74c3c'; }
          const text = `${label}: ${sig || '-'}`;
          const w = Math.min(180, Math.max(60, ctx.measureText(text).width + padX * 2));
          const x = 60; // left-aligned, pulled fully inside the plot area
          // rounded rect
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + lineH - radius);
          ctx.quadraticCurveTo(x + w, y + lineH, x + w - radius, y + lineH);
          ctx.lineTo(x + radius, y + lineH);
          ctx.quadraticCurveTo(x, y + lineH, x, y + lineH - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.fillStyle = bg;
          ctx.fill();
          ctx.strokeStyle = border;
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.fillStyle = textColor;
          ctx.fillText(text, x + padX, y + 12);
          y += lineH + 4;
        }
        ctx.restore();
      }

      const computePeriodBoundaryTimes = (period) => {
        periodBoundaryTimes = [];
        periodAnchorTime = null;
        if (!lwChart || !lwLastTimes.length || !period || period < 1) return;
        // Determine anchor time: selected run start_ts mapped to nearest bar time, otherwise first bar
        let anchorIdx = 0;
        if (stlLastMeta && stlLastMeta.start_ts) {
          const anchorSecRaw = Math.floor(new Date(stlLastMeta.start_ts).getTime() / 1000);
          // find first index whose time >= anchorSecRaw
          for (let i = 0; i < lwLastTimes.length; i++) {
            if (lwLastTimes[i] >= anchorSecRaw) { anchorIdx = i; break; }
          }
        }
        periodAnchorTime = lwLastTimes[anchorIdx] || lwLastTimes[0];
        // Walk left and right from anchor by multiples of period (bar count)
        const times = [];
        for (let idx = anchorIdx; idx >= 0; idx -= period) {
          times.push(lwLastTimes[idx]);
        }
        for (let idx = anchorIdx + period; idx < lwLastTimes.length; idx += period) {
          times.push(lwLastTimes[idx]);
        }
        // Sort ascending and unique
        times.sort((a, b) => a - b);
        const uniq = [];
        let prev = null;
        for (const t of times) {
          if (prev === null || t !== prev) uniq.push(t);
          prev = t;
        }
        periodBoundaryTimes = uniq;
      };

      const applyLightweightPeriodOverlay = (rows, period) => {
        if (!lwSeries || typeof lwSeries.setMarkers !== 'function') {
          clearLwOverlay();
          return;
        }
        if (!showPeriodLines || !period || period < 1 || !Array.isArray(periodBoundaryTimes)) {
          lwSeries.setMarkers([]);
          clearLwOverlay();
          return;
        }
        const markers = periodBoundaryTimes.map((t) => ({
          time: t,
          position: 'belowBar',
          shape: 'arrowUp',
          color: '#d84315',
          text: 'P',
        }));
        lwSeries.setMarkers(markers);
        clearLwOverlay();
      };

      const applyChartPeriodOverlay = (rows, period) => {
        if (!Array.isArray(rows) || !rows.length || !period || period < 1 || !showPeriodLines) {
          chartPeriodWindows = [];
          if (chart && curType === 'line') chart.update('none');
          return;
        }
        const eff = Math.max(1, Math.floor(period));
        const windows = [];
        for (let start = 0; start < rows.length; start += eff) {
          const endIndex = Math.min(rows.length - 1, start + eff);
          const startDate = new Date(rows[start].ts);
          const endDate = new Date(rows[endIndex].ts);
          if (!Number.isFinite(startDate.valueOf()) || !Number.isFinite(endDate.valueOf())) continue;
          windows.push({ start: startDate, end: endDate });
        }
        chartPeriodWindows = windows;
        if (chart && curType === 'line') chart.update('none');
      };

      const updatePeriodOverlays = (period) => {
        if (!period || period < 1 || !lastPriceRows.length) {
          chartPeriodWindows = [];
          if (lwSeries && typeof lwSeries.setMarkers === 'function') lwSeries.setMarkers([]);
          clearLwOverlay();
          if (chart && curType === 'line') chart.update('none');
          return;
        }
        const eff = Math.max(1, Math.floor(period));
        if (showPeriodLines) {
          applyChartPeriodOverlay(lastPriceRows, eff);
        } else {
          chartPeriodWindows = [];
          if (chart && curType === 'line') chart.update('none');
        }
        computePeriodBoundaryTimes(eff);
        applyLightweightPeriodOverlay(lastPriceRows, eff);
      };

      const rangeAlmostEqual = (x, y) => Math.abs((x || 0) - (y || 0)) < 1e-4;
      const rangesEqual = (a, b) => a && b && rangeAlmostEqual(a.from, b.from) && rangeAlmostEqual(a.to, b.to);
      const setRangeIfNeeded = (chart, range) => {
        if (!chart || !range || range.from == null || range.to == null) return;
        if (!Number.isFinite(range.from) || !Number.isFinite(range.to)) return;
        const cur = chart.timeScale().getVisibleRange();
        if (!rangesEqual(cur, range)) {
          try {
            chart.timeScale().setVisibleRange(range);
          } catch (err) {
            console.warn('[ChartSync] setVisibleRange failed', err);
          }
        }
      };
      const logicalRangesEqual = (a, b) => {
        if (!a && !b) return true;
        if (!a || !b) return false;
        return rangeAlmostEqual(a.from, b.from) && rangeAlmostEqual(a.to, b.to);
      };
      const setLogicalRangeIfNeeded = (chart, logicalRange) => {
        if (!chart || !logicalRange || logicalRange.from == null || logicalRange.to == null) return;
        if (!Number.isFinite(logicalRange.from) || !Number.isFinite(logicalRange.to)) return;
        const cur = chart.timeScale().getVisibleLogicalRange();
        if (!logicalRangesEqual(cur, logicalRange)) {
          try {
            chart.timeScale().setVisibleLogicalRange(logicalRange);
          } catch (err) {
            console.warn('[ChartSync] setVisibleLogicalRange failed', err);
          }
        }
      };
      const syncAllChartsToRange = (sourceChart, range, logicalRange) => {
        if (!logicalRange || logicalRange.from == null || logicalRange.to == null) return;
        lwSyncing = true;
        try {
          if (lwChart && sourceChart !== lwChart) {
            setLogicalRangeIfNeeded(lwChart, logicalRange);
          }
          if (lwVolChart && lwVolHasData && sourceChart !== lwVolChart) {
            setLogicalRangeIfNeeded(lwVolChart, logicalRange);
          }
          if (lwRsiChart && lwRsiHasData && sourceChart !== lwRsiChart) {
            setLogicalRangeIfNeeded(lwRsiChart, logicalRange);
          }
          if (lwMacdChart && lwMacdHasData && sourceChart !== lwMacdChart) {
            setLogicalRangeIfNeeded(lwMacdChart, logicalRange);
          }
          if (lwDerivChart && (lwDerivHasSpeed || lwDerivHasAccel) && sourceChart !== lwDerivChart) {
            setLogicalRangeIfNeeded(lwDerivChart, logicalRange);
          }
          if (lwAtrChart && (lastAtrValues && lastAtrValues.length) && sourceChart !== lwAtrChart) {
            setLogicalRangeIfNeeded(lwAtrChart, logicalRange);
          }
          if (lwAdxChart && (lastAdxObj && (lastAdxObj.adx||[]).length) && sourceChart !== lwAdxChart) {
            setLogicalRangeIfNeeded(lwAdxChart, logicalRange);
          }
        } finally {
          lwSyncing = false;
        }
      };
      const handleChartRangeChange = (chartInstance) => {
        if (!chartInstance || lwSyncing || !lwSubscriptionsEnabled) return;
        if (lwRangeTimer) cancelAnimationFrame(lwRangeTimer);
        lwRangeTimer = requestAnimationFrame(() => {
          const range = chartInstance.timeScale().getVisibleRange();
          const logicalRange = chartInstance.timeScale().getVisibleLogicalRange();
          const effectiveLogical = logicalRange || currentLogicalRange || null;
          if (effectiveLogical && effectiveLogical.from != null && effectiveLogical.to != null) {
            if (logicalRangesEqual(currentLogicalRange, effectiveLogical)) {
              return;
            }
            currentLogicalRange = effectiveLogical;
            syncAllChartsToRange(chartInstance, null, effectiveLogical);
            if (curType === 'line') {
              applyIndicatorViewport(range, effectiveLogical);
            }
            if (curType === 'candlestick') {
              redrawPeriodLines();
            }
          } else {
            currentTimeRange = null;
            currentLogicalRange = null;
            if (curType === 'line') {
              applyIndicatorViewport(null, null);
            }
            if (curType === 'candlestick') {
              redrawPeriodLines();
            }
          }
        });
      };

      function isFxPair(sym) {
        return /^[A-Z]{6,7}$/.test((sym||'').toUpperCase());
      }
      function splitPair(sym) { const s=(sym||'').toUpperCase(); return { base: s.slice(0,3), quote: s.slice(3,6) }; }

      function openHealth(kind, preferredStrategy) {
      healthState.kind = kind;
      healthState.strategy = preferredStrategy || null;
      // If no specific strategy requested (Basic), exclude Tech snapshot from history by default
      healthState.excludeStrategy = preferredStrategy ? null : 'tech_snapshot_10q.json';
      healthState.offset = 0;
      healthState.runs = [];
      const modal = el('healthModal');
      if (!modal) return;
      ensureStrategyForKind(kind);
      if (preferredStrategy && healthStrategySelect) {
        const hasOption = !!healthStrategySelect.querySelector(`option[value="${preferredStrategy}"]`);
        if (hasOption) {
          healthStrategyUserOverride = true;
          healthStrategySelect.value = preferredStrategy;
        }
      }
      modal.style.display = 'flex';
      const sym = symbolSelect.value.toUpperCase();
        const info = el('healthInfo');
        if (kind === 'forex_pair') {
          const pq = isFxPair(sym) ? splitPair(sym) : { base: sym.slice(0,3), quote: sym.slice(3,6) };
          info.textContent = `Pair: ${pq.base}/${pq.quote}`;
        } else {
          info.textContent = `Stock: ${sym}`;
        }
        el('healthResultsBox').innerHTML = '';
        loadHealthHistory();
      }

      function openHealthAuto() {
        const sym = symbolSelect.value.toUpperCase();
        const kind = isFxPair(sym) ? 'forex_pair' : 'stock';
        healthState.runs = [];
        openHealth(kind, null);
      }

      const buildTechTable = (title, headers, rows) => {
        const headCells = headers.map((label) => `<th style="text-align:right; padding:4px 6px; border-bottom:1px solid var(--line);">${esc(label)}</th>`).join('');
        const bodyHtml = rows.length
          ? rows.map((row) => {
              const timeCell = `<td style="padding:4px 6px; border-bottom:1px solid var(--line);">${esc(row.time || '')}</td>`;
              const valueCells = row.values.map((val) => `<td style="text-align:right; padding:4px 6px; border-bottom:1px solid var(--line);">${esc(val)}</td>`).join('');
              return `<tr>${timeCell}${valueCells}</tr>`;
            }).join('')
          : `<tr><td colspan="${headers.length + 1}" style="padding:10px; text-align:center; color:var(--muted);"><em>No data</em></td></tr>`;
        return `<div style="border:1px solid var(--line); border-radius:8px; padding:10px; background:var(--panel);">
          <div style="font-weight:600; margin-bottom:6px;">${esc(title)}</div>
          <table style="width:100%; border-collapse:collapse; font-size:13px;">
            <thead>
              <tr>
                <th style="text-align:left; padding:4px 6px; border-bottom:1px solid var(--line);">Time</th>
                ${headCells}
              </tr>
            </thead>
            <tbody>
              ${bodyHtml}
            </tbody>
          </table>
        </div>`;
      };

      function openTechHealth() {
        applyTechWindowDefault(false);
        const modal = el('techModal');
        const box = el('techSummaryBox');
        const metaBox = el('techSummaryMeta');
        if (!modal || !box || !metaBox) return;
        const symbol = currentSymbol();
        const tf = currentTf();
        const rows = Array.isArray(lastPriceRows) ? lastPriceRows : [];
        const windowSize = Math.max(1, resolveTechWindow());
        const startIdx = Math.max(rows.length - windowSize, 0);
        const windowRows = rows.slice(startIdx);
        const closes = rows.map((r) => Number(r?.close));
        const volumes = rows.map((r) => {
          const stack = [r?.real_volume, r?.tick_volume, r?.volume]
            .map((v) => Number(v))
            .filter((v) => Number.isFinite(v) && v > 0);
          return stack.length ? stack[0] : null;
        });
        const rsiValues = computeRSI(closes);
        const macdObj = computeMACD(closes);
        const { atr, tr } = computeAtrSeries(rows);
        const adxObj = computeAdxSeries(rows, tr);

        const buildFromArray = (arr) => windowRows.map((row, offset) => {
          const idx = startIdx + offset;
          const raw = arr ? arr[idx] : null;
          const numeric = Number(raw);
          const formatted = raw != null && Number.isFinite(numeric) ? formatTechNumber(numeric) : '—';
          const ts = row && row.ts ? formatDateTime(row.ts) : '';
          return { time: ts, values: [formatted] };
        });

        const buildFromArrays = (arrays) => windowRows.map((row, offset) => {
          const idx = startIdx + offset;
          const values = arrays.map((arr) => {
            const raw = arr ? arr[idx] : null;
            const numeric = Number(raw);
            return raw != null && Number.isFinite(numeric) ? formatTechNumber(numeric) : '—';
          });
          const ts = row && row.ts ? formatDateTime(row.ts) : '';
          return { time: ts, values };
        });

        const slicePoints = (points) => {
          if (!Array.isArray(points) || !points.length) return [];
          return points.slice(Math.max(points.length - windowSize, 0)).map((pt) => ({
            time: formatEpochDateTime(pt.time),
            values: [Number.isFinite(Number(pt.value)) ? formatTechNumber(Number(pt.value)) : '—'],
          }));
        };

        const priceData = buildFromArray(closes);
        const volumeData = buildFromArray(volumes);
        const rsiData = buildFromArray(rsiValues);
        const macdData = buildFromArrays([macdObj.macd, macdObj.signal, macdObj.histogram]);
        const atrData = buildFromArray(atr);
        const adxData = buildFromArrays([adxObj.adx, adxObj.plusDI, adxObj.minusDI]);
        const trendData = slicePoints(stlTrendPoints);
        const seasonalData = slicePoints(stlSeasonPoints);
        const residData = slicePoints(stlResidPoints);
        const speedData = slicePoints(stlSpeedPoints);
        const accelData = slicePoints(stlAccelPoints);

        const sections = [
          buildTechTable(`${tf} Close Price`, ['Value'], priceData),
          buildTechTable('Volume', ['Value'], volumeData),
          buildTechTable('STL Trend', ['Value'], trendData),
          buildTechTable('STL Seasonal', ['Value'], seasonalData),
          buildTechTable('STL Residual', ['Value'], residData),
          buildTechTable('STL Speed (ΔTrend)', ['Value'], speedData),
          buildTechTable('STL Acceleration (ΔSpeed)', ['Value'], accelData),
          buildTechTable('RSI (14)', ['Value'], rsiData),
          buildTechTable('MACD (12,26,9)', ['MACD', 'Signal', 'Hist'], macdData),
          buildTechTable('ATR (14)', ['Value'], atrData),
          buildTechTable('ADX (14)', ['ADX', '+DI', '-DI'], adxData),
        ];

        box.innerHTML = sections.join('');
        const metaParts = [symbol, `TF ${tf}`, 'Seasonal-Trend decomposition using Loess (STL)'];
        if (stlLastMeta && Number.isFinite(Number(stlLastMeta.period))) {
          metaParts.push(`STL period ${Number(stlLastMeta.period)}`);
        }
        metaParts.push(`N=${windowSize}`);
        metaBox.textContent = metaParts.join(' • ');
        modal.style.display = 'flex';
      }

      const renderHealthOutcome = (container, payload) => {
        if (!container) return;
        const answers = Array.isArray(payload.answers)
          ? payload.answers
          : (Array.isArray(payload.questions) ? payload.questions : []);
        const score = payload.score ?? (payload.scores && payload.scores.NET);
        const signal = payload.signal ?? 'NEUTRAL';
        const strategyUsed = payload.strategy || (payload.meta && payload.meta.strategy) || '';
        const baseCode = payload.base || (payload.meta && payload.meta.base);
        const quoteCode = payload.quote || (payload.meta && payload.meta.quote);
        const scoresObj = payload.scores || (payload.meta && payload.meta.scores) || null;
        const pillHtml = answers.map((ans, idx) => {
          const val = ans && Object.prototype.hasOwnProperty.call(ans, 'answer') ? ans.answer : null;
          const explanation = esc((ans && ans.explanation) || '');
          let label;
          let bg;
          let border;
          let textColor;
          if (typeof val === 'boolean') {
            const isTrue = val === true;
            label = isTrue ? 'YES' : 'NO';
            bg = isTrue ? 'rgba(46,204,113,0.12)' : 'rgba(231,76,60,0.12)';
            border = isTrue ? '#2ecc71' : '#e74c3c';
            textColor = isTrue ? '#1b5e20' : '#b71c1c';
          } else if (typeof val === 'string') {
            label = val.toUpperCase();
            if (label === 'BULLISH') {
              bg = 'rgba(46,204,113,0.12)';
              border = '#2ecc71';
              textColor = '#1b5e20';
            } else if (label === 'BEARISH') {
              bg = 'rgba(231,76,60,0.12)';
              border = '#e74c3c';
              textColor = '#b71c1c';
            } else {
              // Neutral color for currency-code answers (e.g., EUR/USD)
              bg = 'rgba(33,150,243,0.12)';
              border = '#2196f3';
              textColor = '#0d47a1';
            }
          } else {
            label = val == null ? '—' : String(val);
            bg = 'rgba(158,158,158,0.12)';
            border = '#9e9e9e';
            textColor = '#424242';
          }
          return `<div style="display:flex; flex-direction:column; gap:4px;">
            <div style="display:flex; gap:8px; align-items:center;">
              <span style="width:28px; color:var(--muted)">${idx + 1}.</span>
              <span class="pill" style="background:${bg}; border-color:${border}; color:${textColor};">
                ${esc(label)}
              </span>
            </div>
            <div style="font-size:12px; color:var(--muted); padding-left:28px;">${explanation || '<em>No explanation</em>'}</div>
          </div>`;
        }).join('');
        let scoreLine = `<div class="row" style="justify-content:space-between;"><strong>Score: ${score ?? '—'}</strong><strong>${esc(signal)}</strong></div>`;
        const strategyLine = `<div style="font-size:12px; color:var(--muted); margin-top:4px;">Strategy: ${esc(strategyUsed || '—')}</div>`;
        let countsLine = '';
        if (scoresObj && typeof scoresObj === 'object') {
          const hasBaseQuote = Object.prototype.hasOwnProperty.call(scoresObj, 'BASE') || Object.prototype.hasOwnProperty.call(scoresObj, 'QUOTE');
          const hasBullBear = Object.prototype.hasOwnProperty.call(scoresObj, 'BULLISH') || Object.prototype.hasOwnProperty.call(scoresObj, 'BEARISH');
          const netVal = Object.prototype.hasOwnProperty.call(scoresObj, 'NET') ? scoresObj.NET : null;
          const segments = [];
          if (hasBaseQuote) {
            const baseCount = baseCode && Object.prototype.hasOwnProperty.call(scoresObj, 'BASE') ? scoresObj.BASE : null;
            const quoteCount = quoteCode && Object.prototype.hasOwnProperty.call(scoresObj, 'QUOTE') ? scoresObj.QUOTE : null;
            if (baseCode != null && baseCount != null) segments.push(`${esc(baseCode)}=${baseCount}`);
            if (quoteCode != null && quoteCount != null) segments.push(`${esc(quoteCode)}=${quoteCount}`);
          }
          if (hasBullBear) {
            const bull = Object.prototype.hasOwnProperty.call(scoresObj, 'BULLISH') ? scoresObj.BULLISH : null;
            const bear = Object.prototype.hasOwnProperty.call(scoresObj, 'BEARISH') ? scoresObj.BEARISH : null;
            if (bull != null) segments.push(`BULLISH=${bull}`);
            if (bear != null) segments.push(`BEARISH=${bear}`);
          }
          if (netVal != null) segments.push(`NET=${netVal}`);
          if (segments.length) {
            countsLine = `<div style="font-size:12px; color:var(--muted); margin-top:2px;">${segments.join(' • ')}</div>`;
          }
        }
        container.innerHTML = `${scoreLine}${strategyLine}${countsLine}<div style="display:flex; flex-direction:column; gap:6px; margin-top:8px;">${pillHtml}</div>`;
      };

      async function loadHealthHistory() {
        const box = el('healthHistoryBox');
        box.innerHTML = '<em style="color:var(--muted)">Loading…</em>';
        const sym = symbolSelect.value.toUpperCase();
        const params = new URLSearchParams();
        if (healthState.kind === 'forex_pair') {
          const pq = isFxPair(sym) ? splitPair(sym) : { base: sym.slice(0,3), quote: sym.slice(3,6) };
          params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote);
        } else {
          params.set('kind','stock'); params.set('symbol', sym);
        }
        params.set('limit','5'); params.set('offset', String(healthState.offset||0));
        if (healthState.strategy) { params.set('strategy', healthState.strategy); }
        if (healthState.excludeStrategy) { params.set('exclude_strategy', healthState.excludeStrategy); }
        if (healthState.strategy === 'tech_snapshot_10q.json') { params.set('tf', currentTf()); }
        try {
          const res = await fetch(`/api/health/runs?${params.toString()}`);
          const data = await res.json();
          const runs = (data && data.runs) || [];
          if ((healthState.offset||0) === 0) { box.innerHTML = ''; }
          if (!Array.isArray(healthState.runs)) healthState.runs = [];
          const startIdx = healthState.runs.length;
          healthState.runs = healthState.runs.concat(runs);
          const html = runs.map((r, i) => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ansMeta = r.answers || {};
            const sig = ansMeta.signal || (ansMeta.scores && ansMeta.scores.signal) || '';
            const sc = (ansMeta.score ?? ansMeta.NET ?? '') ?? '';
            const strat = ansMeta.strategy || '';
            const summaryParts = [];
            if (sig) summaryParts.push(sig);
            if (sc !== '') summaryParts.push(sc);
            if (strat) summaryParts.push(strat);
            const summary = summaryParts.join(' • ');
            const idx = startIdx + i;
            return `<button class="row" data-run-idx="${idx}" style="justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%; text-align:left; cursor:pointer;">
              <span style="font-size:13px; color:var(--muted);">${t}</span>
              <span style="font-weight:600;">${summary}</span>
            </button>`;
          }).join('');
          if (html) box.insertAdjacentHTML('beforeend', html);

          // Include AI Trade Plans alongside Basic or Tech+AI history for the current timeframe
          const wantAiAlongside = (!healthState.strategy) || (healthState.strategy === 'tech_snapshot_10q.json');
          if (wantAiAlongside) {
            const p2 = new URLSearchParams();
            if (healthState.kind === 'forex_pair') {
              const pq = isFxPair(sym) ? splitPair(sym) : { base: sym.slice(0,3), quote: sym.slice(3,6) };
              p2.set('kind','forex_pair'); p2.set('base', pq.base); p2.set('quote', pq.quote);
            } else {
              p2.set('kind','stock'); p2.set('symbol', sym);
            }
            p2.set('strategy', 'ai_trade_plan');
            p2.set('tf', currentTf());
            p2.set('limit','5'); p2.set('offset', String(healthState.offset||0));
            try {
              const res2 = await fetch(`/api/health/runs?${p2.toString()}`);
              const data2 = await res2.json();
              const runs2 = (data2 && data2.runs) || [];
              if (runs2.length) {
                const html2 = runs2.map((r) => {
                  const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
                  const ans = r.answers || {};
                  const plan = ans.plan || {};
                  const pos = (plan.position || '').toUpperCase();
                  const sl = plan.stop_loss;
                  const tp = plan.take_profit;
                  const posPill = pos ? `<span class=\"pill\" style=\"background:${pos==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${pos==='BUY'?'#2ecc71':'#e74c3c'};\">${pos}</span>` : '';
                  return `<div class=\"row\" style=\"justify-content:space-between; border:1px dashed var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n                    <span style=\"font-size:13px; color:var(--muted);\">${t}</span>\n                    <span>${posPill} <span style=\"font-size:12px; color:var(--muted);\">SL ${esc(sl)} • TP ${esc(tp)}</span> <span class=\"pill\" style=\"margin-left:6px\">ai_trade_plan</span></span>\n                  </div>`;
                }).join('');
                if (html2) box.insertAdjacentHTML('beforeend', html2);
              } else if (!runs.length && (healthState.offset||0) === 0) {
                box.innerHTML = '<em style="color:var(--muted)">No recent checks</em>';
              }
            } catch (e) { if (!runs.length && (healthState.offset||0) === 0) { box.innerHTML = '<em style="color:var(--muted)">No recent checks</em>'; } }
          } else if (!runs.length && (healthState.offset||0) === 0) {
            box.innerHTML = '<em style="color:var(--muted)">No recent checks</em>';
          }
        } catch (e) {
          box.innerHTML = '<em style="color:var(--muted)">Failed to load</em>';
        }
      }

      async function startHealthRun() {
        const sym = symbolSelect.value.toUpperCase();
        const n = Math.max(1, Math.min(20, Number(el('healthNewsCount').value || 3)));
        const body = { symbol: sym, news_count: n };
        const strategyName = healthStrategySelect ? healthStrategySelect.value : '';
        if (strategyName) {
          body.strategy = strategyName;
        }
        // When running the technical snapshot strategy, attach the snapshot text and timeframe
        if (strategyName === 'tech_snapshot_10q.json') {
          try {
            const snapshot = buildTechSnapshotString();
            body.tech_snapshot = snapshot;
            body.timeframe = currentTf();
          } catch (err) {
            console.warn('Failed to build tech snapshot', err);
          }
        }
        console.log('[Health] using strategy', strategyName || '(auto)');
        const outBox = el('healthResultsBox');
        outBox.innerHTML = '<div style="color:var(--muted)">Running… this can take ~30–60s</div>';
        try {
          const res = await fetch('/api/health/run', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify(body)
          });
          const data = await res.json();
          if (!data || data.ok !== true) {
            outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(data && data.error) || 'unknown'}</em>`;
            return;
          }
          renderHealthOutcome(outBox, data);
          loadHealthHistory();
          refreshHealthFreshness();
          refreshTechFreshness();
        } catch (e) {
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e}</em>`;
        }
      }

      async function startTechAiRun() {
        const sym = symbolSelect.value.toUpperCase();
        const outBox = el('healthResultsBox');
        try {
          const snapshot = buildTechSnapshotString();
          const body = {
            symbol: sym,
            strategy: (document.getElementById('techAiStrategy') && document.getElementById('techAiStrategy').value) ? document.getElementById('techAiStrategy').value : 'tech_snapshot_10q.json',
            timeframe: currentTf(),
            tech_snapshot: snapshot
          };
          console.log('[Health][TechAI] running tech snapshot for', sym, currentTf());
          outBox.innerHTML = '<div style="color:var(--muted)">Running Tech+AI…</div>';
          const res = await fetch('/api/health/run', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            cache: 'no-store',
            body: JSON.stringify(body)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data || data.ok !== true) {
            outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(data && data.error) || res.statusText || 'unknown'}</em>`;
            return;
          }
          renderHealthOutcome(outBox, data);
          loadHealthHistory();
          refreshHealthFreshness();
        } catch (e) {
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
        }
      }

      function buildTechSnapshotString() {
        // Build a compact textual snapshot matching the Technical Snapshot modal tables
        applyTechWindowDefault(false);
        const rows = Array.isArray(lastPriceRows) ? lastPriceRows : [];
        const windowSize = Math.max(1, resolveTechWindow());
        const startIdx = Math.max(rows.length - windowSize, 0);
        const windowRows = rows.slice(startIdx);
        const closes = rows.map((r) => Number(r?.close));
        const volumes = rows.map((r) => {
          const stack = [r?.real_volume, r?.tick_volume, r?.volume].map((v) => Number(v)).filter((v) => Number.isFinite(v) && v > 0);
          return stack.length ? stack[0] : null;
        });
        const rsiValues = computeRSI(closes);
        const macdObj = computeMACD(closes);
        const { atr, tr } = computeAtrSeries(rows);
        const adxObj = computeAdxSeries(rows, tr);

        const fmtRow = (ts, vals) => `${formatDateTime(ts)}\t${vals.map((v)=> (Number.isFinite(Number(v)) ? formatTechNumber(Number(v)) : '—')).join('\t')}`;
        const toBlock = (title, headers, dataRows) => {
          const lines = [title, 'Time\t' + headers.join('\t')];
          for (const r of dataRows) lines.push(fmtRow(r.ts, r.values));
          return lines.join('\n');
        };
        const buildSeries = (arr) => windowRows.map((row, offset) => ({ ts: row.ts, values: [arr[startIdx + offset]] }));
        const buildSeries3 = (a,b,c) => windowRows.map((row, offset) => ({ ts: row.ts, values: [a[startIdx + offset], b[startIdx + offset], c[startIdx + offset]] }));
        const slicePts = (pts) => {
          if (!Array.isArray(pts) || !pts.length) return [];
          const p = pts.slice(Math.max(pts.length - windowSize, 0));
          return p.map((pt) => ({ ts: (pt.time*1000), values: [pt.value] }));
        };

        const parts = [];
        const symbol = currentSymbol();
        const tf = currentTf();
        const head = `${symbol} • TF ${tf}` + (stlLastMeta && Number.isFinite(Number(stlLastMeta.period)) ? ` • STL period ${Number(stlLastMeta.period)}` : '') + ` • N=${windowSize}`;
        parts.push(head);
        parts.push(toBlock(`${tf} Close Price`, ['Value'], buildSeries(closes)));
        parts.push(toBlock('Volume', ['Value'], buildSeries(volumes)));
        parts.push(toBlock('STL Trend', ['Value'], slicePts(stlTrendPoints)));
        parts.push(toBlock('STL Seasonal', ['Value'], slicePts(stlSeasonPoints)));
        parts.push(toBlock('STL Residual', ['Value'], slicePts(stlResidPoints)));
        parts.push(toBlock('STL Speed (ΔTrend)', ['Value'], slicePts(stlSpeedPoints)));
        parts.push(toBlock('STL Acceleration (ΔSpeed)', ['Value'], slicePts(stlAccelPoints)));
        parts.push(toBlock('RSI (14)', ['Value'], buildSeries(rsiValues)));
        parts.push(toBlock('MACD (12,26,9)', ['MACD','Signal','Hist'], buildSeries3(macdObj.macd, macdObj.signal, macdObj.histogram)));
        parts.push(toBlock('ATR (14)', ['Value'], buildSeries(atr)));
        parts.push(toBlock('ADX (14)', ['ADX','+DI','-DI'], buildSeries3(adxObj.adx, adxObj.plusDI, adxObj.minusDI)));
        return parts.join('\n\n');
      }

      const btnHealthCheck = document.getElementById('btnHealthCheck');
      const btnHealthStart = document.getElementById('btnHealthStart');
      const btnHealthMore = document.getElementById('btnHealthMore');
      const btnHealthClose = document.getElementById('btnHealthClose');
      const btnTechHealth = document.getElementById('btnTechHealth');
      const btnTechAiHealth = document.getElementById('btnTechAiHealth');
      const btnAiBuy = document.getElementById('btnAiBuy');
      const btnAiSell = document.getElementById('btnAiSell');
      const aiLeverageInput = document.getElementById('aiLeverage');
      const btnTechClose = document.getElementById('btnTechClose');
      const tradeModal = document.getElementById('tradeModal');
      const tradeInfo = document.getElementById('tradeInfo');
      const tradeResultsBox = document.getElementById('tradeResultsBox');
      const tradeHistoryBox = document.getElementById('tradeHistoryBox');
      const btnTradeStart = document.getElementById('btnTradeStart');
      const btnTradeClose = document.getElementById('btnTradeClose');
      const btnTradeMore = document.getElementById('btnTradeMore');
      let tradeState = { action: 'BUY', offset: 0 };
      if (btnHealthCheck) btnHealthCheck.addEventListener('click', openHealthAuto);
      const healthFreshEl = document.getElementById('healthFreshIndicator');
      const renderHealthFresh = (info) => {
        if (!healthFreshEl) return;
        let label = '—';
        let bg = 'rgba(158,158,158,0.12)';
        let border = '#9e9e9e';
        let color = '#424242';
        if (info && info.status === 'fresh') {
          const n = Number(info.last_run_news_count || 0);
          label = `Latest (${n})`;
          bg = 'rgba(46,204,113,0.12)';
          border = '#2ecc71';
          color = '#1b5e20';
        } else if (info && info.status === 'stale') {
          const m = Number(info.new_count || 0);
          label = `New news (${m})`;
          bg = 'rgba(231,76,60,0.12)';
          border = '#e74c3c';
          color = '#b71c1c';
        } else if (info && info.status === 'unknown') {
          const m = Number(info.new_count || 0);
          label = m > 0 ? `New news (${m})` : 'No checks yet';
          bg = m > 0 ? 'rgba(231,76,60,0.12)' : 'rgba(158,158,158,0.12)';
          border = m > 0 ? '#e74c3c' : '#9e9e9e';
          color = m > 0 ? '#b71c1c' : '#424242';
        }
        healthFreshEl.textContent = label;
        healthFreshEl.style.background = bg;
        healthFreshEl.style.borderColor = border;
        healthFreshEl.style.color = color;
        const tip = [];
        if (info && info.last_run_at) tip.push(`Last check: ${new Date(info.last_run_at).toLocaleString()}`);
        if (info && info.latest_news_at) tip.push(`Latest news: ${new Date(info.latest_news_at).toLocaleString()}`);
        healthFreshEl.title = tip.join(' \n');
      };
      async function refreshHealthFreshness() {
        try {
          const sym = currentSymbol();
          const strat = (healthStrategySelect && healthStrategySelect.value) ? healthStrategySelect.value : '';
          const params = new URLSearchParams({ symbol: sym });
          if (strat) params.set('strategy', strat);
          const r = await fetch(`/api/health/freshness?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js && js.ok) {
            renderHealthFresh(js);
          }
        } catch (e) {
          // ignore
        }
      }

      // Tech+AI freshness (bars outdated)
      const techFreshEl = document.getElementById('techFreshIndicator');
      const renderTechFresh = (info) => {
        if (!techFreshEl) return;
        let label = '—';
        let bg = 'rgba(158,158,158,0.12)';
        let border = '#9e9e9e';
        let color = '#424242';
        if (info && info.status === 'fresh') {
          label = 'Tech up-to-date';
          bg = 'rgba(46,204,113,0.12)';
          border = '#2ecc71';
          color = '#1b5e20';
        } else if (info && info.status === 'stale') {
          const n = Number(info.outdated_bars || 0);
          label = `Outdated +${n}`;
          bg = 'rgba(231,76,60,0.12)';
          border = '#e74c3c';
          color = '#b71c1c';
        }
        techFreshEl.textContent = label;
        techFreshEl.style.background = bg;
        techFreshEl.style.borderColor = border;
        techFreshEl.style.color = color;
        const tip = [];
        if (info && info.last_bar_ts_used) tip.push(`Last bar used: ${new Date(info.last_bar_ts_used).toLocaleString()}`);
        if (info && info.latest_bar_ts) tip.push(`Latest bar: ${new Date(info.latest_bar_ts).toLocaleString()}`);
        techFreshEl.title = tip.join(' \n');
      };
      async function refreshTechFreshness() {
        try {
          const sym = currentSymbol();
          const tf = currentTf();
          const params = new URLSearchParams({ symbol: sym, tf });
          const r = await fetch(`/api/tech/freshness?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js && js.ok) {
            renderTechFresh(js);
          }
        } catch (e) {
          // ignore
        }
      }
      if (btnHealthStart) btnHealthStart.addEventListener('click', () => {
        if (healthState && healthState.strategy === 'tech_snapshot_10q.json') {
          startTechAiRun();
        } else {
          startHealthRun();
        }
      });
      if (btnHealthMore) btnHealthMore.addEventListener('click', ()=> { healthState.offset = (healthState.offset||0) + 5; loadHealthHistory(); });
      if (btnHealthClose) btnHealthClose.addEventListener('click', ()=> { const modal = el('healthModal'); if (modal) modal.style.display = 'none'; });
      if (btnTechHealth) btnTechHealth.addEventListener('click', openTechHealth);
      if (btnTechAiHealth) btnTechAiHealth.addEventListener('click', () => {
        // Open modal filtered to Tech strategy; wait for user to click Start
        const sym = symbolSelect.value.toUpperCase();
        const kind = isFxPair(sym) ? 'forex_pair' : 'stock';
        const techSel = document.getElementById('techAiStrategy');
        const techStrat = techSel && techSel.value ? techSel.value : 'tech_snapshot_10q.json';
        openHealth(kind, techStrat);
      });

      // Inline AI trade plan preview (below Buy/Sell buttons)
      let lastAiPlan = null;
      let aiPlanReqSeq = 0;
      const btnExecutePlan = document.getElementById('btnExecutePlan');
      const updateExecuteBtn = () => {
        if (!btnExecutePlan) return;
        const ok = !!(lastAiPlan && lastAiPlan.position && (lastAiPlan.position === 'BUY' || lastAiPlan.position === 'SELL'));
        btnExecutePlan.disabled = !ok;
      };
      async function updateAiPlanPreview() {
        const outBox = el('aiTradePlanBox');
        if (!outBox) return;
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const reqId = ++aiPlanReqSeq;
        const lev = Math.max(1, Math.min(100, Number(aiLeverageInput && aiLeverageInput.value || 10)));
        outBox.textContent = 'Drafting plan…';
        try {
          const snapshot = buildTechSnapshotString();
          const side = (typeof tradeState !== 'undefined' && tradeState && tradeState.action) ? tradeState.action : 'BUY';
          const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
          const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (reqId !== aiPlanReqSeq || currentSymbol() !== sym || currentTf() !== tf) return;
          if (!r.ok || !js || js.ok !== true) { outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(js && js.error) || r.statusText || 'unknown'}</em>`; return; }
          const p = js.plan || {};
          lastAiPlan = { position: (p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: js.symbol, timeframe: js.timeframe };
          const enforced = js.enforced ? ' (risk cap applied)' : '';
          outBox.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center;">
            <strong>Plan</strong><span style="font-size:12px; color:var(--muted)">${esc(js.symbol)} ${esc(js.timeframe)} • lev ${esc(js.leverage)}${enforced}</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;">
            <span class="pill" style="background:${p.position==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${p.position==='BUY'?'#2ecc71':'#e74c3c'};">${esc(p.position||'')}</span>
            <span class="pill">SL: ${esc(p.stop_loss)}</span>
            <span class="pill">TP: ${esc(p.take_profit)}</span>
          </div>
          <div style="margin-top:6px; color:var(--muted);">${esc(p.explanation||'')}</div>`;
          updateExecuteBtn();
        } catch (e) {
          if (reqId !== aiPlanReqSeq || currentSymbol() !== sym || currentTf() !== tf) return;
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
          lastAiPlan = null; updateExecuteBtn();
        }
      }

      // Load latest existing AI trade plan for current symbol/TF (no new AI call)
      async function loadLatestAiPlanPreview() {
        const outBox = el('aiTradePlanBox');
        if (!outBox) return;
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) {
          const pq = splitPair(sym);
          params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote);
        } else {
          params.set('kind','stock'); params.set('symbol', sym);
        }
        params.set('limit','1');
        params.set('strategy','ai_trade_plan');
        params.set('tf', tf);
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = (js && js.runs) || [];
          if (!runs.length) { outBox.innerHTML = ''; return; }
          const run = runs[0];
          const ans = run.answers || run.answers_json || {};
          const plan = ans.plan || {};
          const pos = (plan.position || '').toUpperCase();
          const enforced = (ans.meta && ans.meta.enforced) ? ' (risk cap applied)' : '';
          lastAiPlan = { position: pos, stop_loss: plan.stop_loss, take_profit: plan.take_profit, symbol: sym, timeframe: tf };
          outBox.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center;">
            <strong>Plan</strong><span style="font-size:12px; color:var(--muted)">${esc(sym)} ${esc(tf)}${enforced}</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;">
            <span class="pill" style="background:${pos==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${pos==='BUY'?'#2ecc71':'#e74c3c'};">${esc(pos || '-')}
            </span>
            <span class="pill">SL: ${esc(plan.stop_loss)}</span>
            <span class="pill">TP: ${esc(plan.take_profit)}</span>
          </div>
          <div style="margin-top:6px; color:var(--muted);">${esc(plan.explanation || '')}</div>`;
          updateExecuteBtn();
        } catch (e) { outBox.innerHTML = ''; lastAiPlan = null; updateExecuteBtn(); }
      }
      async function runAiTradePlan(side) {
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const lev = Math.max(1, Math.min(100, Number(aiLeverageInput && aiLeverageInput.value || 10)));
        const outBox = tradeResultsBox;
        if (outBox) outBox.textContent = 'Drafting plan…';
        try {
          const snapshot = buildTechSnapshotString();
          const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
          const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (!r.ok || !js || js.ok !== true) { if (outBox) outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(js && js.error) || r.statusText || 'unknown'}</em>`; return; }
          const p = js.plan || {};
          const enforced = js.enforced ? ' (risk cap applied)' : '';
          if (outBox) outBox.innerHTML = `<div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n            <strong>Plan</strong><span style=\"font-size:12px; color:var(--muted)\">${esc(js.symbol)} ${esc(js.timeframe)} • lev ${esc(js.leverage)}${enforced}</span>\n          </div>\n          <div style=\"margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;\">\n            <span class=\"pill\" style=\"background:${p.position==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${p.position==='BUY'?'#2ecc71':'#e74c3c'};\">${esc(p.position||'')}</span>\n            <span class=\"pill\">SL: ${esc(p.stop_loss)}</span>\n            <span class=\"pill\">TP: ${esc(p.take_profit)}</span>\n          </div>\n          <div style=\"margin-top:6px; color:var(--muted);\">${esc(p.explanation||'')}</div>`;
          // Update inline preview cache and Execute button
          lastAiPlan = { position: (p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: js.symbol, timeframe: js.timeframe };
          updateExecuteBtn();
          tradeState.offset = 0;
          loadTradeHistory();
        } catch (e) {
          if (outBox) outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
        }
      }
      function openTradePlan(action) {
        tradeState.action = action || 'BUY';
        tradeState.offset = 0;
        if (tradeInfo) tradeInfo.textContent = `${currentSymbol()} • TF ${currentTf()} • ${tradeState.action}`;
        if (tradeResultsBox) tradeResultsBox.innerHTML = '';
        if (tradeModal) tradeModal.style.display = 'flex';
        loadTradeHistory();
      }
      async function loadTradeHistory() {
        if (!tradeHistoryBox) return;
        if ((tradeState.offset||0) === 0) tradeHistoryBox.innerHTML = '<em style="color:var(--muted)">Loading…</em>';
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) {
          const pq = splitPair(sym);
          params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote);
        } else {
          params.set('kind','stock'); params.set('symbol', sym);
        }
        params.set('limit','5'); params.set('offset', String(tradeState.offset||0));
        params.set('strategy','ai_trade_plan');
        params.set('tf', tf);
        try {
          const res = await fetch(`/api/health/runs?${params.toString()}`);
          const data = await res.json();
          const runs = (data && data.runs) || [];
          if (!runs.length && (tradeState.offset||0) === 0) { tradeHistoryBox.innerHTML = '<em style="color:var(--muted)">No recent plans</em>'; return; }
          if ((tradeState.offset||0) === 0) { tradeHistoryBox.innerHTML = ''; }
          const html = runs.map((r) => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ans = r.answers || r.answers_json || {};
            const plan = ans.plan || {};
            const pos = (plan.position || '').toUpperCase();
            const sl = plan.stop_loss;
            const tp = plan.take_profit;
            const posPill = pos ? `<span class=\"pill\" style=\"background:${pos==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${pos==='BUY'?'#2ecc71':'#e74c3c'};\">${pos}</span>` : '';
            return `<div class=\"row\" style=\"justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n              <span style=\"font-size:13px; color:var(--muted);\">${t}</span>\n              <span>${posPill} <span style=\"font-size:12px; color:var(--muted);\">SL ${esc(sl)} • TP ${esc(tp)}</span></span>\n            </div>`;
          }).join('');
          tradeHistoryBox.insertAdjacentHTML('beforeend', html);
        } catch (e) {
          tradeHistoryBox.innerHTML = '<em style="color:var(--muted)">Failed to load</em>';
        }
      }
      if (btnAiBuy) btnAiBuy.addEventListener('click', ()=> openTradePlan('BUY'));
      if (btnAiSell) btnAiSell.addEventListener('click', ()=> openTradePlan('SELL'));
      if (btnTradeStart) btnTradeStart.addEventListener('click', ()=> runAiTradePlan(tradeState.action||'BUY'));
      if (btnTradeClose) btnTradeClose.addEventListener('click', ()=> { if (tradeModal) tradeModal.style.display = 'none'; });
      if (btnTradeMore) btnTradeMore.addEventListener('click', ()=> { tradeState.offset = (tradeState.offset||0) + 5; loadTradeHistory(); });
      async function executeAiPlan() {
        if (!lastAiPlan) return;
        const side = (lastAiPlan.position || '').toLowerCase();
        if (side !== 'buy' && side !== 'sell') return;
        const symbol = currentSymbol();
        const volume = el('volume') ? el('volume').value : '0.10';
        const sl = (lastAiPlan.stop_loss != null) ? String(lastAiPlan.stop_loss) : '';
        const tp = (lastAiPlan.take_profit != null) ? String(lastAiPlan.take_profit) : '';
        const msg = `Execute ${lastAiPlan.position} ${symbol}\nSL: ${sl || '-'}  TP: ${tp || '-'}\nProceed?`;
        if (!window.confirm(msg)) return;
        try {
          status('Submitting trade from plan...');
          const body = new URLSearchParams({ symbol, side, volume });
          if (sl) body.set('sl', sl);
          if (tp) body.set('tp', tp);
          const r = await fetch('/api/trade', { method:'POST', headers: { 'Content-Type':'application/x-www-form-urlencoded' }, body, cache: 'no-store' });
          const js = await r.json().catch(()=>({}));
          if (js && js.ok) {
            status(`Trade ok: ${JSON.stringify(js.result)}`);
            await refreshChart();
            await refreshPositions();
          } else {
            status(`Trade error: ${(js && js.error) || r.statusText}`);
          }
        } catch (e) {
          status(`Trade error: ${e && e.message || e}`);
        }
      }
      if (btnExecutePlan) btnExecutePlan.addEventListener('click', executeAiPlan);
      async function runAiTradePlan(side) {
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const lev = Math.max(1, Math.min(100, Number(aiLeverageInput && aiLeverageInput.value || 10)));
        const outBox = el('aiTradePlanBox');
        outBox.textContent = 'Drafting plan…';
        try {
          const snapshot = buildTechSnapshotString();
          const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
          const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (!r.ok || !js || js.ok !== true) { outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(js && js.error) || r.statusText || 'unknown'}</em>`; return; }
          const p = js.plan || {};
          const enforced = js.enforced ? ' (risk cap applied)' : '';
          outBox.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center;">
            <strong>Plan</strong><span style="font-size:12px; color:var(--muted)">${esc(js.symbol)} ${esc(js.timeframe)} • lev ${esc(js.leverage)}${enforced}</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;">
            <span class="pill" style="background:${p.position==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${p.position==='BUY'?'#2ecc71':'#e74c3c'};">${esc(p.position||'')}</span>
            <span class="pill">SL: ${esc(p.stop_loss)}</span>
            <span class="pill">TP: ${esc(p.take_profit)}</span>
          </div>
          <div style="margin-top:6px; color:var(--muted);">${esc(p.explanation||'')}</div>`;
        } catch (e) {
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
        }
      }
      if (btnTechClose) btnTechClose.addEventListener('click', ()=> { const modal = el('techModal'); if (modal) modal.style.display = 'none'; });
      if (healthStrategySelect) {
        healthStrategySelect.addEventListener('change', () => { healthStrategyUserOverride = true; });
      }
      if (techHealthBarsInput) {
        techHealthBarsInput.addEventListener('input', () => { techHealthUserOverride = true; });
        const validateTechBars = () => {
          const raw = Number(techHealthBarsInput.value);
          if (!Number.isFinite(raw) || raw <= 0) {
            applyTechWindowDefault(true);
          } else {
            const clamped = Math.max(10, Math.min(500, Math.round(raw)));
            techHealthBarsInput.value = String(clamped);
          }
        };
        techHealthBarsInput.addEventListener('change', validateTechBars);
        techHealthBarsInput.addEventListener('blur', validateTechBars);
      }

      // Click history item to show saved result
      const healthHistoryBox = document.getElementById('healthHistoryBox');
      if (healthHistoryBox) {
        healthHistoryBox.addEventListener('click', (ev) => {
          const node = ev.target.closest('[data-run-idx]');
          if (!node) return;
          const idx = Number(node.getAttribute('data-run-idx'));
          const run = (healthState.runs || [])[idx];
          if (!run || !run.answers) return;
          const ans = run.answers;
          const payload = {
            questions: ans.questions || [],
            score: ans.score ?? ans.NET,
            signal: ans.signal || (ans.scores && ans.scores.signal) || '',
            strategy: ans.strategy || '',
            scores: ans.scores || null,
            base: run.base_ccy || (ans.meta && ans.meta.base),
            quote: run.quote_ccy || (ans.meta && ans.meta.quote),
          };
          const outBox = el('healthResultsBox');
          renderHealthOutcome(outBox, payload);
        });
      }

      const ensureMacdChart = () => {
        if (macdChart || !macdCtx) return;
        macdChart = new window.Chart(macdCtx, {
          type: 'bar',
          parsing: false,
          data: {
            labels: [],
            datasets: [
              {
                type: 'bar',
                label: 'Histogram',
                data: [],
                backgroundColor: (context) => {
                  const raw = context.raw;
                  const value = raw != null && typeof raw === 'object' ? raw.y : raw;
                  if (value == null) return 'rgba(158, 158, 158, 0.35)';
                  return value >= 0 ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)';
                },
                borderWidth: 0,
                barPercentage: 1.0,
                categoryPercentage: 1.0,
              },
              {
                type: 'line',
                label: 'MACD',
                data: [],
                borderColor: '#1b9aaa',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.15,
                fill: false,
              },
              {
                type: 'line',
                label: 'Signal',
                data: [],
                borderColor: '#ef6c00',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.15,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: true, position: 'top' } },
            interaction: { intersect: false, mode: 'index' },
            scales: {
              x: {
                type: 'time',
                time: { tooltipFormat: 'MMM d HH:mm' },
                bounds: 'ticks',
                offset: false,
                ticks: { maxRotation: 0, autoSkip: true },
                grid: { display: false },
              },
              y: {
                position: 'right',
                grid: { color: '#e0e6ef' },
              },
            },
          },
        });
      };

      const applyScaleBounds = (chartInstance) => {
        if (!chartInstance || !chartInstance.options || !chartInstance.options.scales || !chartInstance.options.scales.x) return;
        const scale = chartInstance.options.scales.x;
        if (indicatorRangeMs && Number.isFinite(indicatorRangeMs.min) && Number.isFinite(indicatorRangeMs.max)) {
          scale.min = indicatorRangeMs.min;
          scale.max = indicatorRangeMs.max;
        } else {
          scale.min = undefined;
          scale.max = undefined;
        }
      };

      const updateIndicatorDisplay = (rows) => {
        // When no data, clear indicator panes
        if (!rows || !rows.length) {
          if (lwVolSeries) lwVolSeries.setData([]);
          if (lwRsiSeries) lwRsiSeries.setData([]);
          if (lwMacdHist) lwMacdHist.setData([]);
          if (lwMacdLine) lwMacdLine.setData([]);
          if (lwMacdSignal) lwMacdSignal.setData([]);
          lwVolHasData = false;
          lwRsiHasData = false;
          lwMacdHasData = false;
          stlTrendPoints = [];
          stlSeasonPoints = [];
          stlResidPoints = [];
          stlSpeedPoints = [];
          stlAccelPoints = [];
          updateStlDerivativeSeries();
          if (chart && curType === 'line') {
            chart.data.labels = [];
            chart.data.datasets.forEach((ds) => { ds.data = []; });
            chart.update('none');
          }
          return;
        }
        // Compute inputs
        const closes = rows.map((r) => Number.isFinite(Number(r.close)) ? Number(r.close) : 0);
        const volumes = rows.map((r) => {
          const cand = [r.real_volume, r.tick_volume, r.volume]
            .map((v) => Number(v))
            .filter((v) => Number.isFinite(v) && v > 0);
          return cand.length ? cand[0] : 0;
        });
        // Ensure LWC panes
        ensureLwVol();
        ensureLwRsi();
        ensureLwMacd();
        ensureLwDeriv();
        // Volume histogram
        if (lwVolSeries) {
          const volPoints = rows.map((row, idx) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const y = volumes[idx];
            const up = Number(row.close) >= Number(row.open);
            const color = up ? 'rgba(76,175,80,0.5)' : 'rgba(244,67,54,0.5)';
            return { time: t, value: y, color };
          });
          lwVolSeries.setData(volPoints);
          lwVolHasData = volPoints.length > 0;
        }
        // RSI line
        if (lwRsiSeries) {
          const rsiValues = computeRSI(closes);
          const rsiPoints = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = rsiValues[i];
            return (v != null && Number.isFinite(v)) ? { time: t, value: v } : null;
          }).filter(Boolean);
          lwRsiSeries.setData(rsiPoints);
          lwRsiHasData = rsiPoints.length > 0;
        }
        // MACD histogram + lines
        if (lwMacdHist && lwMacdLine && lwMacdSignal) {
          const macdObj = computeMACD(closes);
          const hist = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = macdObj.histogram[i];
            const color = v >= 0 ? 'rgba(76,175,80,0.5)' : 'rgba(244,67,54,0.5)';
            return (v != null && Number.isFinite(v)) ? { time: t, value: v, color } : null;
          }).filter(Boolean);
          const macdLine = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = macdObj.macd[i];
            return (v != null && Number.isFinite(v)) ? { time: t, value: v } : null;
          }).filter(Boolean);
          const signal = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = macdObj.signal[i];
            return (v != null && Number.isFinite(v)) ? { time: t, value: v } : null;
          }).filter(Boolean);
          lwMacdHist.setData(hist);
          lwMacdLine.setData(macdLine);
          lwMacdSignal.setData(signal);
          lwMacdHasData = hist.length > 0 || macdLine.length > 0 || signal.length > 0;
        }
        // Line chart overlay retains previous behavior if active
        if (chart && curType === 'line') {
          const boll = computeBollingerBands(closes);
          chart.data.labels = rows.map((r) => r.ts);
          if (chart.data.datasets[0]) chart.data.datasets[0].data = closes;
          if (chart.data.datasets[1]) chart.data.datasets[1].data = boll.middle;
          if (chart.data.datasets[2]) chart.data.datasets[2].data = boll.upper;
          if (chart.data.datasets[3]) chart.data.datasets[3].data = boll.lower;
          chart.update('none');
        }
      };

      const enforceIndicatorRange = (range, logicalRange) => {
        if (!range || range.from == null || range.to == null) return;
        lwSyncing = true;
        try {
          if (lwVolChart && lwVolHasData) {
            lwVolChart.timeScale().setVisibleRange(range);
          }
          if (lwRsiChart && lwRsiHasData) {
            lwRsiChart.timeScale().setVisibleRange(range);
          }
          if (lwMacdChart && lwMacdHasData) {
            lwMacdChart.timeScale().setVisibleRange(range);
          }
          if (lwDerivChart && (lwDerivHasSpeed || lwDerivHasAccel)) {
            lwDerivChart.timeScale().setVisibleRange(range);
          }
          if (logicalRange && logicalRange.from != null && logicalRange.to != null) {
            currentLogicalRange = logicalRange;
          }
        } catch (err) {
          console.warn('[ChartSync] indicator range error', err);
        } finally {
          lwSyncing = false;
        }
      };

      const applyIndicatorViewport = (range, logicalRange) => {
        if (range && range.from != null && range.to != null) {
          currentTimeRange = range;
          const fromMs = Number(range.from) * 1000;
          const toMs = Number(range.to) * 1000;
          indicatorRangeMs = (Number.isFinite(fromMs) && Number.isFinite(toMs))
            ? { min: fromMs, max: toMs }
            : null;
          if (logicalRange && curType === 'candlestick') {
            enforceIndicatorRange(range, logicalRange);
          }
        } else {
          currentTimeRange = null;
          indicatorRangeMs = null;
        }
        updateIndicatorDisplay(lastPriceRows);
        if (chart && curType === 'line') {
          applyScaleBounds(chart);
          chart.update('none');
        }
      };

      function makeChart(type) {
        curType = type;
        if (type === 'line') {
          lwContainer.style.display = 'none';
          canvas.style.display = 'block';
          if (lwOverlay && lwOverlayCtx) {
            lwOverlayCtx.clearRect(0, 0, lwOverlay.width, lwOverlay.height);
          }
          clearAllStlOverlaySeries();
          if (chart) {
            chart.destroy();
            chart = null;
          }
          const existing = window.Chart.getChart(canvas);
          if (existing) existing.destroy();
          chart = new window.Chart(ctx, {
            type: 'line',
            data: {
              labels: [],
              datasets: [
                { label: 'Close', data: [], borderColor: '#1976d2', borderWidth: 1.5, pointRadius: 0, tension: 0.15, fill: false },
                { label: 'Bollinger Mid', data: [], borderColor: '#607d8b', borderDash: [4, 4], borderWidth: 1, pointRadius: 0, tension: 0.15, fill: false },
                { label: 'Bollinger Upper', data: [], borderColor: '#ff9800', borderWidth: 1, pointRadius: 0, tension: 0.15, fill: false },
                { label: 'Bollinger Lower', data: [], borderColor: '#ff9800', borderWidth: 1, pointRadius: 0, tension: 0.15, fill: false },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: true, position: 'top' } },
              interaction: { intersect: false, mode: 'index' },
              scales: {
                x: { type: 'time', time: { tooltipFormat: 'MMM d HH:mm' }, ticks: { maxRotation: 0, autoSkip: true }, grid: { display: false } },
                y: { beginAtZero: false, grid: { color: '#e0e6ef' } },
              },
            },
          });
          currentTimeRange = null;
          currentLogicalRange = null;
          applyIndicatorViewport(null, null);
          clearStlOverlay('Switch to candlestick view to see STL overlay.', true);
          return chart;
        }

        canvas.style.display = 'none';
        lwContainer.style.display = 'block';
        if (!lwChart) {
          lwChart = LightweightCharts.createChart(lwContainer, {
            layout: { background: { color: '#f7f9fc' }, textColor: '#111' },
            grid: { vertLines: { color: '#e0e6ef' }, horzLines: { color: '#e0e6ef' } },
            crosshair: { mode: LightweightCharts.CrosshairMode.Magnet },
            rightPriceScale: { borderColor: '#e0e6ef' },
            timeScale: { borderColor: '#e0e6ef', rightOffset: getRightOffset(), fixRightEdge: false },
          });
          lwSeries = lwChart.addCandlestickSeries({
            upColor: '#2ecc71',
            downColor: '#e74c3c',
            wickUpColor: '#2ecc71',
            wickDownColor: '#e74c3c',
            borderVisible: false,
          });
          if (!lwBollingerUpper) {
            lwBollingerUpper = lwChart.addLineSeries({
              color: '#ff9800',
              lineWidth: 1.5,
              priceLineVisible: false,
              title: 'Bollinger Upper',
            });
          }
          if (!lwBollingerLower) {
            lwBollingerLower = lwChart.addLineSeries({
              color: '#ff9800',
              lineWidth: 1.5,
              priceLineVisible: false,
              title: 'Bollinger Lower',
            });
          }
          if (!lwBollingerMid) {
            lwBollingerMid = lwChart.addLineSeries({
              color: '#607d8b',
              lineWidth: 1,
              lineStyle: LightweightCharts.LineStyle.Dashed,
              priceLineVisible: false,
              title: 'Bollinger Mid',
            });
          }
          lwObserver = new ResizeObserver(() => {
            const rect = lwContainer.getBoundingClientRect();
            lwChart.applyOptions({
              width: rect.width || lwContainer.clientWidth || 800,
              height: rect.height || lwContainer.clientHeight || 400,
            });
          });
          lwObserver.observe(lwContainer);
          const rectInit = lwContainer.getBoundingClientRect();
          lwChart.applyOptions({
            width: rectInit.width || lwContainer.clientWidth || 800,
            height: rectInit.height || lwContainer.clientHeight || 400,
          });
          ensureLwOverlay();
          if (!lwTimeRangeSubscribed) {
            lwChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
              handleChartRangeChange(lwChart);
            });
            lwTimeRangeSubscribed = true;
          }
        }
        // Apply current chart shift offset to all panes
        try {
          const ro = getRightOffset();
          if (lwChart) lwChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwVolChart) lwVolChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwRsiChart) lwRsiChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwMacdChart) lwMacdChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwDerivChart) lwDerivChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwAtrChart) lwAtrChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwAdxChart) lwAdxChart.applyOptions({ timeScale: { rightOffset: ro } });
        } catch (e) { /* noop */ }
        if (stlLastRows.length && stlLastMeta) {
          applyStlData(stlLastRows.slice(), stlLastMeta).catch((err) => console.warn('STL overlay restore failed', err));
        }
        syncStlOverlayVisibility();
        return lwChart;
      }
      function handleFetchEvent(data) {
        if (!data) return;
        debugLog('[WS] fetch event', data);
        if (data.status === 'scheduled' && data.background) {
          status(`Background fetch scheduled (${data.symbol} ${data.timeframe})`);
          return;
        }
        if (data.status === 'error') {
          status(`Fetch error (${data.symbol} ${data.timeframe}): ${data.error || 'unknown'}`);
          return;
        }
        const symbol = currentSymbol();
        const tf = currentTf();
        const sameSymbol = data.symbol === symbol;
        const sameTf = data.timeframe === tf;
        const inserted = Number(data.inserted || 0);
        if (sameSymbol && sameTf) {
          if (data.background) {
            status(`Background fetch done (${data.symbol} ${data.timeframe}, +${inserted} bars)`);
          }
          scheduleChartRefresh(`${data.symbol}/${data.timeframe}`);
          // Update Tech+AI freshness (bars outdated)
          refreshTechFreshness();
          // Re-run top strategy so the Signal pill reflects the new bars
          try { runStrategyTop(); } catch (e) { /* ignore */ }
        } else if (data.scope === 'symbol_all_tf' && sameSymbol) {
          status(`Background fetch done (${data.symbol} ${data.timeframe})`);
          scheduleChartRefresh(`${data.symbol}/${data.timeframe} [scope symbol_all_tf]`);
          refreshTechFreshness();
          if (data.timeframe === currentTf()) { try { runStrategyTop(); } catch (e) {} }
        } else if (data.scope === 'all_symbols' && data.symbol === symbol) {
          status(`Bulk fetch updated ${data.symbol} ${data.timeframe}`);
          scheduleChartRefresh(`${data.symbol}/${data.timeframe} [scope all_symbols]`);
          refreshTechFreshness();
          if (data.timeframe === currentTf()) { try { runStrategyTop(); } catch (e) {} }
        }
      }

      function handleNewsEvent(data) {
        if (!data) return;
        debugLog('[WS] news event', data);
        const symbol = currentSymbol();
        const eventSymbol = (data.symbol || '').toUpperCase();
        if (eventSymbol && eventSymbol !== symbol) {
          return;
        }
        const count = Number.isFinite(Number(data.items)) ? Number(data.items) : null;
        const scope = data.scope || 'news';
        const prefix = count != null ? `${count} new item${count === 1 ? '' : 's'}` : 'Background update';
        setNewsStatus(`${prefix} (${symbol}, ${scope})`, 'warn');
        scheduleNewsRefresh(data.reason || 'ws_news');
      }

      function handleStlEvent(data) {
        if (!data) return;
        const desc = `${data.symbol} ${data.timeframe}`;
        const sameSymbol = data.symbol === currentSymbol();
        const sameTf = data.timeframe === currentTf();
        const overlayKey = `${data.symbol}__${data.timeframe}`;
        stlOverlayLoading.delete(overlayKey);
        stlOverlayData.delete(overlayKey);
        const wasPending = stlOverlayPending.delete(overlayKey);
        const pendingInput = stlOverlayInputs.get(data.timeframe);
        if (pendingInput && (wasPending || pendingInput.dataset.loading === '1')) {
          pendingInput.dataset.loading = '';
        }
        if (sameSymbol && sameTf && data.status === 'scheduled') {
          stlPendingCompute = true;
        }
        const box = el('stlStatus');
        if (data.status === 'scheduled') {
          if (box) box.textContent = `STL job scheduled (${desc})...`;
          status(`STL scheduled (${desc})`);
          return;
        }
        if (data.status === 'error') {
          const message = `STL error (${desc}): ${data.error || 'unknown'}`;
          if (box) box.textContent = message;
          status(message);
          if (sameSymbol && sameTf) {
            stlPendingCompute = false;
            refreshStlOverlay({ autoCompute: false });
          } else if (sameSymbol && pendingInput && !pendingInput.disabled) {
            pendingInput.checked = false;
          }
          return;
        }
        const rangeInfo = data.start_ts && data.end_ts ? `, ${formatDateShort(data.start_ts)} → ${formatDateShort(data.end_ts)}` : '';
        const metaInfo = `period ${data.period || '—'}${rangeInfo}${data.points ? `, points ${data.points}` : ''}`;
        const note = data.note ? ` • ${data.note}` : '';
        if (box) box.textContent = `STL ${data.status} (${desc}, ${metaInfo}${note})`;
        if (sameSymbol && sameTf && data.status === 'completed') {
          stlPendingCompute = false;
          if (data.run_id) stlSelectedRunId = data.run_id;
          status(`STL updated (${desc}, ${metaInfo})`);
          refreshStlOverlay({ runId: data.run_id || null, autoCompute: false });
        } else if (!sameSymbol || !sameTf) {
          status(`STL ${data.status} (${desc}${note ? `, ${data.note}` : ''})`);
        }
        if (sameSymbol && data.timeframe !== currentTf() && isStlOverlayEnabled(data.timeframe)) {
          loadStlOverlay(data.timeframe);
        }
        syncStlOverlayVisibility();
      }
      function ensureStlOverlaySeries(tf) {
        if (!lwChart) return null;
        if (stlOverlaySeries.has(tf)) return stlOverlaySeries.get(tf);
        const series = lwChart.addLineSeries({
          color: STL_OVERLAY_COLORS[tf] || '#607d8b',
          lineWidth: 1.5,
          priceScaleId: 'right',
          title: `Trend ${tf}`,
        });
        stlOverlaySeries.set(tf, series);
        return series;
      }
      function clearStlOverlaySeries(tf) {
        const series = stlOverlaySeries.get(tf);
        if (series && typeof series.setData === 'function') {
          series.setData([]);
        }
      }
      function clearAllStlOverlaySeries() {
        stlOverlaySeries.forEach((series) => {
          if (series && typeof series.setData === 'function') series.setData([]);
        });
      }
      function isStlOverlayEnabled(tf) {
        const input = stlOverlayInputs.get(tf);
        if (!input) return false;
        if (input.disabled) return input.dataset.locked === 'current';
        return !!input.checked;
      }
      function overlayKey(symbol, tf) {
        return `${symbol}__${tf}`;
      }
      function scheduleStlOverlayCompute(symbol, tf) {
        const key = overlayKey(symbol, tf);
        if (stlOverlayPending.has(key)) return;
        const input = stlOverlayInputs.get(tf);
        if (input) input.dataset.loading = '1';
        stlOverlayPending.add(key);
        status(`Scheduling STL overlay compute (${symbol} ${tf})...`);
        triggerStl('current', {
          symbol,
          timeframe: tf,
          silent: true,
          skipPref: true,
          allData: true,
        })
          .then(() => {
            debugLog('[STL overlay] compute scheduled', symbol, tf);
          })
          .catch((err) => {
            stlOverlayPending.delete(key);
            debugWarn('[STL overlay] compute schedule failed', symbol, tf, err);
            status(`Failed to schedule STL overlay (${symbol} ${tf}).`);
          });
      }
      function applyStoredOverlay(tf) {
        if (curType !== 'candlestick') return;
        const symbol = currentSymbol();
        const key = overlayKey(symbol, tf);
        const data = stlOverlayData.get(key);
        const series = ensureStlOverlaySeries(tf);
        if (!series) return;
        series.setData(Array.isArray(data) ? data : (data && data.trend) || data || []);
      }
      async function loadStlOverlay(tf) {
        if (curType !== 'candlestick') return;
        const symbol = currentSymbol();
        const key = overlayKey(symbol, tf);
        if (stlOverlayData.has(key)) {
          applyStoredOverlay(tf);
          return;
        }
        if (stlOverlayLoading.has(key)) {
          return stlOverlayLoading.get(key);
        }
        const input = stlOverlayInputs.get(tf);
        if (input) input.dataset.loading = '1';
        const limit = Math.max(200, Math.min(1500, currentBarsLimit() * 2));
        const params = new URLSearchParams({
          symbol,
          tf,
          include_data: '1',
          all_data: '1',
          limit: String(limit),
        });
        const promise = (async () => {
          const resp = await fetch(`/api/stl?${params.toString()}`, { cache: 'no-store' });
          const js = await resp.json().catch(() => ({}));
          if (!resp.ok || !js || js.ok !== true) {
            throw new Error(js && js.error ? js.error : resp.statusText || 'overlay fetch failed');
          }
          const rows = Array.isArray(js.rows) ? js.rows : [];
          if (!rows.length) {
            throw new Error('no STL rows');
          }
          const seriesData = rows
            .map((r) => {
              const t = new Date(r.ts).getTime();
              const v = Number(r.trend);
              if (!Number.isFinite(t) || !Number.isFinite(v)) return null;
              return { time: Math.floor(t / 1000), value: v };
            })
            .filter(Boolean);
          if (!seriesData.length) {
            throw new Error('no usable trend points');
          }
          stlOverlayData.set(key, seriesData);
          applyStoredOverlay(tf);
          debugLog(`[STL overlay] loaded ${symbol} ${tf}`);
        })().catch((err) => {
          debugWarn('[STL overlay]', tf, err);
          scheduleStlOverlayCompute(symbol, tf);
          status(`STL overlay pending compute (${symbol} ${tf})`);
        }).finally(() => {
          stlOverlayLoading.delete(key);
          const inputEl = stlOverlayInputs.get(tf);
          if (inputEl) {
            if (stlOverlayPending.has(key)) {
              inputEl.dataset.loading = '1';
            } else {
              inputEl.dataset.loading = '';
            }
          }
        });
        stlOverlayLoading.set(key, promise);
        return promise;
      }
      function syncStlOverlayVisibility() {
        if (!stlOverlayControls) return;
        if (curType !== 'candlestick') {
          clearAllStlOverlaySeries();
          return;
        }
        const symbol = currentSymbol();
        STL_OVERLAY_TFS.forEach((tf) => {
          if (tf === currentTf()) return;
          if (!isStlOverlayEnabled(tf)) {
            clearStlOverlaySeries(tf);
            return;
          }
          const key = overlayKey(symbol, tf);
          if (stlOverlayData.has(key)) {
            applyStoredOverlay(tf);
          } else {
            loadStlOverlay(tf);
          }
        });
      }
      function buildStlOverlayControls() {
        if (!stlOverlayControls) return;
        const symbol = currentSymbol();
        const current = currentTf();
        stlOverlayControls.innerHTML = '';
        stlOverlayInputs.clear();
        // Auto STL switch (per symbol × timeframe)
        const getAutoKey = () => `stl_auto_compute:${symbol}:${current}`;
        const readAuto = () => { try { return (localStorage.getItem(getAutoKey()) === '1'); } catch { return false; } };
        const writeAuto = (val) => { try { localStorage.setItem(getAutoKey(), val ? '1' : '0'); } catch {} };
        const autoWrap = document.createElement('label');
        autoWrap.className = 'switch';
        autoWrap.style.marginRight = '8px';
        const autoChk = document.createElement('input');
        autoChk.type = 'checkbox';
        autoChk.id = 'chkStlAutoCompute';
        autoChk.checked = !!readAuto();
        autoChk.addEventListener('change', () => { writeAuto(!!autoChk.checked); });
        const autoText = document.createElement('span');
        autoText.textContent = 'Auto STL';
        autoWrap.appendChild(autoChk);
        autoWrap.appendChild(autoText);
        stlOverlayControls.appendChild(autoWrap);

        const label = document.createElement('span');
        label.textContent = 'Overlay STL';
        label.style.fontSize = '12px';
        label.style.fontWeight = '600';
        label.style.color = 'var(--muted)';
        stlOverlayControls.appendChild(label);
        const order = ALL_TFS.slice();
        const currentIdx = order.indexOf(current);
        const overlayList = order.filter((tf) => STL_OVERLAY_TFS.includes(tf) || tf === current);
        overlayList.forEach((tf) => {
          const tfIdx = order.indexOf(tf);
          const isCurrent = tf === current;
          const isLower = currentIdx !== -1 && tfIdx !== -1 && tfIdx < currentIdx;
          const unavailable = tfIdx === -1;
          const wrap = document.createElement('label');
          wrap.style.display = 'flex';
          wrap.style.alignItems = 'center';
          wrap.style.gap = '4px';
          wrap.style.fontSize = '12px';
          wrap.style.color = 'var(--muted)';
          wrap.style.cursor = 'pointer';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = tf;
          input.dataset.tf = tf;
          if (isCurrent) {
            input.checked = true;
            input.disabled = true;
            input.dataset.locked = 'current';
            wrap.style.cursor = 'default';
            wrap.style.opacity = '0.9';
          } else if (unavailable) {
            input.checked = false;
            input.disabled = true;
            input.dataset.locked = 'unsupported';
            wrap.style.cursor = 'not-allowed';
            wrap.style.opacity = '0.3';
          } else if (isLower && currentIdx !== -1) {
            input.checked = false;
            input.disabled = true;
            input.dataset.locked = 'lower';
            wrap.style.cursor = 'not-allowed';
            wrap.style.opacity = '0.35';
            wrap.title = 'Enable lower timeframe trends from their own chart.';
            clearStlOverlaySeries(tf);
          } else {
            const key = overlayKey(symbol, tf);
            if (stlOverlayData.has(key)) {
              input.checked = true;
            }
            input.addEventListener('change', () => {
              if (input.checked) {
                loadStlOverlay(tf);
              } else {
                clearStlOverlaySeries(tf);
              }
            });
          }
          stlOverlayInputs.set(tf, input);
          const badge = document.createElement('span');
          badge.textContent = tf;
          badge.style.padding = '2px 6px';
          badge.style.borderRadius = '4px';
          const color = STL_OVERLAY_COLORS[tf] || '#607d8b';
          badge.style.border = `1px solid ${color}`;
          badge.style.color = color;
          badge.style.fontWeight = '600';
          wrap.appendChild(input);
          wrap.appendChild(badge);
          stlOverlayControls.appendChild(wrap);
        });
        syncStlOverlayVisibility();
      }
      function ensureStlSeries() {
        if (!lwChart) return;
        const dotted = (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dotted !== undefined)
          ? LightweightCharts.LineStyle.Dotted
          : (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Solid !== undefined
              ? LightweightCharts.LineStyle.Solid
              : 2);
        if (!stlTrendSeries) {
          stlTrendSeries = lwChart.addLineSeries({
            color: '#d84315',
            lineWidth: 2,
            priceScaleId: 'right',
            title: 'Trend',
          });
        }
        if (!stlSeasonSeries) {
          stlSeasonSeries = lwChart.addLineSeries({
            color: '#03a9f4',
            lineWidth: 1,
            priceScaleId: 'left',
            title: 'Seasonal',
          });
        }
        if (!stlResidSeries) {
          stlResidSeries = lwChart.addLineSeries({
            color: '#9c27b0',
            lineWidth: 1,
            lineStyle: dotted,
            priceScaleId: 'left',
            title: 'Residual',
          });
        }
        lwChart.priceScale('left').applyOptions({
          visible: true,
          scaleMargins: { top: 0.8, bottom: 0.05 },
        });
      }

      async function applyStlData(rows, meta) {
        const box = el('stlStatus');
        if (!rows || !rows.length) {
          clearStlOverlay('No STL data cached yet. Use Recalculate to compute.');
          return;
        }
        stlLastRows = rows.slice();
        stlLastMeta = meta || null;
        const periodValue = meta && Number(meta.period);
        if (Number.isFinite(periodValue) && periodValue >= 1) {
          stlLastPeriod = periodValue;
          if (stlAutoPeriod) {
            stlManualPeriod = periodValue;
            if (stlPeriodInput) stlPeriodInput.value = stlManualPeriod;
          }
        }
        updateStlInputsFromState();
        if (curType === 'line') {
          clearStlOverlay('Switch to candlestick view to see STL overlay.', true);
          return;
        }
        ensureStlSeries();
        const toSeriesData = (key) =>
          rows
            .map((r) => ({
              time: Math.floor(new Date(r.ts).getTime() / 1000),
              value: Number(r[key]),
            }))
            .filter((pt) => Number.isFinite(pt.value));
        const trendData = toSeriesData('trend');
        const seasonalData = toSeriesData('seasonal');
        const residData = toSeriesData('resid');
        stlTrendPoints = trendData.slice();
        stlSeasonPoints = seasonalData.slice();
        stlResidPoints = residData.slice();
        if (trendData.length && stlTrendSeries) stlTrendSeries.setData(trendData);
        if (seasonalData.length && stlSeasonSeries) stlSeasonSeries.setData(seasonalData);
        if (residData.length && stlResidSeries) stlResidSeries.setData(residData);
        if (trendData.length > 2) {
          const trendValues = trendData.map((pt) => Number(pt.value) || 0);

          stlSpeedPoints = [];
          for (let i = 1; i < trendValues.length; i += 1) {
            const speedVal = trendValues[i] - trendValues[i - 1];
            stlSpeedPoints.push({ time: trendData[i].time, value: speedVal });
          }

          stlAccelPoints = [];
          for (let i = 1; i < stlSpeedPoints.length; i += 1) {
            const accelVal = (stlSpeedPoints[i].value ?? 0) - (stlSpeedPoints[i - 1].value ?? 0);
            stlAccelPoints.push({ time: stlSpeedPoints[i].time, value: accelVal });
          }
        } else {
          stlTrendPoints = [];
          stlSeasonPoints = [];
          stlResidPoints = [];
          stlSpeedPoints = [];
          stlAccelPoints = [];
        }
        updateStlDerivativeSeries();
        const overlayPeriod = periodValue && Number.isFinite(periodValue)
          ? periodValue
          : (stlAutoPeriod ? stlLastPeriod : stlManualPeriod);
        updatePeriodOverlays(overlayPeriod && Number.isFinite(overlayPeriod) ? overlayPeriod : null);
        if (box) {
          const periodLabel = meta && meta.period ? meta.period : '—';
          const rangeLabel = meta && meta.start_ts && meta.end_ts ? ` • ${formatDateShort(meta.start_ts)} → ${formatDateShort(meta.end_ts)}` : '';
          const updatedIso = meta && (meta.updated || meta.created_at);
          const updatedLabel = updatedIso ? ` • run ${formatDateTime(updatedIso)}` : '';
          box.textContent = `STL period ${periodLabel}${rangeLabel} • ${rows.length} points${updatedLabel}`;
        }
        syncStlOverlayVisibility();
      }
      function ensureStlSeries() {
        if (!lwChart) return;
        const dotted = (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dotted !== undefined)
          ? LightweightCharts.LineStyle.Dotted
          : (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Solid !== undefined
              ? LightweightCharts.LineStyle.Solid
              : 2);
        if (!stlTrendSeries) {
          stlTrendSeries = lwChart.addLineSeries({
            color: '#d84315',
            lineWidth: 2,
            priceScaleId: 'right',
            title: 'Trend',
          });
        }
        if (!stlSeasonSeries) {
          stlSeasonSeries = lwChart.addLineSeries({
            color: '#03a9f4',
            lineWidth: 1,
            priceScaleId: 'left',
            title: 'Seasonal',
          });
        }
        if (!stlResidSeries) {
          stlResidSeries = lwChart.addLineSeries({
            color: '#9c27b0',
            lineWidth: 1,
            lineStyle: dotted,
            priceScaleId: 'left',
            title: 'Residual',
          });
        }
        lwChart.priceScale('left').applyOptions({
          visible: true,
          scaleMargins: { top: 0.8, bottom: 0.05 },
        });
      }

      function clearStlOverlay(message, preserveData = false) {
        if (stlTrendSeries) stlTrendSeries.setData([]);
        if (stlSeasonSeries) stlSeasonSeries.setData([]);
        if (stlResidSeries) stlResidSeries.setData([]);
        if (!preserveData) {
          stlLastRows = [];
          stlLastMeta = null;
          stlLastPeriod = null;
          updatePeriodOverlays(null);
          stlTrendPoints = [];
          stlSeasonPoints = [];
          stlResidPoints = [];
        } else {
          if (!stlLastMeta) {
            stlLastRows = [];
          }
          updatePeriodOverlays(stlLastPeriod);
        }
        stlSpeedPoints = [];
        stlAccelPoints = [];
        updateStlDerivativeSeries();
        updateStlInputsFromState();
        if (lwChart) {
          lwChart.priceScale('left').applyOptions({ visible: false });
        }
        if (message) {
          const box = el('stlStatus');
          if (box) box.textContent = message;
        }
        syncStlOverlayVisibility();
      }
      async function refreshStlOverlay(options = {}) {
        const { runId = stlSelectedRunId } = options || {};
        const autoCompute = (() => { try { return localStorage.getItem(`stl_auto_compute:${currentSymbol()}:${currentTf()}`) === '1'; } catch { return false; } })();
        const statusBox = el('stlStatus');
        const symbol = currentSymbol();
        const tf = currentTf();
        if (!symbol || !tf) return;
        let startIso = stlAllData ? null : stlTargetStart;
        let endIso = stlAllData ? null : stlTargetEnd;
        if (!stlAllData) {
          if (!startIso && stlStartInput && stlStartInput.value) startIso = localInputToIso(stlStartInput.value);
          if (!endIso && stlEndInput && stlEndInput.value) endIso = localInputToIso(stlEndInput.value);
          if (!startIso || !endIso) {
            clearStlOverlay('Select a start and end datetime for STL.');
            if (statusBox) statusBox.textContent = 'Select a start and end datetime for STL.';
            return;
          }
          if (new Date(startIso) >= new Date(endIso)) {
            clearStlOverlay('STL start must be before end.');
            status('STL range invalid: start must be before end.');
            return;
          }
          stlTargetStart = startIso;
          stlTargetEnd = endIso;
        }
        try {
          const params = new URLSearchParams({
            symbol,
            tf,
            include_runs: '1',
            include_data: '1',
            all_data: stlAllData ? '1' : '0',
          });
          if (!stlAllData) {
            params.set('start', stlTargetStart);
            params.set('end', stlTargetEnd);
          }
          if (runId) params.set('run_id', String(runId));
          const limit = Math.max(10, Number(el('count').value) || 500);
          params.set('limit', String(limit));
          const r = await fetch(`/api/stl?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (!r.ok || !js.ok) {
            const message = `STL fetch failed: ${js.error || r.statusText}`;
            status(message);
            clearStlOverlay(message);
            return;
          }
          stlDatasetRange = js.dataset || stlDatasetRange;
          if (js.target_range) {
            stlAllData = !!js.target_range.all_data;
            stlTargetStart = js.target_range.start_ts || stlTargetStart;
            stlTargetEnd = js.target_range.end_ts || stlTargetEnd;
          } else if (stlAllData && stlDatasetRange) {
            stlTargetStart = stlDatasetRange.start_ts;
            stlTargetEnd = stlDatasetRange.end_ts;
          }
          updateStlInputsFromState();
          if (Array.isArray(js.runs)) {
            populateStlRuns(js.runs, js.selected_run_id || runId || null);
          }
          stlSelectedRunId = js.selected_run_id || runId || null;
          if (stlDeleteBtn) stlDeleteBtn.disabled = !stlSelectedRunId;
          const runMeta = js.selected_run
            ? {
                id: js.selected_run.id,
                period: js.selected_run.period,
                start_ts: js.selected_run.start_ts,
                end_ts: js.selected_run.end_ts,
                updated: js.selected_run.created_at,
                created_at: js.selected_run.created_at,
              }
            : null;
          if (js.rows && js.rows.length) {
            if (curType === 'line') {
              stlLastRows = js.rows.slice();
              stlLastMeta = runMeta;
              clearStlOverlay('Switch to candlestick view to see STL overlay.', true);
            } else {
              await applyStlData(js.rows, runMeta);
            }
          } else {
            const reason = js.reason || (js.needs_compute ? 'needs_compute' : 'no_rows');
            const message =
              reason === 'range_mismatch'
                ? 'No STL run covers the requested range. Use Recalculate to compute.'
                : reason === 'dataset_extended'
                  ? 'New data detected. Re-run STL to refresh.'
                  : 'No STL data cached yet. Use Recalculate to compute.';
            clearStlOverlay(message);
            if (statusBox) statusBox.textContent = message;
          }
          if (js.needs_compute && autoCompute) {
            if (!stlPendingCompute) {
              stlPendingCompute = true;
              triggerStl('current');
            }
          } else if (!js.needs_compute) {
            stlPendingCompute = false;
          }
        } catch (err) {
          console.warn('STL fetch failed', err);
          clearStlOverlay('STL fetch failed.');
          status('STL fetch failed.');
        }
      }
      async function triggerStl(scope, options = {}) {
        const opts = options || {};
        const symbol = opts.symbol || currentSymbol();
        const tf = opts.timeframe || currentTf();
        const silent = !!opts.silent;
        const skipPref = !!opts.skipPref;
        const sameSymbol = symbol === currentSymbol();
        const sameTf = tf === currentTf();
        if (!skipPref && sameSymbol) queuePrefUpdate('last_symbol', symbol);
        if (!skipPref && sameTf) queuePrefUpdate('last_tf', tf);
        const payload = { scope, symbol, timeframe: tf };
        let periodValue = null;
        if (opts.period != null) {
          periodValue = opts.period;
        } else if (sameSymbol && sameTf && !stlAutoPeriod) {
          periodValue = stlManualPeriod;
        }
        if (periodValue != null) {
          if (!Number.isFinite(periodValue) || periodValue < 3) {
            if (!silent) {
              status('STL period must be >= 3.');
              if (sameTf && stlPeriodInput) stlPeriodInput.focus();
            }
            return;
          }
          payload.period = Math.round(periodValue);
          if (!skipPref && sameSymbol && sameTf && !stlAutoPeriod) {
            queuePrefUpdate('stl_manual_period', payload.period);
          }
        }
        let allDataFlag;
        if (opts.allData != null) {
          allDataFlag = opts.allData ? 1 : 0;
        } else {
          allDataFlag = (sameSymbol && sameTf) ? (stlAllData ? 1 : 0) : 1;
        }
        payload.all_data = allDataFlag;
        if (payload.all_data !== 1) {
          const startIso = opts.start || stlTargetStart || (stlStartInput && stlStartInput.value ? localInputToIso(stlStartInput.value) : null);
          const endIso = opts.end || stlTargetEnd || (stlEndInput && stlEndInput.value ? localInputToIso(stlEndInput.value) : null);
          if (!startIso || !endIso) {
            if (!silent) status('Select a start and end datetime before recalculating STL.');
            return;
          }
          if (new Date(startIso) >= new Date(endIso)) {
            if (!silent) status('STL range invalid: start must be before end.');
            return;
          }
          payload.start = startIso;
          payload.end = endIso;
          if (sameSymbol && sameTf) {
            stlTargetStart = startIso;
            stlTargetEnd = endIso;
          }
        }
        if (scope === 'symbol_all_tf') {
          payload.timeframes = ALL_TFS;
        } else if (scope === 'timeframe_all_symbols') {
          payload.symbols = APP_SYMBOLS;
        } else if (scope === 'all') {
          payload.symbols = APP_SYMBOLS;
          payload.timeframes = ALL_TFS;
        }
        const statusBox = !silent ? el('stlStatus') : null;
        if (statusBox) statusBox.textContent = `Scheduling STL (${scope})...`;
        if (sameSymbol && sameTf && !silent) stlPendingCompute = true;
        try {
          const r = await fetch('/api/stl/compute', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            cache: 'no-store',
          });
          const js = await r.json().catch(() => ({}));
          if (!r.ok || !js || js.ok !== true) {
            const message = (js && js.error) || r.statusText || 'STL schedule failed';
            if (statusBox) statusBox.textContent = `STL schedule failed: ${message}`;
            if (!silent) status(`STL schedule failed: ${message}`);
            if (sameSymbol && sameTf) stlPendingCompute = false;
          } else if (!silent) {
            status(`STL tasks scheduled (${js.scheduled} jobs, scope ${js.scope})`);
          }
        } catch (err) {
          if (!silent) {
            console.error('STL schedule failed', err);
            if (statusBox) statusBox.textContent = `STL schedule failed: ${err.message || err}`;
            status(`STL schedule failed: ${err.message || err}`);
          }
          if (sameSymbol && sameTf) stlPendingCompute = false;
        }
      }
      function connectUpdates(retryDelay = 2000) {
        const proto = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${proto}://${window.location.host}/ws/updates`;
        const ws = new WebSocket(wsUrl);

        ws.addEventListener('open', () => {
          debugLog('[WS] connected', wsUrl);
        });

        ws.addEventListener('message', (ev) => {
          let data;
          try {
            data = JSON.parse(ev.data);
          } catch (err) {
            debugWarn('[WS] message parse failed', err);
            return;
          }
          if (!data || !data.type) return;
          if (data.type === 'fetch_complete') {
            handleFetchEvent(data);
          } else if (data.type === 'news_update') {
            handleNewsEvent(data);
          } else if (data.type === 'stl_complete') {
            handleStlEvent(data);
          } else if (data.type === 'balance_update') {
            refreshBalanceSeries();
          }
        });

        ws.addEventListener('close', () => {
          debugLog('[WS] disconnected, retrying in', retryDelay, 'ms');
          setTimeout(() => connectUpdates(Math.min(retryDelay * 1.5, 10000)), retryDelay);
        });

        ws.addEventListener('error', (err) => {
          debugWarn('[WS] error', err);
          ws.close();
        });
      }

      connectUpdates();
      refreshBalanceSeries();
      // Initialize freshness indicators
      (async () => { try { await refreshHealthFreshness(); } catch {} })();
      (async () => { try { await refreshTechFreshness(); } catch {} })();
      (async () => { try { await loadLatestAiPlanPreview(); } catch {} })();

      
      async function refreshChart() {
        const symbol = currentSymbol();
        const tf = currentTf();
        const limit = Math.max(10, currentBarsLimit());
        status(`Loading data (${symbol} ${tf}, limit ${limit})...`);
        try {
          const r = await fetch(`/api/data?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&limit=${encodeURIComponent(limit)}`, { cache: 'no-store' });
          const js = await r.json();
          const rows = js.rows || [];
          lastPriceRows = rows.slice();
          const labels = rows.map((row) => row.ts);
          const closes = rows.map((row) => {
            const v = Number(row.close);
            return Number.isFinite(v) ? v : null;
          });
          const boll = computeBollingerBands(closes);
          if (curType === 'line') {
            if (!chart) { makeChart('line'); }
            chart.data.labels = labels;
            chart.data.datasets[0].data = closes;
            if (chart.data.datasets[1]) chart.data.datasets[1].data = boll.middle;
            if (chart.data.datasets[2]) chart.data.datasets[2].data = boll.upper;
            if (chart.data.datasets[3]) chart.data.datasets[3].data = boll.lower;
            chart.update('none');
          } else {
            if (!lwChart || !lwSeries) { makeChart('candlestick'); }
            const data = rows.map(r => ({
              time: Math.floor(new Date(r.ts).getTime() / 1000),
              open: Number(r.open),
              high: Number(r.high),
              low: Number(r.low),
              close: Number(r.close)
            }));
            lwSeries.setData(data);
            // Cache bar times for precise anchoring
            lwLastTimes = data.map(d => d.time);
            const toLwPoints = (values) =>
              rows
                .map((row, idx) => {
                  const val = values[idx];
                  if (val == null || !Number.isFinite(val)) return null;
                  return { time: Math.floor(new Date(row.ts).getTime() / 1000), value: val };
                })
                .filter(Boolean);
            if (lwBollingerUpper) lwBollingerUpper.setData(toLwPoints(boll.upper));
            if (lwBollingerLower) lwBollingerLower.setData(toLwPoints(boll.lower));
            if (lwBollingerMid) lwBollingerMid.setData(toLwPoints(boll.middle));
            // Recompute boundary times using current period
            const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
            if (Number.isFinite(overlayPeriod)) {
              computePeriodBoundaryTimes(Math.max(1, Math.floor(overlayPeriod)));
            } else {
              periodBoundaryTimes = [];
            }
            redrawPeriodLines();
            const visibleRange = lwChart.timeScale().getVisibleRange();
            const hasRange = visibleRange && visibleRange.from != null && visibleRange.to != null;
            if (!lwInitialFitted || !hasRange) {
              // First render: fit once and rely on subscription to broadcast
              lwSyncing = true;
              lwChart.timeScale().fitContent();
              lwSyncing = false;
              lwInitialFitted = true;
              lwSubscriptionsEnabled = true;
            } else {
              // Preserve user view; do not auto-fit on refresh
              const visibleLogical = lwChart.timeScale().getVisibleLogicalRange();
              currentLogicalRange = visibleLogical || currentLogicalRange || null;
              lwSubscriptionsEnabled = true;
            }
          }
          updateIndicatorCharts(rows);
          const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
          updatePeriodOverlays(overlayPeriod && Number.isFinite(overlayPeriod) ? overlayPeriod : null);
          status(`Loaded ${rows.length} bars for ${symbol} ${tf}`);
          await refreshStlOverlay({});
          syncStlOverlayVisibility();
        } catch (err) {
          console.error('Refresh failed', err);
          status('Refresh failed');
          updateIndicatorCharts([]);
          if (chart && chart.data && chart.data.datasets) {
            chart.data.labels = [];
            chart.data.datasets.forEach((ds) => {
              ds.data = [];
            });
            chart.update('none');
          }
          if (lwBollingerUpper) lwBollingerUpper.setData([]);
          if (lwBollingerLower) lwBollingerLower.setData([]);
          if (lwBollingerMid) lwBollingerMid.setData([]);
          clearStlOverlay('STL unavailable (chart refresh failed).');
        }
      }

      async function fetchAndSave(opts = {}) {
        const isEvent = opts && typeof opts === 'object' && typeof opts.preventDefault === 'function';
        if (isEvent) {
          opts.preventDefault();
        }
        const options = isEvent ? {} : (opts || {});
        const symbol = currentSymbol();
        const tf = currentTf();
        const count = el('count').value;
        const mode = (options.mode || 'inc').toString();
        const background = options.background !== false;
        const refreshFirst = options.refreshFirst !== false;
        queuePrefUpdate('last_symbol', symbol);
        queuePrefUpdate('last_tf', tf);
        queuePrefUpdate('last_count', count);
        if (refreshFirst) {
          try {
            status(`Loading cached data (${symbol} ${tf})...`);
            await refreshChart();
          } catch (err) {
            console.warn('[App] Cached refresh failed', err);
          }
        }
        status(background ? `Scheduling background fetch (${symbol} ${tf})...` : `Fetching from MT5 (${symbol} ${tf})...`);
        try {
          const params = new URLSearchParams({
            symbol,
            tf,
            count,
            mode,
          });
          params.set('persist', '1');
          if (background) params.set('background', '1');
          const r = await fetch(`/api/fetch?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js.ok) {
            const note = js.note ? ` ${js.note}` : '';
            if (background) {
              if (js.scheduled || (!js.inserted && !js.fetched)) {
                status(`Background fetch scheduled for ${symbol} ${tf}.${note}`);
              } else if ((js.inserted || 0) > 0) {
                status(`Background fetch completed immediately (${symbol} ${tf}, +${js.inserted || 0} bars).`);
                scheduleChartRefresh(`${symbol}/${tf} immediate`);
              } else {
                status(`Background fetch acknowledged for ${symbol} ${tf}.${note}`);
              }
            } else {
              status(`Inserted/updated ${js.inserted || 0} bars for ${symbol} ${tf}`);
              await refreshChart();
            }
          } else {
            status(`Fetch error: ${js.error || r.statusText}`);
          }
        } catch (e) {
          console.error('Fetch failed', e);
          status(`Fetch failed: ${e.message || e}`);
        }
      }

      async function backgroundFetch(scope, opts = {}) {
        const symbol = currentSymbol();
        const tf = currentTf();
        const count = el('count').value;
        queuePrefUpdate('last_symbol', symbol);
        queuePrefUpdate('last_tf', tf);
        queuePrefUpdate('last_count', count);
        const payload = {
          scope,
          symbol,
          count,
          mode: opts.mode || 'inc'
        };
        if (scope === 'symbol_tf') {
          payload.timeframe = tf;
        }
        if (opts.timeframes) {
          payload.timeframes = opts.timeframes.join(',');
        }
        status(`Scheduling background fetch (${scope})...`);
        try {
          const r = await fetch('/api/fetch_bulk', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            cache: 'no-store'
          });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js.ok) {
            status(`Background fetch queued (${js.jobs || 0} jobs, scope ${scope}).`);
          } else {
            status(`Background fetch error: ${js.error || r.statusText}`);
          }
        } catch (e) {
          console.error('Bulk fetch failed', e);
          status(`Background fetch failed: ${e.message || e}`);
        }
      }

      // Controls
      el('btnFetch').addEventListener('click', fetchAndSave);
      el('btnRefresh').addEventListener('click', refreshChart);
      // Auto-fetch when user changes symbol or timeframe
      el('symbol').addEventListener('change', async () => {
        try { localStorage.setItem('last_symbol', currentSymbol()); } catch {}
        stlSelectedRunId = null;
        stlPendingCompute = false;
        stlLastRows = [];
        stlLastMeta = null;
        stlOverlayData.clear();
        stlOverlayLoading.clear();
        clearAllStlOverlaySeries();
        buildStlOverlayControls();
        applyTechWindowDefault(false);
        ensureStrategyForKind(isFxPair(currentSymbol()) ? 'forex_pair' : 'stock');
        queuePrefUpdate('last_symbol', currentSymbol());
        try {
          debugLog('[App] Auto-fetch on symbol change');
          lwInitialFitted = false;
          await fetchAndSave();
          await refreshPositions();
        } catch (e) {
          debugWarn('[App] Auto-fetch failed', e);
        } finally {
          await refreshNews();
          await refreshHealthFreshness();
          await loadLatestAiPlanPreview();
          if (autoTimer) startAuto({ announce: false });
          // Inline AI trade plan preview disabled on symbol change (run from modal Start)
        }
      });
      const tfSel = document.getElementById('tf');
      if (tfSel) tfSel.addEventListener('change', async () => {
        try { localStorage.setItem('last_tf', currentTf()); } catch {}
        stlSelectedRunId = null;
        stlPendingCompute = false;
        stlLastRows = [];
        stlLastMeta = null;
        stlOverlayData.clear();
        stlOverlayLoading.clear();
        clearAllStlOverlaySeries();
        buildStlOverlayControls();
        applyTechWindowDefault(false);
        ensureStrategyForKind(isFxPair(currentSymbol()) ? 'forex_pair' : 'stock');
        queuePrefUpdate('last_tf', currentTf());
        try {
          debugLog('[App] Auto-fetch on timeframe change');
          lwInitialFitted = false;
          await fetchAndSave();
        } catch (e) {
          debugWarn('[App] Auto-fetch failed', e);
        } finally {
          await refreshNews();
          await refreshHealthFreshness();
          await loadLatestAiPlanPreview();
          if (autoTimer) startAuto({ announce: false });
          // Inline AI trade plan preview disabled on timeframe change (run from modal Start)
        }
      });
      if (chartShiftInput) {
        chartShiftOn = !!chartShiftInput.checked;
        chartShiftInput.addEventListener('change', () => {
          chartShiftOn = !!chartShiftInput.checked;
          const ro = getRightOffset();
          try {
            if (lwChart) lwChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwVolChart) lwVolChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwRsiChart) lwRsiChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwMacdChart) lwMacdChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwDerivChart) lwDerivChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwAtrChart) lwAtrChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwAdxChart) lwAdxChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwBalanceChart) lwBalanceChart.applyOptions({ timeScale: { rightOffset: ro } });
          } catch (e) { /* ignore */ }
          // persist preference
          try { queuePrefUpdate('chart_shift', chartShiftOn ? '1' : '0'); } catch (e) {}
        });
      }
      const countSel = document.getElementById('count');
      if (countSel) countSel.addEventListener('change', async () => {
        queuePrefUpdate('last_count', el('count').value);
        try {
          debugLog('[App] Bars limit changed');
          await refreshChart();
          // Kick off a deeper background fill for this symbol/timeframe
          await backgroundFetch('symbol_tf', { mode: 'full_async' });
        } catch (e) { console.warn('[App] Count change refresh failed', e); }
      });
      const btnFetchCurrentBg = document.getElementById('btnFetchCurrentBg');
      if (btnFetchCurrentBg) btnFetchCurrentBg.addEventListener('click', () => backgroundFetch('symbol_tf', { mode: 'full_async' }));
      const btnFetchSymbolAll = document.getElementById('btnFetchSymbolAll');
      if (btnFetchSymbolAll) btnFetchSymbolAll.addEventListener('click', () => backgroundFetch('symbol_all_tf', { mode: 'inc' }));
      const btnFetchAll = document.getElementById('btnFetchAll');
      if (btnFetchAll) btnFetchAll.addEventListener('click', () => backgroundFetch('all_symbols', { mode: 'inc' }));
      const btnStlCurrent = el('btnStlCurrent');
      if (btnStlCurrent) btnStlCurrent.addEventListener('click', () => triggerStl('current'));
      if (stlPeriodLinesToggle) stlPeriodLinesToggle.addEventListener('change', () => {
        showPeriodLines = !!stlPeriodLinesToggle.checked;
        const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
        const effPeriod = overlayPeriod && Number.isFinite(overlayPeriod) ? Math.max(1, Math.floor(overlayPeriod)) : null;
        if (effPeriod) computePeriodBoundaryTimes(effPeriod);
        updatePeriodOverlays(effPeriod);
        redrawPeriodLines();
      });
      if (stlDerivativeToggle) stlDerivativeToggle.addEventListener('change', () => {
        updateStlDerivativeSeries();
      });
      if (stlAccelerationToggle) stlAccelerationToggle.addEventListener('change', () => {
        updateStlDerivativeSeries();
      });
      const btnStlSymbolAll = el('btnStlSymbolAll');
      if (btnStlSymbolAll) btnStlSymbolAll.addEventListener('click', () => triggerStl('symbol_all_tf'));
      const btnStlTfAll = el('btnStlTfAll');
      if (btnStlTfAll) btnStlTfAll.addEventListener('click', () => triggerStl('timeframe_all_symbols'));
      const btnStlAll = el('btnStlAll');
      if (btnStlAll) btnStlAll.addEventListener('click', () => triggerStl('all'));
      if (stlAllToggle) stlAllToggle.addEventListener('change', () => {
        stlAllData = !!stlAllToggle.checked;
        if (stlAllData && stlDatasetRange) {
          stlTargetStart = stlDatasetRange.start_ts;
          stlTargetEnd = stlDatasetRange.end_ts;
        }
        updateStlInputsFromState();
        refreshStlOverlay({});
      });
      if (stlAutoToggle) stlAutoToggle.addEventListener('change', () => {
        stlAutoPeriod = !!stlAutoToggle.checked;
        queuePrefUpdate('stl_auto_period', stlAutoPeriod ? '1' : '0');
        if (stlAutoPeriod && Number.isFinite(stlLastPeriod) && stlLastPeriod >= 1) {
          stlManualPeriod = stlLastPeriod;
          if (stlPeriodInput) stlPeriodInput.value = stlManualPeriod;
        }
        updateStlInputsFromState();
        const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
        const effPeriod2 = overlayPeriod && Number.isFinite(overlayPeriod) ? Math.max(1, Math.floor(overlayPeriod)) : null;
        if (effPeriod2) computePeriodBoundaryTimes(effPeriod2);
        updatePeriodOverlays(effPeriod2);
      });
      if (stlPeriodInput) stlPeriodInput.addEventListener('change', () => {
        const val = Number(stlPeriodInput.value);
        if (!Number.isFinite(val) || val < 3) {
          status('STL period must be >= 3.');
          stlPeriodInput.value = stlManualPeriod;
          return;
        }
        stlManualPeriod = Math.round(val);
        stlPeriodInput.value = stlManualPeriod;
        queuePrefUpdate('stl_manual_period', stlManualPeriod);
        if (!stlAutoPeriod) updatePeriodOverlays(stlManualPeriod);
      });
      if (stlStartInput) stlStartInput.addEventListener('change', () => {
        if (stlAllData) return;
        const iso = localInputToIso(stlStartInput.value);
        if (!iso) { status('Invalid STL start time.'); return; }
        stlTargetStart = iso;
        if (stlTargetEnd && new Date(stlTargetStart) >= new Date(stlTargetEnd)) {
          status('STL range invalid: start must be before end.');
          return;
        }
        refreshStlOverlay({});
      });
      if (stlEndInput) stlEndInput.addEventListener('change', () => {
        if (stlAllData) return;
        const iso = localInputToIso(stlEndInput.value);
        if (!iso) { status('Invalid STL end time.'); return; }
        stlTargetEnd = iso;
        if (stlTargetStart && new Date(stlTargetStart) >= new Date(stlTargetEnd)) {
          status('STL range invalid: start must be before end.');
          return;
        }
        refreshStlOverlay({});
      });
      if (stlRunsSelect) stlRunsSelect.addEventListener('change', () => {
        stlSelectedRunId = stlRunsSelect.value ? Number(stlRunsSelect.value) : null;
        if (stlDeleteBtn) stlDeleteBtn.disabled = !stlSelectedRunId;
        refreshStlOverlay({ runId: stlSelectedRunId });
      });
      if (stlDeleteBtn) stlDeleteBtn.addEventListener('click', async () => {
        const selected = stlRunsSelect && stlRunsSelect.value ? stlRunsSelect.value : '';
        if (!selected) {
          status('Select a saved STL run to delete.');
          return;
        }
        if (typeof window.confirm === 'function' && !window.confirm(`Delete STL run ${selected}?`)) return;
        try {
          const resp = await fetch(`/api/stl/run/${encodeURIComponent(selected)}`, { method: 'DELETE', cache: 'no-store' });
          const js = await resp.json().catch(() => ({}));
          if (!resp.ok || !js.ok) {
            status(`Delete failed: ${js.error || resp.statusText}`);
          } else {
            status(`Deleted STL run ${selected}`);
            stlSelectedRunId = null;
            stlLastRows = [];
            stlLastMeta = null;
            refreshStlOverlay({});
          }
        } catch (err) {
          status(`Delete failed: ${err.message || err}`);
        }
      });
      const volumeInput = el('volume');
      if (volumeInput) volumeInput.addEventListener('change', () => queuePrefUpdate('last_volume', volumeInput.value));
      const slInput = el('sl');
      if (slInput) slInput.addEventListener('change', () => queuePrefUpdate('last_sl', slInput.value));
      const tpInput = el('tp');
      if (tpInput) tpInput.addEventListener('change', () => queuePrefUpdate('last_tp', tpInput.value));
      const fastInput = el('fast');
      if (fastInput) fastInput.addEventListener('change', () => queuePrefUpdate('last_fast', fastInput.value));
      const slowInput = el('slow');
      if (slowInput) slowInput.addEventListener('change', () => queuePrefUpdate('last_slow', slowInput.value));
      document.querySelectorAll('input[name="ctype"]').forEach(r => r.addEventListener('change', (e) => {
        queuePrefUpdate('chart_type', e.target.value);
        const nextType = e.target.value;
        // Disable LW subscriptions while switching chart type to avoid spurious sync
        lwSubscriptionsEnabled = false;
        makeChart(nextType);
        refreshChart();
        // Re-enable only for candlestick once data is applied in refreshChart
      }));

      let autoTimer = null;
      const btnAuto = el('btnAuto');
      const computeAutoInterval = () => {
        const tfEl = el('tf');
        const tf = tfEl && tfEl.value ? tfEl.value : 'M1';
        const minuteMs = 60000;
        if (tf.startsWith('M')) return minuteMs;
        if (tf.startsWith('H')) return 60 * minuteMs;
        return 15 * minuteMs;
      };
      const updateAutoUi = (running) => {
        if (btnAuto) btnAuto.textContent = running ? 'Stop Auto' : 'Start Auto';
      };
      const stopAuto = ({ announce = true } = {}) => {
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        updateAutoUi(false);
        if (announce) status('Auto stopped');
      };
      const startAuto = ({ announce = true, immediate = false } = {}) => {
        const ms = computeAutoInterval();
        if (!ms) return;
        if (autoTimer) clearInterval(autoTimer);
        autoTimer = setInterval(fetchAndSave, ms);
        updateAutoUi(true);
        if (announce) status('Auto started');
        if (immediate) fetchAndSave();
      };
      if (btnAuto) {
        btnAuto.addEventListener('click', () => {
          if (autoTimer) {
            stopAuto();
          } else {
            startAuto({ announce: true, immediate: true });
          }
        });
      }

      async function trade(side) {
        const symbol = currentSymbol();
        const volume = el('volume').value;
        queuePrefUpdate('last_volume', volume);
        queuePrefUpdate('last_sl', el('sl').value);
        queuePrefUpdate('last_tp', el('tp').value);
        status(`${side.toUpperCase()} submitting...`);
        const sl = el('sl').value; const tp = el('tp').value;
        const body = new URLSearchParams({ symbol, side, volume, sl, tp });
        const r = await fetch(`/api/trade`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body, cache: 'no-store' });
        const js = await r.json().catch(() => ({}));
        if (js.ok) {
          status(`${side.toUpperCase()} ok: ${JSON.stringify(js.result)}`);
          await refreshChart();
          await refreshPositions();
        } else {
          status(`Trade error: ${js.error || r.statusText}`);
        }
      }

      async function closeAll() {
        const symbol = currentSymbol();
        status('Closing positions...');
        const body = new URLSearchParams({ symbol });
        const r = await fetch(`/api/close`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body, cache: 'no-store' });
        const js = await r.json().catch(() => ({}));
        if (js.ok) {
          status(`Closed positions: ${JSON.stringify(js.closed)}`);
          await refreshChart();
          await refreshPositions();
        } else {
          status(`Close error: ${js.error || r.statusText}`);
        }
      }

      async function refreshPositions() {
        const symbol = currentSymbol();
        const r = await fetch(`/api/positions?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
        const js = await r.json().catch(() => ({}));
        if (js.ok) {
          const list = (js.positions || []).map(p => `#${p.ticket} ${p.type===0?'BUY':'SELL'} vol=${p.volume} @ ${p.price_open} pnl=${p.profit}`);
          el('positionsBox').textContent = list.length ? list.join('\n') : 'No open positions.';
        } else {
          el('positionsBox').textContent = `Positions error: ${js.error || r.statusText}`;
        }
      }
      async function runStrategyTop() {
        const symbol = currentSymbol();
        const tf = currentTf();
        const fast = 20, slow = 50;
        try {
          const r = await fetch(`/api/strategy/run?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&fast=${fast}&slow=${slow}`, { cache:'no-store' });
          const js = await r.json();
          const sig = js && js.signal ? (js.signal.signal || js.signal) : 'hold';
          lastSignal = sig;
          updateSignalUI(sig, js.signal && js.signal.reason);
          if (typeof tradeState !== 'undefined' && tradeState) {
            if (sig === 'buy') tradeState.action = 'BUY';
            else if (sig === 'sell') tradeState.action = 'SELL';
          }
        } catch (e) {
          console.error('Strategy fetch failed', e);
          updateSignalUI('hold', 'error');
        }
      }
      document.getElementById('btnRunStratTop').addEventListener('click', runStrategyTop);
      document.getElementById('btnTradeSignalTop').addEventListener('click', () => {
        if (lastSignal === 'buy' || lastSignal === 'sell') trade(lastSignal);
      });
      document.getElementById('btnAutoStrat').addEventListener('click', (ev) => {
        if (autoStratTimer) {
          clearInterval(autoStratTimer); autoStratTimer = null; ev.target.textContent = 'Auto Off';
        } else {
          runStrategyTop();
          autoStratTimer = setInterval(runStrategyTop, 15000); // every 15s
          ev.target.textContent = 'Auto On';
        }
      });
      // initial strategy read
      runStrategyTop();
      // Always fetch latest AI trade plan for current symbol/TF
      setTimeout(() => { try { loadLatestAiPlanPreview(); } catch (_) {} }, 200);

      // Strategy panel actions
      async function runStrategy() {
        const symbol = currentSymbol();
        const tf = currentTf();
        const fast = el('fast').value || '20';
        const slow = el('slow').value || '50';
        queuePrefUpdate('last_fast', fast);
        queuePrefUpdate('last_slow', slow);
        try {
          const r = await fetch(`/api/strategy/run?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&fast=${encodeURIComponent(fast)}&slow=${encodeURIComponent(slow)}`, { cache:'no-store' });
          const js = await r.json().catch(() => ({}));
          if (js && js.signal) {
            lastSignal = js.signal.signal || js.signal;
            const reason = js.signal.reason ? ` (${js.signal.reason})` : '';
            el('stratStatus').textContent = `Signal: ${lastSignal.toUpperCase()}${reason}`;
            el('btnTradeSignal').disabled = !(lastSignal === 'buy' || lastSignal === 'sell');
          } else {
            el('stratStatus').textContent = `Strategy error: ${js.error || r.statusText}`;
            el('btnTradeSignal').disabled = true;
          }
        } catch (err) {
          console.error('Strategy fetch failed', err);
          el('stratStatus').textContent = 'Strategy error';
          el('btnTradeSignal').disabled = true;
        }
      }
      const btnRunStrat = document.getElementById('btnRunStrat');
      if (btnRunStrat) btnRunStrat.addEventListener('click', runStrategy);
      const btnTradeSignal = document.getElementById('btnTradeSignal');
      if (btnTradeSignal) btnTradeSignal.addEventListener('click', () => {
        if (lastSignal === 'buy' || lastSignal === 'sell') trade(lastSignal);
      });

      // Initial load
      // News & intel helpers
      const htmlEscape = (str) => {
        if (typeof str !== 'string') return '';
        return str.replace(/[&<>\"']/g, (ch) => ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
        })[ch] || ch);
      };
      const isFiniteNumber = (val) => val !== null && val !== undefined && val !== '' && Number.isFinite(Number(val));
      const niceNumber = (val, opts = {}) => {
        if (!isFiniteNumber(val)) return '—';
        return Number(val).toLocaleString(undefined, opts);
      };
      const formatBigNumber = (val) => {
        if (!isFiniteNumber(val)) return '—';
        const num = Number(val);
        const abs = Math.abs(num);
        if (abs >= 1e12) return `${(num / 1e12).toFixed(2)}T`;
        if (abs >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
        if (abs >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
        if (abs >= 1e3) return `${(num / 1e3).toFixed(2)}K`;
        return num.toLocaleString();
      };
      const priceDigits = (sym, type) => {
        const upper = (sym || '').toUpperCase();
        if (type === 'forex') {
          if (upper.startsWith('XAU') || upper.startsWith('XAG') || upper.startsWith('XPT') || upper.startsWith('XPD')) {
            return 2;
          }
          return 5;
        }
        return 2;
      };

      function renderSymbolInfo(snapshot) {
        const box = el('symbolInfoBox');
        if (!box) return;
        if (!snapshot || Object.keys(snapshot).length === 0) {
          box.innerHTML = '<em style="color:var(--muted)">Provide FMP/Alpha Vantage API keys in <code>.env</code> to enable symbol intelligence.</em>';
          return;
        }
        const type = snapshot.type || 'equity';
        const symbol = snapshot.symbol || currentSymbol();
        const name = snapshot.name || symbol;
        const priceVal = isFiniteNumber(snapshot.price) ? Number(snapshot.price) : null;
        const changeVal = isFiniteNumber(snapshot.change) ? Number(snapshot.change) : null;
        const pctVal = isFiniteNumber(snapshot.changesPercentage) ? Number(snapshot.changesPercentage) : null;
        const fractionDigits = priceDigits(symbol, type);
        const priceStr = niceNumber(priceVal, { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits });
        const changePieces = [];
        if (changeVal !== null) changePieces.push(niceNumber(changeVal, { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits }));
        if (pctVal !== null) changePieces.push(`${niceNumber(pctVal, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%`);
        const changeColor = changeVal !== null
          ? (changeVal > 0 ? 'var(--buy)' : changeVal < 0 ? 'var(--sell)' : 'var(--muted)')
          : (pctVal !== null ? (pctVal > 0 ? 'var(--buy)' : pctVal < 0 ? 'var(--sell)' : 'var(--muted)') : 'var(--muted)');

        const details = [];
        if (snapshot.exchange) details.push(`Exchange: ${htmlEscape(snapshot.exchange)}`);
        if (snapshot.sector) details.push(`Sector: ${htmlEscape(snapshot.sector)}`);
        if (snapshot.industry) details.push(`Industry: ${htmlEscape(snapshot.industry)}`);
        if (isFiniteNumber(snapshot.marketCap)) details.push(`Mkt Cap: ${formatBigNumber(snapshot.marketCap)}`);
        if (isFiniteNumber(snapshot.volume)) details.push(`Vol: ${formatBigNumber(snapshot.volume)}`);
        if (isFiniteNumber(snapshot.avgVolume)) details.push(`Avg Vol: ${formatBigNumber(snapshot.avgVolume)}`);
        if (type === 'forex') {
          if (isFiniteNumber(snapshot.dayHigh) || isFiniteNumber(snapshot.dayLow)) {
            details.push(`Day: ${niceNumber(snapshot.dayLow, { maximumFractionDigits: fractionDigits })} → ${niceNumber(snapshot.dayHigh, { maximumFractionDigits: fractionDigits })}`);
          }
          if (isFiniteNumber(snapshot.yearLow) || isFiniteNumber(snapshot.yearHigh)) {
            details.push(`52w: ${niceNumber(snapshot.yearLow, { maximumFractionDigits: fractionDigits })} → ${niceNumber(snapshot.yearHigh, { maximumFractionDigits: fractionDigits })}`);
          }
        }
        let desc = '';
        if (snapshot.description) {
          const fullDesc = String(snapshot.description);
          const trimmed = fullDesc.slice(0, 280);
          desc = `<div style="font-size:12px; color:var(--muted); margin-top:4px;">${htmlEscape(trimmed)}${fullDesc.length > trimmed.length ? '…' : ''}</div>`;
        }
        if (snapshot.website) {
          details.push(`<a href="${htmlEscape(snapshot.website)}" target="_blank" rel="noopener">Website</a>`);
        }
        box.innerHTML = `
          <div style="display:flex; flex-direction:column; gap:4px;">
            <div style="font-weight:600; color:var(--text);">${htmlEscape(name)} <span style="font-weight:500; color:var(--muted);">(${htmlEscape(symbol)})</span></div>
            <div style="display:flex; gap:10px; align-items:baseline; flex-wrap:wrap;">
              <span style="font-size:20px; font-weight:600; color:var(--text);">${priceStr}</span>
              <span style="font-weight:600; color:${changeColor};">${changePieces.join(' · ')}</span>
            </div>
            ${details.length ? `<div style="font-size:12px; color:var(--muted); display:flex; flex-wrap:wrap; gap:6px;">${details.join(' • ')}</div>` : ''}
            ${desc}
          </div>
        `;
      }

      function renderNews(items) {
        const box = el('newsBox');
        if (!box) return;
        box.innerHTML = '';
        if (!items || !items.length) {
          box.innerHTML = '<em style="color:var(--muted)">No recent news found for this symbol.</em>';
          return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          const card = document.createElement('div');
          card.className = 'news-card';

          const titleText = item.title || item.headline || '(no title)';
          const titleEl = document.createElement('h4');
          const titleLink = document.createElement('a');
          titleLink.textContent = titleText;
          if (item.url) {
            titleLink.href = item.url;
            titleLink.target = '_blank';
            titleLink.rel = 'noopener';
          } else {
            titleLink.href = '#';
          }
          titleLink.style.color = 'var(--accent)';
          titleLink.style.textDecoration = 'none';
          titleEl.appendChild(titleLink);
          card.appendChild(titleEl);

          const metaParts = [];
          if (item.source || item.site) metaParts.push(item.source || item.site);
          if (item.publishedAt || item.publishedDate || item.date) {
            metaParts.push(item.publishedAt || item.publishedDate || item.date);
          }
          if (metaParts.length) {
            const metaEl = document.createElement('div');
            metaEl.className = 'news-meta';
            metaEl.textContent = metaParts.join(' • ');
            card.appendChild(metaEl);
          }

          const summaryText = NEWS_SHOW_FULL ? (item.body || item.summary || item.description || item.snippet || '') : (item.summary || item.description || item.snippet || '');
          if (summaryText) {
            const summaryEl = document.createElement('div');
            summaryEl.className = 'news-summary';
            summaryEl.textContent = summaryText;
            card.appendChild(summaryEl);
          }

          const fallbackKey = [titleText, summaryText, metaParts.join('|')].filter(Boolean).join('|');

          const actionsEl = document.createElement('div');
          actionsEl.className = 'news-actions';
          // Read button to open full text in modal
          const readBtn = document.createElement('button');
          readBtn.type = 'button';
          readBtn.className = 'btn secondary';
          readBtn.textContent = 'Read';
          readBtn.addEventListener('click', () => {
            const fullBody = (item.body || item.text || item.summary || item.description || item.snippet || '').toString();
            openNewsModal(titleText, fullBody);
          });

          const aiBtn = document.createElement('button');
          aiBtn.type = 'button';
          aiBtn.className = 'btn secondary news-ai-btn';
          // Keep the button visible but disabled per request
          aiBtn.textContent = 'Ask AI (30 checks)';
          aiBtn.disabled = true;
          actionsEl.appendChild(readBtn);
          actionsEl.appendChild(aiBtn);
          card.appendChild(actionsEl);

          const answersWrap = document.createElement('div');
          answersWrap.className = 'news-answers';
          card.appendChild(answersWrap);

          const cacheKey = newsArticleKey(item) || fallbackKey || titleText;
          if (NEWS_AI_AVAILABLE) {
            aiBtn.addEventListener('click', () => requestNewsAnalysis(item, cacheKey, aiBtn, answersWrap));
            if (newsAnalysisCache.has(cacheKey)) {
              renderNewsAnswers(answersWrap, newsAnalysisCache.get(cacheKey));
            }
          }

          fragment.appendChild(card);
        });
        box.appendChild(fragment);
      }

      function renderNewsAnswers(container, answers) {
        if (!container) return;
        container.innerHTML = '';
        if (!answers || !answers.length) {
          container.classList.remove('active');
          return;
        }
        container.classList.add('active');
        answers.forEach((ans) => {
          const pill = document.createElement('span');
          const answerValue = (ans && ans.answer) ? String(ans.answer).toLowerCase() : 'no';
          pill.className = `news-answer ${answerValue}`;
          const labelText = ans && ans.label ? ans.label : ans.id || 'Question';
          pill.textContent = `${labelText}: ${answerValue.toUpperCase()}`;
          if (ans && ans.question) {
            pill.title = ans.question;
          }
          container.appendChild(pill);
        });
      }

      function setNewsAnalysisUnavailable(container, message) {
        if (!container) return;
        container.classList.add('active');
        container.innerHTML = '';
        const pill = document.createElement('span');
        pill.className = 'news-answer unknown';
        pill.textContent = message || 'Analysis unavailable';
        container.appendChild(pill);
      }

      async function requestNewsAnalysis(article, cacheKey, button, container) {
        if (!NEWS_AI_AVAILABLE) {
          status('LLM analysis unavailable (set OPENAI_API_KEY).');
          setNewsAnalysisUnavailable(container, 'AI unavailable');
          return;
        }
        if (!article) return;
        if (cacheKey && newsAnalysisCache.has(cacheKey)) {
          renderNewsAnswers(container, newsAnalysisCache.get(cacheKey));
          return;
        }
        if (button) {
          button.disabled = true;
          button.textContent = 'Analyzing…';
        }
        if (container) {
          container.classList.add('active');
          container.innerHTML = '<span class="news-answer unknown">Analyzing…</span>';
        }
        const payload = {
          article_id: cacheKey,
          title: article.title || article.headline || '',
          summary: article.summary || article.description || '',
          body: article.content || article.text || '',
          url: article.url || '',
          source: article.source || article.site || '',
          published_at: article.publishedAt || article.publishedDate || article.date || '',
          symbol: currentSymbol(),
        };
        try {
          const resp = await fetch('/api/news/analyze', {
            method: 'POST',
            cache: 'no-store',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const js = await resp.json().catch(() => ({}));
          if (!resp.ok || !js.ok) {
            const msg = js.error || resp.statusText || 'AI analysis failed';
            status(msg);
            setNewsAnalysisUnavailable(container, msg);
            return;
          }
          const answers = js.answers || [];
          if (cacheKey) {
            newsAnalysisCache.set(cacheKey, answers);
          }
          renderNewsAnswers(container, answers);
          status('AI micro-checks completed for news article.');
        } catch (err) {
          status(`AI analysis failed: ${err.message || err}`);
          setNewsAnalysisUnavailable(container, 'Analysis failed');
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = 'Ask AI (30 checks)';
          }
        }
      }

      let NEWS_SHOW_FULL = false;
      // Affiliate widget visibility controls
      const RF_TOP_KEY = 'rfTopQuotesHidden';
      const RF_BOT_KEY = 'rfBottomBannerHidden';
      const RF_BR_KEY = 'rfRightForecastsHidden';
      const RF_WIDGET_IDS = ['rfBottomBanner', 'rfRightForecasts'];
      const rfOptIn = (() => {
        try {
          const v = localStorage.getItem('rfWidgetsOptIn');
          // Default to ON when unset; user can still hide per-widget.
          return v === null || v === '1';
        } catch (_) {
          return true;
        }
      })();
      const teardownRfWidget = (id) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.querySelectorAll('[data-rf-content]').forEach((node) => node.remove());
        delete el.dataset.rfMounted;
        const placeholderText = el.dataset.rfPlaceholder || 'RoboForex widget disabled.';
        if (!el.querySelector('.rf-placeholder')) {
          const target = el.dataset.rfType === 'img' ? el.querySelector('a') || el : el;
          const placeholderTag = el.dataset.rfType === 'img' ? 'span' : 'div';
          const placeholder = document.createElement(placeholderTag);
          placeholder.className = 'rf-placeholder';
          placeholder.textContent = placeholderText;
          if (el.dataset.rfType === 'iframe') {
            const head = el.querySelector('.rf-head');
            if (head) {
              head.insertAdjacentElement('afterend', placeholder);
            } else {
              el.appendChild(placeholder);
            }
          } else {
            target.appendChild(placeholder);
          }
        }
      };
      const mountRfWidget = (id) => {
        const el = document.getElementById(id);
        if (!el || el.dataset.rfMounted === '1' || el.classList.contains('rf-hidden')) return;
        const type = el.dataset.rfType;
        const src = el.dataset.rfSrc;
        if (!type || !src) return;
        const width = el.dataset.rfWidth || '100%';
        const height = el.dataset.rfHeight || '200';
        el.querySelectorAll('.rf-placeholder').forEach((node) => node.remove());
        if (type === 'iframe') {
          const iframe = document.createElement('iframe');
          iframe.setAttribute('data-rf-content', '1');
          iframe.frameBorder = '0';
          iframe.loading = 'lazy';
          iframe.className = 'efx';
          iframe.width = width;
          iframe.height = height;
          iframe.src = src;
          const head = el.querySelector('.rf-head');
          const closeBtn = el.querySelector('.rf-btn') || el.querySelector('button');
          if (head && head.parentNode === el) {
            head.insertAdjacentElement('afterend', iframe);
          } else if (closeBtn && closeBtn.parentNode === el) {
            el.insertBefore(iframe, closeBtn);
          } else {
            el.insertBefore(iframe, el.firstChild);
          }
        } else if (type === 'img') {
          const anchor = el.querySelector('a');
          if (!anchor) return;
          const img = document.createElement('img');
          img.setAttribute('data-rf-content', '1');
          img.loading = 'lazy';
          img.src = src;
          const w = parseInt(width, 10);
          const h = parseInt(height, 10);
          if (!Number.isNaN(w)) img.width = w;
          if (!Number.isNaN(h)) img.height = h;
          img.alt = 'RoboForex';
          anchor.appendChild(img);
        }
        el.dataset.rfMounted = '1';
        el.classList.remove('rf-hidden');
      };
      const setRfHidden = (id, key) => {
        const el = document.getElementById(id);
        if (el) {
          teardownRfWidget(id);
          el.classList.add('rf-hidden');
        }
        try { localStorage.setItem(key, '1'); } catch {}
      };
      const initRfWidget = (id, key, btnId) => {
        const el = document.getElementById(id);
        const btn = document.getElementById(btnId);
        if (!el) return;
        let hidden = false;
        try {
          hidden = localStorage.getItem(key) === '1';
        } catch {}
        // Always allow showing now (do not clear the stored flag),
        // but remove CSS hidden class so widget can render.
        try { el.classList.remove('rf-hidden'); } catch {}
        if (btn) btn.addEventListener('click', () => setRfHidden(id, key));
        if (rfOptIn) {
          mountRfWidget(id);
        }
      };
      if (!rfOptIn) {
        RF_WIDGET_IDS.forEach((id) => {
          const el = document.getElementById(id);
          if (el) {
            teardownRfWidget(id);
            el.classList.add('rf-hidden');
          }
        });
        window.enableRoboForexWidgets = () => {
          try { localStorage.setItem('rfWidgetsOptIn', '1'); } catch {}
          window.location.reload();
        };
      } else {
        RF_WIDGET_IDS.forEach((id) => mountRfWidget(id));
        window.disableRoboForexWidgets = () => {
          try { localStorage.setItem('rfWidgetsOptIn', '0'); } catch {}
          window.location.reload();
        };
      }
      initRfWidget('rfTopQuotes', RF_TOP_KEY, 'rfTopQuotesClose');
      initRfWidget('rfBottomBanner', RF_BOT_KEY, 'rfBottomBannerClose');
      initRfWidget('rfRightForecasts', RF_BR_KEY, 'rfRightForecastsClose');
      // Modal helpers for full news text
      const modalEl = document.getElementById('newsModal');
      const modalTitleEl = document.getElementById('newsModalTitle');
      const modalBodyEl = document.getElementById('newsModalBody');
      const modalCloseEl = document.getElementById('newsModalClose');
      const openNewsModal = (title, body) => {
        if (modalTitleEl) modalTitleEl.textContent = title || 'Full Article';
        if (modalBodyEl) modalBodyEl.textContent = (body || '').toString();
        if (modalEl) {
          modalEl.style.display = 'flex';
          modalEl.setAttribute('aria-hidden', 'false');
        }
      };
      const closeNewsModal = () => {
        if (modalEl) {
          modalEl.style.display = 'none';
          modalEl.setAttribute('aria-hidden', 'true');
        }
        if (modalTitleEl) modalTitleEl.textContent = '';
        if (modalBodyEl) modalBodyEl.textContent = '';
      };
      if (modalCloseEl) modalCloseEl.addEventListener('click', closeNewsModal);
      if (modalEl) modalEl.addEventListener('click', (e) => { if (e.target === modalEl) closeNewsModal(); });

      // (Affiliate Backlinks panel removed per request)

      async function refreshNews(arg = {}) {
        let opts = {};
        if (arg && typeof arg.preventDefault === 'function') {
          arg.preventDefault();
        } else if (arg && typeof arg === 'object' && arg !== null) {
          opts = arg;
        }
        const symbol = currentSymbol();
        const reason = opts.reason || 'manual';
        const disableButton = !!opts.disableButton;
        const silent = !!opts.silent;
        const newsBox = el('newsBox');
        debugLog('[App] Refresh news/intel for', symbol, 'reason=', reason);
        if (!silent) {
          setNewsStatus(`Refreshing news for ${symbol}…`, 'info');
        }
        if (newsBox && !opts.skipPlaceholder) {
          newsBox.innerHTML = '<em style="color:var(--muted)">Loading latest news…</em>';
        }
        if (disableButton && btnNews) {
          btnNews.disabled = true;
          btnNews.textContent = 'Refreshing…';
        }
        try {
          const r = await fetch(`/api/news?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
          const js = await r.json();
          if (js && js.ok) {
            const items = js.news || [];
            renderSymbolInfo(js.snapshot || {});
            renderNews(items);
            lastNewsUpdatedAt = new Date();
            if (!silent) {
              const ts = lastNewsUpdatedAt.toLocaleTimeString();
              setNewsStatus(`Updated ${ts} • ${items.length} item${items.length === 1 ? '' : 's'}`, 'ok');
            }
            debugLog(`[App] News result ok=true count=${items.length} snapshot=${!!js.snapshot}`);
          } else {
            renderSymbolInfo({});
            renderNews([]);
            if (!silent) {
              setNewsStatus('News refresh failed (server error).', 'error');
            }
            debugWarn(`[App] News result ok=false for ${symbol}`, js);
          }
        } catch (e) {
          debugWarn('News fetch failed', e);
          renderSymbolInfo({});
          renderNews([]);
          if (!silent) {
            setNewsStatus(`News refresh failed: ${e.message || e}`, 'error');
          }
        } finally {
          if (disableButton && btnNews) {
            btnNews.disabled = false;
            btnNews.textContent = NEWS_BUTTON_DEFAULT;
          }
          // Update Basic Health freshness indicator
          try { await refreshHealthFreshness(); } catch {}
        }
      }
      if (btnNews) btnNews.addEventListener('click', (ev) => {
        ev.preventDefault();
        refreshNews({ disableButton: true, reason: 'manual_click' });
      });
      if (btnNewsFull) btnNewsFull.addEventListener('click', () => {
        NEWS_SHOW_FULL = !NEWS_SHOW_FULL;
        btnNewsFull.textContent = NEWS_SHOW_FULL ? 'Summaries' : 'Full Text';
        // Re-render using cached last news list by refetching from DOM cache if available
        // Simpler: just call refreshNews to rebuild with full text toggle
        refreshNews({ reason: 'toggle_full_text' });
      });

      // Trading controls
      const btnBuyEl = document.getElementById('btnBuy');
      const btnSellEl = document.getElementById('btnSell');
      const btnCloseEl = document.getElementById('btnClose');
      const btnPosEl = document.getElementById('btnPos');
      if (btnBuyEl) btnBuyEl.addEventListener('click', () => trade('buy'));
      if (btnSellEl) btnSellEl.addEventListener('click', () => trade('sell'));
      if (btnCloseEl) btnCloseEl.addEventListener('click', closeAll);
      if (btnPosEl) btnPosEl.addEventListener('click', refreshPositions);

      // Ticker poll (bid/ask + update button labels)
      let tickTimer = null;
      let autoStratTimer = null;
      async function pollTick() {
        const symbol = currentSymbol();
        try {
          const r = await fetch(`/api/tick?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (js && js.ok && js.tick) {
            const { bid, ask } = js.tick;
            const spr = (Number(ask) - Number(bid));
            const sprStr = Number.isFinite(spr) ? spr.toFixed(3) : '—';
            const bidStr = Number.isFinite(Number(bid)) ? Number(bid).toFixed(3) : '—';
            const askStr = Number.isFinite(Number(ask)) ? Number(ask).toFixed(3) : '—';
            const tk = document.getElementById('ticker');
            if (tk) tk.textContent = `${symbol}  Bid ${bidStr}  Ask ${askStr}  Spr ${sprStr}`;
            const b = document.getElementById('btnBuy');
            const s = document.getElementById('btnSell');
            if (b) b.textContent = `Buy @ ${askStr}`;
            if (s) s.textContent = `Sell @ ${bidStr}`;
          }
        } catch (e) {
          // ignore transient errors
        }
      }
      function startTickPoll() {
        if (tickTimer) clearInterval(tickTimer);
        // immediate update then interval
        pollTick();
        tickTimer = setInterval(pollTick, 2000);
      }
      // restart ticker when symbol changes
      const symSel = document.getElementById('symbol');
      if (symSel) symSel.addEventListener('change', () => { try { localStorage.setItem('last_symbol', currentSymbol()); } catch {} startTickPoll(); });

      // Initial loads
      buildStlOverlayControls();
      updateStlInputsFromState();
      updateStlDerivativeSeries();
      refreshChart();
      refreshNews();
      refreshPositions();
      startAuto({ announce: false });
      startTickPoll();
    </script>
  </body>
  </html>


















