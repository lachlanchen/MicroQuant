<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Micro Quant</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
  <!-- Time scale adapter for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
  <!-- Config via data attributes (avoids HTML entity issues) -->
  <div id="app-cfg" data-symbols="{{ symbols_csv }}" data-default="{{ default_symbol_plain }}" data-ai="{{ 1 if news_ai_available else 0 }}" style="display:none"></div>
  <!-- Minimal modal container for full news text -->
  <div id="newsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-box">
      <div class="modal-head">
        <h3 id="newsModalTitle">Full Article</h3>
        <button id="newsModalClose" class="modal-close" aria-label="Close">×</button>
      </div>
      <div id="newsModalBody" class="modal-body"></div>
    </div>
  </div>
  <style>
    :root {
      --gold: #d4a017;
      --accent: #1976d2; /* vivid blue */
      --accent2: #ff9800; /* orange */
      --buy: #2ecc71; /* green */
      --sell: #e74c3c; /* red */
      --muted: #555;
      --bg: #ffffff;
      --panel: #f7f9fc;
      --text: #111;
      --line: #e0e6ef;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: var(--bg); color: var(--text); }
    header { display:flex; justify-content:space-between; align-items:center; padding: 12px 20px; background: linear-gradient(90deg, var(--accent), var(--accent2)); color: #fff; }
    .brand { display:flex; align-items:center; gap:6px; }
    header h2 { margin: 0; font-weight: 600; }
    #ticker { font-variant-numeric: tabular-nums; }
    .container { padding: 16px 20px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
    label { color: var(--muted); }
    input, select { background: #fff; color: var(--text); border: 1px solid var(--line); border-radius: 6px; padding: 6px 8px; }
    #status { margin-top: 8px; color: var(--muted); }
    #chart-wrap { width: 100%; max-width: 100%; background: var(--panel); padding: 12px; border:1px solid var(--line); border-radius: 8px; box-sizing: border-box; }
    #lwChart { width: 100%; min-height: 520px; height: clamp(520px, 72vh, 920px); }
    /* Overlay canvas to draw period lines over Lightweight Charts */
    #lwChart { position: relative; }
    .lw-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
    #chart { width: 100% !important; height: clamp(420px, 68vh, 840px); }
    #indicator-wrap { margin-top: 12px; display: grid; gap: 12px; width: 100%; }
    .indicator-panel { background: var(--panel); border:1px solid var(--line); border-radius:8px; padding:8px 12px; }
    .indicator-panel h4 { margin:0 0 6px; font-size:13px; color:var(--muted); font-weight:600; letter-spacing:0.4px; text-transform:uppercase; }
    #indicator-wrap canvas { width: 100% !important; height: 190px !important; }
    /* Extra safety for balance pane sizing to avoid LW charts null errors */
    #lwBalance { min-height: 180px; width: 100%; display: block; }
    .news-card { border:1px solid var(--line); border-radius:10px; padding:12px 14px; background:#fff; margin:10px 0; box-shadow:0 1px 2px rgba(0,0,0,0.04); display:flex; flex-direction:column; gap:8px; }
    .news-card h4 { margin:0; font-size:15px; color:var(--text); font-weight:600; }
    .news-meta { font-size:12px; color:var(--muted); display:flex; gap:8px; flex-wrap:wrap; }
    .news-summary { font-size:13px; color:var(--text); line-height:1.4; }
    .news-actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .news-ai-btn { padding:6px 10px; font-size:12px; }
    .news-answers { display:none; flex-wrap:wrap; gap:6px; margin-top:4px; }
    .news-answers.active { display:flex; }
    .news-answer { padding:4px 8px; border-radius:6px; font-size:12px; font-weight:600; border:1px solid var(--line); background:var(--panel); color:var(--muted); }
    .news-answer.yes { border-color:#2ecc71; color:#1b5e20; background:rgba(46, 204, 113, 0.12); }
    .news-answer.no { border-color:#e74c3c; color:#b71c1c; background:rgba(231, 76, 60, 0.12); }
    .news-answer.unknown { border-color:#b0bec5; color:#546e7a; background:rgba(84, 110, 122, 0.12); }
    .news-answer span { font-weight:500; }
    /* Subtle pulse when strategy result updates */
    @keyframes pulse {
      0% { transform: scale(1); box-shadow: 0 0 0 rgba(0,0,0,0); }
      40% { transform: scale(1.15); box-shadow: 0 0 0 rgba(0,0,0,0.0); }
      100% { transform: scale(1); box-shadow: 0 0 0 rgba(0,0,0,0); }
    }
    .pulse { animation: pulse 480ms ease-out 1; }
    /* Simple modal for full news text */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .modal-box { background:#fff; max-width: 920px; width: min(92vw, 920px); max-height: 82vh; overflow:auto; border-radius:10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
    .modal-head { display:flex; justify-content: space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--line); }
    .modal-head h3 { margin:0; font-size:16px; }
    .modal-body { padding: 14px 16px; line-height:1.5; white-space: pre-wrap; }
    .modal-close { background: transparent; border: 0; font-size: 20px; cursor: pointer; color: #444; }
    /* Tighter spacing for Auto AI Trade modal */
    #autoModal .modal-box { width: min(740px, 94vw); max-height: 86vh; }
    #autoModal .modal-head { padding: 6px 10px; }
    #autoModal .modal-body { padding: 6px 10px; line-height: 1.35; }
    #autoModal .row { gap: 6px; margin-bottom: 4px; }
    #autoModal #autoMeta { margin-bottom: 4px; }
    #autoModal #autoHistoryBox { padding: 6px; }
    /* Auto history row highlighting for skipped entries */
    #autoModal .auto-row-skip {
      background: rgba(255, 193, 7, 0.14) !important; /* amber */
      border-color: #ffb300 !important;
    }
    /* Hide duplicated Open/Safe hint under controls; meta line already shows it */
    #autoModal #autoSafeHint { display: none; }
    #autoModal h3 { margin: 0; font-size: 16px; }
    #autoModal .stale-row { background: rgba(231, 76, 60, 0.08); border: 1px solid #e74c3c; border-radius: 6px; padding: 4px 6px; }
    #autoModal .stale-badge { display:inline-block; margin-top:2px; font-size:11px; color:#b71c1c; background:rgba(231,76,60,0.12); border:1px solid #e74c3c; padding:1px 6px; border-radius:6px; width:max-content; }
    #autoModal .fresh-row { background: rgba(46, 204, 113, 0.08); border: 1px solid #2ecc71; border-radius: 6px; padding: 4px 6px; }
    #autoModal .fresh-badge { display:inline-block; margin-top:2px; font-size:11px; color:#1b5e20; background:rgba(46,204,113,0.12); border:1px solid #2ecc71; padding:1px 6px; border-radius:6px; width:max-content; }
    /* RoboForex affiliate widgets (non-intrusive, dismissible) */
    .rf-floating { position: fixed; z-index: 9998; background:#fff; border:1px solid var(--line); border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,0.15); overflow:hidden; }
    .rf-top { top: 8px; right: 12px; }
    .rf-bottom { bottom: 8px; left: 50%; transform: translateX(-50%); }
    .rf-br { bottom: 12px; right: 12px; }
    .rf-head { position:absolute; top:4px; right:6px; display:flex; gap:6px; }
    .rf-btn { border:0; background:rgba(0,0,0,0.5); color:#fff; width:18px; height:18px; line-height:18px; border-radius:3px; font-size:12px; cursor:pointer; }
    .rf-btn:hover { background:rgba(0,0,0,0.7); }
    .rf-hidden { display:none !important; }
    .rf-placeholder { font-size:12px; color:var(--muted); display:block; padding:4px 0; }
    .rf-inline { display:flex; align-items:center; gap:6px; background:#fff; border:1px solid var(--line); border-radius:8px; padding:4px 8px; box-shadow:0 3px 10px rgba(0,0,0,0.08); margin-left:16px; }
    .rf-inline button { border:0; background:transparent; color:var(--muted); cursor:pointer; font-size:16px; line-height:1; padding:0 4px; }
    .rf-inline button:hover { color:#000; }
    .rf-inline iframe { border:0; }
    .pill { padding: 4px 10px; border: 1px solid var(--line); border-radius: 999px; background:#fff; }
    .btn { padding: 10px 14px; background: var(--accent); color: #fff; border: 0; border-radius: 6px; cursor: pointer; }
    .btn.secondary { background: #607d8b; }
    .btn-buy { background: var(--buy); font-weight:600; }
    .btn-sell { background: var(--sell); font-weight:600; }
    .btn:disabled { opacity: 0.6; cursor: default; }
    .grid { display:grid; grid-template-columns: minmax(0, 1fr) 360px; gap: 16px; align-items:start; }
    .control-top { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin:12px 0 16px; }
    .control-group { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .control-group.trade { margin-left:auto; justify-content:flex-end; flex: 1 1 100%; }
    pre { margin:0; }
    .switch { display:inline-flex; align-items:center; gap:6px; font-size:13px; color:var(--text); cursor:pointer; user-select:none; }
    .switch input[type="checkbox"] { width:18px; height:18px; accent-color: var(--accent); cursor:pointer; }
    /* Slider-style switch (only applies when input has class toggle-input and followed by .toggle) */
    .switch .toggle-input { position:absolute; opacity:0; width:0; height:0; }
    .switch .toggle { width:36px; height:20px; border-radius:20px; background:#cfd8dc; position:relative; transition:background .2s ease; box-shadow: inset 0 0 0 1px var(--line); }
    .switch .toggle::after { content:""; position:absolute; top:2px; left:2px; width:16px; height:16px; border-radius:50%; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.25); transition: transform .2s ease; }
    .switch .toggle-input:checked + .toggle { background: var(--buy); }
    .switch .toggle-input:checked + .toggle::after { transform: translateX(16px); }
    .switch .toggle-input:focus-visible + .toggle { outline:2px solid var(--accent); outline-offset:2px; }
      .lw-pane { width: 100%; height: 190px; }
    .stl-row { align-items: center; }
    .stl-field { display:grid; grid-template-columns: 64px 240px; align-items:center; column-gap:8px; }
    .stl-field .stl-lbl { text-align:right; white-space:nowrap; }
    .stl-field input[type="datetime-local"] { width: 240px; max-width: 100%; height: 32px; padding: 6px 8px; }
  </style>
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico" />
  </head>
  <body>
    <header>
      <div class="brand">
        <img src="/static/logo.png" alt="Micro Quant" style="height:40px; width:auto; border-radius:4px;" />
        <h2>Micro Quant</h2>
      </div>
      <iframe width="604" height="40" frameborder="0" class="efx" src="https://staticmy.roboforex-cn.com/en/partners/informers_get/?width=600&width_type=slider&speed=4&color_bg=%23ffffff&color_bd=%23dbe5e8&arrows=on&data_type=askbid&EURUSD=&GBPUSD=&USDCHF=&USDJPY=&USDCAD=&AUDUSD=&NZDUSD=&EURGBP=&EURJPY=&EURCHF=&GBPJPY=&GBPCHF=&type=quotestape" style="margin-left:12px; vertical-align:middle;"></iframe>
      <div style="display:flex; gap:16px; align-items:center;">
        <div id="signalBar" style="display:flex; gap:8px; align-items:center;">
          <span id="signalDot" style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#999;"></span>
          <span id="signalText">Signal: —</span>
          <button class="btn secondary" id="btnRunStratTop" style="padding:6px 10px">Run</button>
          <button class="btn secondary" id="btnAutoStrat" style="padding:6px 10px">Auto Off</button>
          <button class="btn" id="btnTradeSignalTop" style="padding:6px 10px" disabled>Trade Signal</button>
        </div>
        <div id="ticker">—</div>
      </div>
    </header>
    <div class="container">
    <div class="control-top">
      <div class="control-group">
        <label>Symbol
          <select id="symbol">
        {% for sym in symbols %}
            <option value="{{ sym }}"{% if sym == default_symbol %} selected{% end %}>{{ sym }}</option>
        {% end %}
          </select>
        </label>
        <label>Timeframe
          <select id="tf">
            <option value="M1"{% if default_tf == 'M1' %} selected{% end %}>M1</option>
            <option value="M5"{% if default_tf == 'M5' %} selected{% end %}>M5</option>
            <option value="M15"{% if default_tf == 'M15' %} selected{% end %}>M15</option>
            <option value="M30"{% if default_tf == 'M30' %} selected{% end %}>M30</option>
            <option value="H1"{% if default_tf == 'H1' %} selected{% end %}>H1</option>
            <option value="H4"{% if default_tf == 'H4' %} selected{% end %}>H4</option>
            <option value="D1"{% if default_tf == 'D1' %} selected{% end %}>D1</option>
            <option value="W1"{% if default_tf == 'W1' %} selected{% end %}>W1 (Weekly)</option>
            <option value="MN1"{% if default_tf == 'MN1' %} selected{% end %}>MN1 (Monthly)</option>
            <option value="Y1"{% if default_tf == 'Y1' %} selected{% end %}>Y1 (Yearly)</option>
          </select>
        </label>
        <label>Bars
          <input id="count" type="number" min="10" max="5000" value="{{ default_count }}" />
        </label>
        <span class="pill">
          Chart:
          <label><input type="radio" name="ctype" value="line"{% if default_chart_type == 'line' %} checked{% end %}> Line</label>
          <label><input type="radio" name="ctype" value="candlestick"{% if default_chart_type != 'line' %} checked{% end %}> Candlestick</label>
        </span>
        <label class="switch" title="Shift end of chart from right border">
          <input type="checkbox" id="chkChartShift"{% try %}{% if default_chart_shift != '0' %} checked{% end %}{% except %} checked{% end %} />
          <span>Chart shift</span>
        </label>
      </div>
      <div class="control-group">
        <button class="btn" id="btnFetch">Fetch + Save</button>
        <button class="btn secondary" id="btnRefresh">Refresh</button>
        <button class="btn secondary" id="btnAuto">Start Auto</button>
      </div>
      <div class="control-group">
        <button class="btn secondary" id="btnFetchCurrentBg">Current TF</button>
        <button class="btn secondary" id="btnFetchSymbolAll">Symbol × TFs</button>
        <button class="btn secondary" id="btnFetchAll">All Symbols</button>
      </div>
      <div class="control-group" id="stlOverlayRow">
        <div id="stlOverlayControls" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;"></div>
      </div>
      <div class="control-group trade" id="tradeControls">
        <label style="display:flex; align-items:center; gap:6px;">Vol
          <input id="volume" type="number" step="0.01" min="0.01" value="{{ default_volume }}" style="width:100px;" />
        </label>
        <label style="display:flex; align-items:center; gap:6px;">SL
          <input id="sl" type="number" step="0.01" min="0" placeholder="optional" value="{{ default_sl }}" style="width:120px;" />
        </label>
        <label style="display:flex; align-items:center; gap:6px;">TP
          <input id="tp" type="number" step="0.01" min="0" placeholder="optional" value="{{ default_tp }}" style="width:120px;" />
        </label>
        <button class="btn btn-buy" id="btnBuy">Buy</button>
        <button class="btn btn-sell" id="btnSell">Sell</button>
        <button class="btn secondary" id="btnClose">Close Current</button>
        <button class="btn secondary" id="btnCloseAll">Close ALL</button>
      </div>
    </div>
    <div id="status"></div>

    <div class="grid">
      <div>
        <div id="chart-wrap">
          <canvas id="chart" height="400"></canvas>
          <div id="lwChart" style="display:none; height:520px;"></div>
        </div>
        <div id="indicator-wrap">
          <div class="indicator-panel">
            <h4>STL Speed / Accel</h4>
            <div id="lwDeriv" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>RSI (14)</h4>
            <div id="lwRsi" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>MACD (12, 26, 9)</h4>
            <div id="lwMacd" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>Volume</h4>
            <div id="lwVol" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>ATR (14)</h4>
            <div id="lwAtr" class="lw-pane"></div>
          </div>
          <div class="indicator-panel">
            <h4>ADX (14)</h4>
            <div id="lwAdx" class="lw-pane"></div>
          </div>
          <!-- Closed orders controls moved out of charts -->
          <div class="row" id="closedControlsRow" style="gap:12px; align-items:center; margin:4px 0 8px 0;">
            <button class="btn" id="btnPurgeClosed" style="padding:4px 8px; background: var(--sell); color:#fff; border:1px solid var(--sell);">Purge + Refetch</button>
            <button class="btn secondary" id="btnFetchClosed" style="padding:4px 8px;">Fetch Closed</button>
            <button class="btn secondary" id="btnSyncClosed" style="padding:4px 8px;">Sync</button>
            <label style="display:flex; align-items:center; gap:6px;">
              <span style="font-size:12px; color:var(--muted);">Closed PnL refresh (min)</span>
              <input id="closedPollMin" type="number" min="1" value="{% try %}{{ default_closed_orders_poll_min }}{% except %}30{% end %}" style="width:72px;" />
            </label>
            <label style="display:flex; align-items:center; gap:6px;">
              <span style="font-size:12px; color:var(--muted);">Balance snapshot (min)</span>
              <input id="balancePollMin" type="number" min="1" value="{% try %}{{ default_balance_poll_min }}{% except %}1440{% end %}" style="width:72px;" />
            </label>
            <button class="btn secondary" id="btnSaveIntervals" style="padding:4px 8px;">Save</button>
          </div>
          <div class="indicator-panel">
            <h4>Closed PnL (Cumulative)</h4>
            <div style="width:100%">
              <canvas id="pnlChartCanvas" height="190"></canvas>
            </div>
          </div>
          <div class="indicator-panel">
            <h4>Account Balance</h4>
            <div style="width:100%">
              <canvas id="balanceChartCanvas" height="190"></canvas>
            </div>
          </div>
        </div>
      </div>
      <div>
        <!-- Data Source Provider button at top of right column -->
        <div style="padding:8px 12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <a href="https://roboforex.com/"
             class="efx"
             target="_blank"
             rel="noopener noreferrer sponsored"
             style="display:block; width:100%; max-width:100%; box-sizing:border-box; text-align:center; padding:10px 12px; font-size:13px; font-weight:600; color:#fff; text-decoration:none; border-radius:10px; background:linear-gradient(90deg, var(--accent), var(--accent2)); box-shadow:0 6px 18px rgba(0,0,0,0.12); overflow:hidden;">
            Data Source Provider
          </a>
        </div>
        <!-- News panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px; max-height:320px; overflow:auto;">
          <div class="row" id="newsHeader" style="justify-content:space-between; position:sticky; top:0; background:var(--panel); z-index:10; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
            <strong style="color:var(--accent)">News &amp; Intel</strong>
            <div class="row" style="gap:6px;">
              <button class="btn secondary" id="btnNews" style="padding:6px 10px">Refresh News</button>
              <button class="btn secondary" id="btnNewsFull" style="padding:6px 10px">Full Text</button>
            </div>
          </div>
          <div id="newsStatus" style="font-size:12px; color:var(--muted); margin:-4px 0 8px 0;"></div>
          <div id="symbolInfoBox" style="font-size:13px; line-height:1.45; color:var(--muted); margin-bottom:8px;">
            <em>Snapshot will appear here…</em>
          </div>
          <div id="newsBox" style="font-size:14px; line-height:1.35; color:var(--text);"><em style="color:var(--muted)">No news yet…</em></div>
        </div>
        <!-- Analysis panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <div style="display:flex; flex-direction:column; gap:10px;">
            <strong style="color:var(--accent)">Analysis</strong>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Template</span>
                <select id="healthStrategy" style="min-width:220px; padding:4px 6px;"></select>
              </label>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">News to use</span>
                <input id="healthNewsCount" type="number" min="1" max="20" value="20" style="width:72px;" />
              </label>
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Basic AI model</span>
                <select id="basicAiModel" style="min-width:220px; padding:4px 6px;">
                  <option value="">(default)</option>
                  <option value="gpt-5">gpt-5</option>
                  <option value="gpt-4o">gpt-4o</option>
                  <option value="gpt-4o-mini">gpt-4o-mini</option>
                  <option value="deepseek-chat" selected>deepseek-chat</option>
                  <option value="deepseek-reasoner">deepseek-reasoner</option>
                </select>
              </label>
              <button class="btn" id="btnHealthCheck" style="padding:6px 10px;">Basic Health Check</button>
              <span id="healthFreshIndicator" class="pill" style="display:inline-block; font-size:12px;">—</span>
              <label class="switch" style="margin-left:8px;">
                <input type="checkbox" id="chkAutoBasic" class="toggle-input" disabled />
                <span class="toggle"></span>
                <span>Auto Check</span>
              </label>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Bars</span>
                <input id="techHealthBars" type="number" min="1" max="500" style="width:72px;" />
              </label>
              <button class="btn secondary" id="btnTechHealth" style="padding:6px 10px;">Tech Snapshot</button>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Tech template</span>
                <select id="techAiStrategy" style="min-width:220px; padding:4px 6px;">
                  <option value="tech_snapshot_10q_position.json" selected>Tech Snapshot + Position (10)</option>
                  <option value="tech_snapshot_10q.json">Tech Snapshot (10)</option>
                </select>
              </label>
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Tech+AI model</span>
                <select id="techAiModel" style="min-width:220px; padding:4px 6px;">
                  <option value="">(default)</option>
                  <option value="gpt-5">gpt-5</option>
                  <option value="gpt-4o">gpt-4o</option>
                  <option value="gpt-4o-mini">gpt-4o-mini</option>
                  <option value="deepseek-chat" selected>deepseek-chat</option>
                  <option value="deepseek-reasoner">deepseek-reasoner</option>
                </select>
              </label>
              <button class="btn" id="btnTechAiHealth" style="padding:6px 10px;">Tech+AI Check</button>
              <span id="techFreshIndicator" class="pill" style="display:inline-block; font-size:12px;">—</span>
              <label class="switch" style="margin-left:8px;">
                <input type="checkbox" id="chkAutoTech" class="toggle-input" disabled />
                <span class="toggle"></span>
                <span>Auto Check</span>
              </label>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Trade AI model</span>
                <select id="aiModelSelect" style="min-width:220px; padding:4px 6px;">
                  <option value="gpt-5">gpt-5</option>
                  <option value="gpt-4o">gpt-4o</option>
                  <option value="gpt-4o-mini">gpt-4o-mini</option>
                  <option value="deepseek-chat" selected>deepseek-chat (default)</option>
                  <option value="deepseek-reasoner">deepseek-reasoner</option>
                </select>
              </label>
            </div>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
              <button class="btn" id="btnAiBuySell" style="padding:6px 12px; color:#fff; font-weight:600; background:linear-gradient(90deg, #2ecc71, #e74c3c); border:none; box-shadow:0 2px 8px rgba(0,0,0,0.18);">AI Buy/Sell</button>
            </div>
            <div id="aiTradePlanBox" style="font-size:13px; color:var(--text);"></div>
            <!-- Inline AI Trade Plan selector (latest 5 with lazy load) -->
            <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
              <span style="min-width:110px; color:var(--muted);">Plan</span>
              <select id="inlinePlanSelect" style="min-width:220px; flex:1;"></select>
              <button class="btn secondary" id="btnInlinePlanMore" style="padding:6px 10px;">More</button>
            </div>
            <div id="aiPlanHistoryBox" style="display:none; margin-top:8px; border:1px solid var(--line); border-radius:8px; background:var(--panel); padding:8px; max-height:160px; overflow:auto; font-size:12px; color:var(--muted);"></div>
        <!-- Inline account selection for AI Buy/Sell (moved out of modal) -->
        <div class="row" style="gap:10px; align-items:center; margin-top:8px;">
          <span style="min-width:110px; color:var(--muted);">Account</span>
          <select id="tradeAccountSelectInline" style="min-width:220px; flex:1;"></select>
        </div>
        <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
          <button class="btn secondary" id="btnExecutePlan" disabled style="padding:6px 10px;">Execute Plan</button>
        </div>
        <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
          <button class="btn" id="btnAutoAiTrade" style="padding:6px 10px;">Auto AI Trade</button>
        </div>
        <!-- Periodic Auto AI Trade controls -->
        <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
          <label class="switch">
            <input type="checkbox" id="autoPeriodicToggle" />
            <span>Periodic Auto Trade</span>
          </label>
          <label style="display:flex; align-items:center; gap:6px;">
            <span style="min-width:80px; color:var(--muted);">Period</span>
            <select id="autoPeriodicPeriod" style="min-width:120px;">
              <option value="15">15m</option>
              <option value="30">30m</option>
              <option value="60" selected>1h</option>
              <option value="120">2h</option>
              <option value="240">4h</option>
              <option value="1440">1d</option>
            </select>
          </label>
        </div>
        <div class="row" style="gap:10px; align-items:center; margin-top:4px;">
          <span style="min-width:110px; color:var(--muted);">Account</span>
          <select id="autoPeriodicAccountSelect" style="min-width:220px; flex:1;"></select>
        </div>
        <div class="row" style="gap:10px; align-items:center; margin-top:4px;">
          <label style="display:flex; align-items:center; gap:6px;">
            <span style="min-width:110px; color:var(--muted);">Auto volume</span>
            <input id="autoPeriodicVolumeInput" type="number" min="0.01" step="0.01" value="0.01" style="width:110px;" />
          </label>
          <label style="display:flex; align-items:center; gap:6px;">
            <span style="min-width:110px; color:var(--muted);">Safe max lots</span>
            <input id="autoPeriodicSafeMaxInput" type="number" min="0.01" step="0.01" style="width:110px;" />
          </label>
        </div>
        <div class="row" style="gap:10px; align-items:center; margin-top:4px;">
          <label class="switch">
            <input type="checkbox" id="autoPeriodicSlToggle" />
            <span>Set Stop Loss</span>
          </label>
        </div>
        <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
          <button class="btn secondary" id="btnAddAccountOpen" style="padding:6px 10px;">Manage Accounts</button>
        </div>
            <!-- Leverage + position size hint -->
            <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Leverage</span>
                <input id="aiLeverage" type="number" min="1" max="1000" value="10" style="width:80px;" />
              </label>
            </div>
            <div id="posSizeHint" style="font-size:12px; color:var(--muted); margin-top:4px;"></div>
            <!-- Risk controls (per symbol×TF) -->
            <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Risk %</span>
                <input id="riskPercent" type="range" min="0.5" max="2" step="0.1" value="1.0" />
                <span id="riskPercentVal" style="min-width:48px; text-align:right;">1.0%</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Stop</span>
                <input id="stopDistance" type="number" min="0.01" step="0.01" value="10" style="width:100px;" />
                <select id="stopUnit" style="min-width:80px;">
                  <option value="price" selected>Price</option>
                  <option value="pips">Pips</option>
                </select>
              </label>
            </div>
            <!-- Manual safe max lots override (moved below Stop row) -->
            <div class="row" style="gap:10px; align-items:center; margin-top:6px;">
              <label style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:120px; text-align:right;">Safe max lots</span>
                <input id="safeMaxLotsInput" type="number" min="0.01" max="100" step="0.01" style="width:100px;" />
              </label>
              <span style="font-size:12px; color:var(--muted);">(Manual override, saved per symbol × TF)</span>
            </div>
            <div id="blowoutHint" style="font-size:12px; color:var(--muted); margin-top:4px;"></div>
          </div>
        </div>
        <!-- STL panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <div class="row" style="justify-content:space-between; gap:8px;">
            <strong style="color:var(--accent)">STL Decomposition</strong>
            <div style="display:flex; gap:6px; flex-wrap:wrap;">
              <button class="btn secondary" id="btnStlCurrent" style="padding:6px 10px;">Recalculate</button>
              <button class="btn secondary" id="btnStlSymbolAll" style="padding:6px 10px;">Symbol × TFs</button>
              <button class="btn secondary" id="btnStlTfAll" style="padding:6px 10px;">TF × Symbols</button>
              <button class="btn secondary" id="btnStlAll" style="padding:6px 10px;">All</button>
            </div>
          </div>
          <div class="row" style="gap:10px; margin-top:8px; flex-wrap:wrap;">
            <label class="switch">
              <input type="checkbox" id="chkStlAutoPeriod"{% if default_stl_auto_period != '0' %} checked{% end %} />
              <span>Auto period</span>
            </label>
            <label>Period
              <input type="number" id="stlPeriodInput" min="3" value="{{ default_stl_manual_period }}" disabled />
            </label>
            <label class="switch">
              <input type="checkbox" id="chkStlDerivative" checked />
              <span>Show STL speed</span>
            </label>
            <label class="switch">
              <input type="checkbox" id="chkStlAcceleration" />
              <span>Show STL accel</span>
            </label>
            <label class="switch">
              <input type="checkbox" id="chkStlPeriodLines" />
              <span>Period lines</span>
            </label>
          </div>
          <div class="row stl-row" style="gap:10px; margin-top:8px; flex-wrap:wrap; align-items:center;">
            <label class="switch">
              <input type="checkbox" id="chkStlAllData" checked />
              <span>Use all data</span>
            </label>
            <label class="stl-field"><span class="stl-lbl">From</span><input type="datetime-local" id="stlStart" disabled />
            </label>
            <label class="stl-field"><span class="stl-lbl">To</span><input type="datetime-local" id="stlEnd" disabled />
            </label>
          </div>
          <div class="row" style="gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center;">
            <label style="flex:1; min-width:220px; display:flex; align-items:center; gap:8px;">
              <span style="white-space:nowrap;">Saved runs</span>
              <select id="stlRuns" style="flex:1; min-width:140px;">
                <option value="">Latest (auto)</option>
              </select>
            </label>
            <button class="btn secondary" id="btnStlDelete" style="padding:6px 10px; align-self:center;" disabled>Delete</button>
          </div>
          <div id="stlStatus" style="font-size:13px; color:var(--muted); margin-top:6px;">STL overlay not loaded yet.</div>
        </div>
        <!-- Strategy panel -->
        <div style="padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px; margin-bottom:12px;">
          <div class="row">
            <strong style="color:var(--accent)">Strategy: SMA Crossover</strong>
            <label>Fast <input id="fast" type="number" min="2" value="{{ default_fast }}" /></label>
            <label>Slow <input id="slow" type="number" min="3" value="{{ default_slow }}" /></label>
            <button class="btn" id="btnRunStrat">Run Strategy</button>
            <button class="btn secondary" id="btnTradeSignal" disabled>Trade Signal</button>
            <button class="btn secondary" id="btnSignalHistory" style="padding:6px 10px;">History</button>
          </div>
          <div id="stratStatus" style="color:var(--muted)">Signal: —</div>
        </div>
        <div id="rfRightForecasts" style="margin-top:12px; padding:12px; background:var(--panel); border:1px solid var(--line); border-radius:8px;"
          class="rf-hidden"
          data-rf-type="iframe"
          data-rf-src="https://staticmy.roboforex-cn.com/en/partners/informers_get/?width=300&theme_2=classic&amount=5&type=forecasts"
          data-rf-width="100%"
          data-rf-height="260"
          data-rf-placeholder="RoboForex forecasts widget disabled.">
          <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:14px;">
            <strong style="color:var(--accent)">RoboForex Market Forecasts</strong>
            <div class="rf-head" style="position:static;">
              <button class="rf-btn" id="rfRightForecastsClose" title="Hide">×</button>
            </div>
          </div>
        
        </div>
        <!-- Positions moved to bottom (independent panel) -->
        <div style="margin-top:12px;">
          <div class="row">
            <strong style="color:var(--accent)">Positions</strong>
            <button class="btn secondary" id="btnPos" style="margin-left:auto;">Refresh</button>
          </div>
          <pre id="positionsBox" style="margin-top:6px; background:var(--panel); padding:8px; border:1px solid var(--line); border-radius:8px; height:300px; overflow:auto;"></pre>
        </div>
        
        
        </div>
      </div>
    </div>
    <!-- Health Check Modal -->
    <div id="healthModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:1000;">
      <div style="background:#fff; border-radius:8px; border:1px solid var(--line); padding:12px; width:min(760px, 94vw); max-height:86vh; overflow:auto;">
        <div class="row" style="justify-content:space-between; align-items:center; position:sticky; top:0; background:#fff; z-index:5; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
          <strong id="healthModalTitle" style="color:var(--accent)">Health Check</strong>
          <button class="btn secondary" id="btnHealthClose" style="padding:6px 10px;">Close</button>
        </div>
        <div id="healthInfo" style="color:var(--muted); font-size:13px; margin-top:6px;"></div>
        <div style="margin-top:8px;">
          <div style="font-weight:600; color:var(--muted); margin-bottom:4px;">Recent</div>
          <div id="healthHistoryBox" style="border:1px solid var(--line); border-radius:8px; background:var(--panel); padding:8px; max-height:200px; overflow:auto;"></div>
          <div class="row" style="gap:8px; margin-top:6px;">
            <button class="btn secondary" id="btnHealthMore" style="padding:6px 10px;">More</button>
            <button class="btn" id="btnHealthStart" style="padding:6px 10px;">Start</button>
          </div>
        </div>
        <div id="healthResultsBox" style="margin-top:10px;"></div>
      </div>
    </div>
    <!-- Technical Health Modal -->
    <div id="techModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:1000;">
      <div style="background:#fff; border-radius:8px; border:1px solid var(--line); padding:16px; width:min(720px, 94vw); max-height:86vh; overflow:auto;">
        <div class="row" style="justify-content:space-between; align-items:center; position:sticky; top:0; background:#fff; z-index:5; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
          <strong style="color:var(--accent)">Technical Snapshot</strong>
          <button class="btn secondary" id="btnTechClose" style="padding:6px 10px;">Close</button>
        </div>
        <div id="techSummaryMeta" style="margin-top:4px; font-size:13px; color:var(--muted);"></div>
        <div id="techSummaryBox" style="margin-top:12px; display:flex; flex-direction:column; gap:12px;"></div>
      </div>
    </div>
    </div>
    <!-- AI Trade Plan Modal -->
    <div id="tradeModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:1000;">
      <div style="background:#fff; border-radius:8px; border:1px solid var(--line); padding:12px; width:min(760px, 94vw); max-height:86vh; overflow:auto;">
        <div class="row" style="justify-content:space-between; align-items:center; position:sticky; top:0; background:#fff; z-index:5; padding-bottom:8px; margin-bottom:8px; border-bottom:1px solid var(--line);">
          <strong style="color:var(--accent)">AI Trade Plan</strong>
          <button class="btn secondary" id="btnTradeClose" style="padding:6px 10px;">Close</button>
        </div>
        <div id="tradeInfo" style="color:var(--muted); font-size:13px; margin-top:6px;"></div>
        <!-- Source selections for Basic and Tech+AI -->
        <div class="row" style="gap:8px; align-items:center; margin-top:8px;">
          <span style="min-width:110px; color:var(--muted);">Basic</span>
          <select id="selectBasicRun" style="flex:1; min-width:220px;"></select>
          <button class="btn secondary" id="btnNewBasicRun" style="padding:6px 10px;">New Check</button>
        </div>
        <div class="row" style="gap:8px; align-items:center; margin-top:6px;">
          <span style="min-width:110px; color:var(--muted);">Tech+AI</span>
          <select id="selectTechRun" style="flex:1; min-width:220px;"></select>
          <button class="btn secondary" id="btnNewTechRun" style="padding:6px 10px;">New Check</button>
        </div>
        <!-- Plan selection hidden (no longer needed in UI) -->
        <div class="row" style="gap:8px; align-items:center; margin-top:6px; display:none;">
          <span style="min-width:110px; color:var(--muted);">Plan</span>
          <select id="selectPlanRun" style="flex:1; min-width:260px;"></select>
          <button class="btn secondary" id="btnPlanMore" style="padding:6px 10px;">More</button>
        </div>
        <!-- Plan JSON hint/selector (moved below Tech+AI row) -->
        <div class="row" style="gap:8px; align-items:center; margin-top:8px;">
          <span style="min-width:110px; color:var(--muted);">Plan JSON</span>
          <select id="tradePlanSchema" style="flex:1; min-width:260px;">
            <option value="standard" selected>position • stop_loss • take_profit • explanation</option>
          </select>
        </div>
        <!-- BUY/SELL triggers -->
        <div class="row" style="gap:8px; align-items:center; margin-top:6px;">
          <button class="btn btn-buy" id="btnTradeStartBuy" style="padding:6px 10px;">Buy</button>
          <button class="btn btn-sell" id="btnTradeStartSell" style="padding:6px 10px;">Sell</button>
        </div>
        <div style="margin-top:8px;">
          <div style="font-weight:600; color:var(--muted); margin-bottom:4px;">Recent</div>
          <div id="tradeHistoryBox" style="border:1px solid var(--line); border-radius:8px; background:var(--panel); padding:8px; max-height:200px; overflow:auto;"></div>
          <div class="row" style="gap:8px; margin-top:6px;">
            <button class="btn secondary" id="btnTradeMore" style="padding:6px 10px;">More</button>
          </div>
    </div>
  </div>

        <div id="tradeResultsBox" style="margin-top:10px;"></div>
      </div>
    </div>

    <!-- Close Positions Modal (standalone, not nested inside other modals) -->
    <div id="closeModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal-box">
        <div class="modal-head">
          <h3>Close Positions</h3>
          <button id="btnCloseModalX" class="modal-close" aria-label="Close">×</button>
        </div>
        <div class="modal-body" style="padding:12px;">
          <div id="closeModalText" style="margin-bottom:10px; color:var(--muted);"></div>
          <div class="row" style="gap:12px; align-items:center; margin-bottom:8px;">
            <label class="switch" style="gap:6px;">
              <input type="checkbox" id="chkCloseLong" class="toggle-input" />
              <span class="toggle"></span>
              <span>Close Long</span>
            </label>
            <label class="switch" style="gap:6px;">
              <input type="checkbox" id="chkCloseShort" class="toggle-input" />
              <span class="toggle"></span>
              <span>Close Short</span>
            </label>
          </div>
          <div class="row" style="gap:8px;">
            <button class="btn" id="btnConfirmCloseCurrent" style="padding:6px 10px;">Close Current</button>
            <button class="btn secondary" id="btnConfirmCloseAll" style="padding:6px 10px;">Close ALL</button>
            <button class="btn secondary" id="btnCloseModalCancel" style="padding:6px 10px;">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Auto AI Trade Modal -->
    <div id="autoModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true" style="display:none;">
      <div class="modal-box" style="width:min(740px,94vw); max-height:86vh; overflow:auto; position:relative;">
        <div class="modal-head" style="position:sticky; top:0; background:#fff; z-index:5; border-bottom:1px solid var(--line); padding:6px 10px;">
          <h3 style="margin:0; text-align:center; color:var(--accent); font-size:16px;">Auto AI Trade</h3>
          <button class="modal-close" id="btnAutoClose" aria-label="Close" style="position:absolute; right:10px; top:6px;">×</button>
        </div>
        <div class="modal-body" style="padding:8px 10px;">
          <div id="autoMeta" style="font-size:13px; color:var(--muted); margin-bottom:2px;"></div>
          <div class="row" style="gap:6px; align-items:center; margin:0;">
            <label class="switch" title="Include Stop Loss when placing Auto trades" style="gap:6px;">
              <input type="checkbox" id="autoSlToggle" class="toggle-input" />
              <span class="toggle"></span>
              <span>Set Stop Loss</span>
            </label>
            <label style="display:flex; align-items:center; gap:6px;">
              <span style="font-size:12px; color:var(--muted);">Auto Vol</span>
              <input id="autoVolumeInput" type="number" min="0.01" step="0.01" value="0.01" style="width:84px;" />
            </label>
            <label style="display:flex; align-items:center; gap:6px;">
              <span style="font-size:12px; color:var(--muted);">Safe max lots</span>
              <input id="autoSafeMaxInput" type="number" min="0.01" step="0.01" value="0.10" style="width:90px;" />
            </label>
            <label style="display:flex; align-items:center; gap:6px;">
              <span style="font-size:12px; color:var(--muted);">SL scale</span>
              <input id="autoSlScaleInput" type="number" min="0.1" step="0.1" value="1.5" style="width:72px;" />
            </label>
            <span id="autoSafeHint" style="font-size:12px; color:var(--muted);"></span>
          </div>
          <!-- Mirrors of Basic/Tech/Plan (display-only) -->
        <div id="autoMirrorBasicRow" class="row" style="gap:6px; align-items:center; margin-top:2px;">
        <div style="display:flex; flex-direction:column; min-width:80px;">
        <span style="font-size:12px; color:var(--muted);">Basic</span>
        <span id="autoMirrorBasicStale" class="stale-badge" style="display:none;">Outdated</span>
        <span id="autoMirrorBasicFresh" class="fresh-badge" style="display:none;">Up to date</span>
        </div>
            <select id="autoMirrorBasic" style="min-width:260px; padding:4px 6px;" disabled></select>
          </div>
        <div id="autoMirrorTechRow" class="row" style="gap:6px; align-items:center; margin-top:2px;">
        <div style="display:flex; flex-direction:column; min-width:80px;">
        <span style="font-size:12px; color:var(--muted);">Tech+AI</span>
        <span id="autoMirrorTechStale" class="stale-badge" style="display:none;">Outdated</span>
        <span id="autoMirrorTechFresh" class="fresh-badge" style="display:none;">Up to date</span>
        </div>
            <select id="autoMirrorTech" style="min-width:260px; padding:4px 6px;" disabled></select>
          </div>
          <div class="row" style="gap:6px; align-items:center; margin-top:2px;">
            <span style="font-size:12px; color:var(--muted); min-width:80px;">Plan JSON</span>
            <select id="autoPlanSchemaMirror" style="min-width:260px; padding:4px 6px;" disabled></select>
          </div>
          <!-- Account selection moved just below controls -->
          <div class="row" style="gap:6px; align-items:center; margin-top:2px;">
            <span style="font-size:12px; color:var(--muted);">Account</span>
            <select id="autoAccountSelect" style="min-width:200px; padding:4px 6px;"></select>
          </div>
          <div style="margin:0;">
            <div style="font-weight:600; color:var(--muted); margin-bottom:2px;">Recent</div>
            <div id="autoHistoryBox" style="border:1px solid var(--line); border-radius:6px; background:var(--panel); padding:6px; max-height:150px; overflow:auto;"></div>
            <div class="row" style="gap:6px; margin-top:2px;">
              <button class="btn secondary" id="btnAutoMore" style="padding:4px 8px;">More</button>
              <button class="btn" id="btnAutoStart" style="padding:4px 8px;">Start</button>
            </div>
          </div>
          <div id="autoLogBoxModal" style="margin-top:2px; font-size:12px; color:var(--muted); border:1px dashed var(--line); border-radius:6px; padding:6px; max-height:170px; overflow:auto;"></div>
        </div>
      </div>
    </div>

    <div id="addAccountModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true" style="display:none;">
      <div class="modal-box" style="width:min(420px,94vw); max-height:70vh; overflow:auto;">
        <div class="modal-head">
          <h3>Manage MT5 Accounts</h3>
          <button class="modal-close" id="btnAddAccountClose" aria-label="Close">×</button>
        </div>
        <div class="modal-body" style="padding:10px;">
          <div class="row" style="gap:8px; align-items:center; margin-bottom:6px;">
            <label style="display:flex; flex-direction:column; gap:4px; flex:1;">
              <span style="font-size:12px; color:var(--muted);">Accounts</span>
              <select id="addAcctSelect" style="padding:6px; min-width:220px;"></select>
            </label>
          </div>
          <div class="row" style="gap:8px; align-items:center;">
            <label style="display:flex; flex-direction:column; gap:4px; flex:1;">
              <span style="font-size:12px; color:var(--muted);">Login</span>
              <input id="acctLogin" type="text" inputmode="numeric" placeholder="e.g., 68257735" />
            </label>
          </div>
          <div class="row" style="gap:8px; align-items:center; margin-top:8px;">
            <label style="display:flex; flex-direction:column; gap:4px; flex:1;">
              <span style="font-size:12px; color:var(--muted);">Server</span>
              <input id="acctServer" type="text" placeholder="e.g., RoboForex-Pro" />
            </label>
          </div>
          <div class="row" style="gap:8px; align-items:center; margin-top:8px;">
            <label style="display:flex; flex-direction:column; gap:4px; flex:1;">
              <span style="font-size:12px; color:var(--muted);">Password</span>
              <input id="acctPassword" type="text" placeholder="Account password" />
            </label>
          </div>
          <div class="row" style="gap:8px; margin-top:10px;">
            <button class="btn" id="btnAcctSave" style="padding:6px 10px;">Save</button>
            <button class="btn secondary" id="btnAcctDelete" style="padding:6px 10px;">Delete</button>
            <button class="btn secondary" id="btnAcctCancel" style="padding:6px 10px;">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Signal Trade History Modal -->
    <div id="signalHistoryModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal-box" style="width:min(720px,94vw); max-height:86vh; overflow:auto;">
        <div class="modal-head">
          <h3>Signal Trade History</h3>
          <button id="btnSignalHistoryClose" class="modal-close" aria-label="Close">×</button>
        </div>
        <div class="modal-body" style="padding:12px;">
          <div id="signalHistoryInfo" style="color:var(--muted); font-size:13px; margin-bottom:6px;"></div>
          <div id="signalHistoryList" style="border:1px solid var(--line); border-radius:8px; background:var(--panel); padding:8px; max-height:300px; overflow:auto;"></div>
          <div class="row" style="gap:8px; margin-top:8px;">
            <button class="btn secondary" id="btnSignalHistoryMore" style="padding:6px 10px;">More</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Affiliate floating widgets -->
    <div id="rfBottomBanner" class="rf-floating rf-bottom rf-hidden" style="width:728px; height:90px;"
      data-rf-type="img"
      data-rf-src="https://my.roboforex.com/files/banners/88_en_rbfx_728x90__4947e7b6af364ea64a0f748b2a63fa14.jpg"
      data-rf-width="728"
      data-rf-height="90"
      data-rf-placeholder="RoboForex banner disabled.">
      <div class="rf-head">
        <button class="rf-btn" id="rfBottomBannerClose" title="Hide">×</button>
      </div>
      <a id="rfBottomBannerLink" href="https://roboforex.com/?utm_source=domain&amp;utm_medium=affbanerimg&amp;utm_content=size728_90&amp;utm_campaign=affunlimited_choice&amp;a=efx" target="_blank" rel="noopener noreferrer sponsored">
      </a>
    </div>

    

    

    <script>
      const el = (id) => document.getElementById(id);
      const esc = (s) => String(s ?? '').replace(/[&<>"']/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
      let DEBUG_LOGS = false;
      try {
        if (window.DEBUG_LOGS === true) {
          DEBUG_LOGS = true;
        } else if (typeof localStorage !== 'undefined' && localStorage.getItem('debugLogs') === '1') {
          DEBUG_LOGS = true;
        }
      } catch (_) {
        DEBUG_LOGS = false;
      }
      const debugLog = (...args) => { if (DEBUG_LOGS) console.log(...args); };
      const debugWarn = (...args) => { if (DEBUG_LOGS) console.warn(...args); };
      const status = (msg) => {
        el('status').textContent = msg || '';
        if (msg && DEBUG_LOGS) console.log('[App]', msg);
      };
      // Update top signal UI (dot color and Trade button)
      let lastSignal = 'hold';
      function updateSignalUI(sig, reason) {
        lastSignal = sig || 'hold';
        const dot = document.getElementById('signalDot');
        const txt = document.getElementById('signalText');
        const btn = document.getElementById('btnTradeSignalTop');
        let color = '#999';
        if (lastSignal === 'buy') color = getComputedStyle(document.documentElement).getPropertyValue('--buy').trim() || '#2ecc71';
        if (lastSignal === 'sell') color = getComputedStyle(document.documentElement).getPropertyValue('--sell').trim() || '#e74c3c';
        if (dot) dot.style.background = color;
        if (btn) btn.disabled = !(lastSignal === 'buy' || lastSignal === 'sell');
        if (txt) txt.textContent = `Signal: ${lastSignal.toUpperCase()}` + (reason ? ` (${reason})` : '');
        lastSignalReason = reason || '';
        if (reason && DEBUG_LOGS) console.log('[Strategy]', lastSignal, reason);
      }

      // Read config from data-attributes (CSV → array)
      const cfgNode = document.getElementById('app-cfg');
      const _csv = cfgNode ? (cfgNode.getAttribute('data-symbols') || '') : '';
      const _def = cfgNode ? (cfgNode.getAttribute('data-default') || '') : '';
      const NEWS_AI_AVAILABLE = cfgNode ? (cfgNode.getAttribute('data-ai') === '1') : false;
      const APP_SYMBOLS = _csv ? _csv.split(',').map(s => s.trim()).filter(Boolean) : ['XAUUSD'];
      const APP_DEFAULT_SYMBOL = _def || (APP_SYMBOLS.length ? APP_SYMBOLS[0] : 'XAUUSD');
      debugLog('[App] Config symbols/default:', APP_SYMBOLS, APP_DEFAULT_SYMBOL);
      const DEFAULT_TF = "{{ default_tf }}";
      const DEFAULT_BARS = Number("{{ default_count }}") || 500;
      const DEFAULT_STL_AUTO_PERIOD = "{{ default_stl_auto_period }}";
      const DEFAULT_STL_MANUAL_PERIOD = Number("{{ default_stl_manual_period }}") || 30;
      const DEFAULT_CHART_SHIFT = "{{ default_chart_shift }}";
      const ALL_TFS = ['M1','M5','M15','M30','H1','H4','D1','W1','MN1','Y1'];
      const DEFAULT_TECH_WINDOW = 7;
      const TF_SECONDS = {
        M1: 60,
        M5: 300,
        M15: 900,
        M30: 1800,
        H1: 3600,
        H4: 14400,
        D1: 86400,
        W1: 604800,
        MN1: 2629746,
        Y1: 31556952,
      };
      const techHealthBarsInput = el('techHealthBars');
      const chartShiftInput = el('chkChartShift');
      let chartShiftOn = (DEFAULT_CHART_SHIFT !== '0');
      const getRightOffset = () => (chartShiftOn ? 20 : 0);
      const healthStrategySelect = el('healthStrategy');

      // Strong client-side memory for last selection (fallback if DB prefs are stale)
      const isValidSymbol = (s) => APP_SYMBOLS.includes(String(s || '').toUpperCase());
      const isValidTf = (tf) => ALL_TFS.includes(String(tf || '').toUpperCase());
      (function applyLocalSelectionFallback() {
        try {
          const lsSym = (localStorage.getItem('last_symbol') || '').toUpperCase();
          const lsTf = (localStorage.getItem('last_tf') || '').toUpperCase();
          const symSel = document.getElementById('symbol');
          const tfSel = document.getElementById('tf');
          if (symSel && isValidSymbol(lsSym)) { symSel.value = lsSym; }
          if (tfSel && isValidTf(lsTf)) { tfSel.value = lsTf; }
        } catch (_) { /* ignore */ }
      })();
      const HEALTH_STRATEGIES = [
        // FX
        { value: 'forex_pair_compact_10q_position.json', label: 'FX Comprehensive + Position (10)', kinds: ['forex_pair'] },
        { value: 'forex_pair_compact_10q.json', label: 'FX Comprehensive (10)', kinds: ['forex_pair'] },
        // Metals (kind=forex_pair)
        { value: 'metal_pair_compact_10q_position.json', label: 'Metals Comprehensive + Position (10)', kinds: ['forex_pair'] },
        { value: 'metal_pair_compact_10q.json', label: 'Metals Comprehensive (10)', kinds: ['forex_pair'] },
        // Stocks
        { value: 'stocks_compact_10q_position.json', label: 'Stocks Comprehensive + Position (10)', kinds: ['stock'] },
        { value: 'stocks_compact_10q.json', label: 'Stocks Comprehensive (10)', kinds: ['stock'] },
        // Intentionally exclude 'tech_snapshot_10q.json' from the Basic dropdown; it is used via Tech+AI
      ];
      let techHealthUserOverride = false;
      let healthStrategyUserOverride = false;
      const nextTimeframe = (tf) => {
        const idx = ALL_TFS.indexOf(tf);
        if (idx === -1 || idx >= ALL_TFS.length - 1) return null;
        return ALL_TFS[idx + 1];
      };
      const defaultTechWindow = (tf) => {
        const next = nextTimeframe(tf);
        const baseSeconds = TF_SECONDS[tf];
        const nextSeconds = next ? TF_SECONDS[next] : null;
        if (Number.isFinite(baseSeconds) && Number.isFinite(nextSeconds) && nextSeconds > baseSeconds) {
          const ratio = Math.round(nextSeconds / baseSeconds);
          if (Number.isFinite(ratio) && ratio > 0) return Math.max(ratio, 10);
        }
        return Math.max(DEFAULT_TECH_WINDOW, 10);
      };
      const applyTechWindowDefault = (force = false) => {
        if (!techHealthBarsInput) return;
        if (!force && techHealthUserOverride) return;
        const computed = defaultTechWindow(currentTf());
        techHealthUserOverride = false;
        techHealthBarsInput.value = String(computed);
      };
      const resolveTechWindow = () => {
        if (!techHealthBarsInput) return defaultTechWindow(currentTf());
        const raw = Number(techHealthBarsInput.value);
        if (Number.isFinite(raw) && raw > 0) {
          const clamped = Math.max(10, Math.min(500, Math.round(raw)));
          if (techHealthBarsInput.value !== String(clamped)) {
            techHealthBarsInput.value = String(clamped);
          }
          return clamped;
        }
        applyTechWindowDefault(true);
        return defaultTechWindow(currentTf());
      };
      if (healthStrategySelect) {
        healthStrategySelect.innerHTML = HEALTH_STRATEGIES
          .map((item) => `<option value="${item.value}">${esc(item.label)}</option>`)
          .join('');
      }
      const findStrategyMeta = (value) => HEALTH_STRATEGIES.find((item) => item.value === value);
      const defaultStrategyForKind = (kind) => {
        if (kind === 'forex_pair') {
          // Default to +Position variant
          const fxDefault = HEALTH_STRATEGIES.find((item) => item.value === 'forex_pair_compact_10q_position.json');
          if (fxDefault) return fxDefault;
        }
        return HEALTH_STRATEGIES.find((item) => item.kinds.includes(kind)) || HEALTH_STRATEGIES[0];
      };
      const isMetalPair = (sym) => {
        const s = (sym || '').toUpperCase();
        if (!/^[A-Z]{6,7}$/.test(s)) return false;
        const base = s.slice(0,3);
        return base === 'XAU' || base === 'XAG';
      };
      const ensureStrategyForKind = (kind) => {
        if (!healthStrategySelect) return;
        const currentValue = healthStrategySelect.value;
        const currentMeta = findStrategyMeta(currentValue);
        // Prefer metals template for XAU/XAG pairs when user hasn't chosen explicitly
        const sym = (typeof currentSymbol === 'function') ? currentSymbol() : (symbolSelect && symbolSelect.value) || '';
        const preferMetal = kind === 'forex_pair' && isMetalPair(sym);
        const desiredValue = preferMetal ? 'metal_pair_compact_10q_position.json' : (defaultStrategyForKind(kind)?.value);
        if (!healthStrategyUserOverride || !currentMeta || !currentMeta.kinds.includes(kind) || (preferMetal && currentValue !== desiredValue)) {
          if (desiredValue) {
            healthStrategyUserOverride = false;
            healthStrategySelect.value = desiredValue;
          }
        }
      };

      const DEFAULT_CHART_TYPE = "{{ default_chart_type }}";
      const symbolSelect = document.getElementById('symbol');
      const tfSelect = document.getElementById('tf');
      const countInput = document.getElementById('count');
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      const lwContainer = document.getElementById('lwChart');
      let curType = (DEFAULT_CHART_TYPE === 'line') ? 'line' : 'candlestick';
      let chart = null;
      let lastSignalReason = '';
      let lwChart = null;
      let lwLastTimes = [];
      let periodBoundaryTimes = [];
      let periodAnchorTime = null;
      let usePeriodGrid = false; // disable vertical grid; use markers instead
      let lwOverlayDpr = (window.devicePixelRatio || 1);
      let lwSeries = null;
      let lwBollingerUpper = null;
      let lwBollingerLower = null;
      let lwBollingerMid = null;
      let lwObserver = null;
      let lwTimeRangeSubscribed = false;
      let currentTimeRange = null;
      let currentLogicalRange = null;
      let stlTrendSeries = null;
      let stlSeasonSeries = null;
      let stlResidSeries = null;
      let stlLastMeta = null;
      let stlLastRows = [];
      let stlAllData = true;
      let stlPendingCompute = false;
      let stlDatasetRange = null;
      let stlSelectedRunId = null;
      let stlTargetStart = null;
      let stlTargetEnd = null;
      let stlLastPeriod = null;
      let stlTrendPoints = [];
      let stlSeasonPoints = [];
      let stlResidPoints = [];
      let stlSpeedPoints = [];
      let stlAccelPoints = [];
      const stlAllToggle = el('chkStlAllData');
      const stlAutoToggle = el('chkStlAutoPeriod');
      const stlPeriodInput = el('stlPeriodInput');
      const stlStartInput = el('stlStart');
      const stlEndInput = el('stlEnd');
      const stlRunsSelect = el('stlRuns');
      const stlDeleteBtn = el('btnStlDelete');
      const stlOverlayControls = el('stlOverlayControls');
      const STL_OVERLAY_TFS = ['M1','M5','M15','M30','H1','H4','D1','W1','MN1','Y1'];
      const STL_OVERLAY_COLORS = {
        M1: '#006064',
        M5: '#00838f',
        M15: '#7e57c2',
        M30: '#5e35b1',
        H1: '#1e88e5',
        H4: '#fb8c00',
        D1: '#43a047',
        W1: '#f4511e',
        MN1: '#6d4c41',
        Y1: '#8d6e63',
      };
      const stlOverlaySeries = new Map();
      const stlOverlayData = new Map();
      const stlOverlayInputs = new Map();
      const stlOverlayLoading = new Map();
      const stlOverlayPending = new Set();
      let stlAutoPeriod = !(DEFAULT_STL_AUTO_PERIOD === '0' || DEFAULT_STL_AUTO_PERIOD === 'false');
      let stlManualPeriod = DEFAULT_STL_MANUAL_PERIOD;
      const stlPeriodLinesToggle = el('chkStlPeriodLines');
      const stlDerivativeToggle = el('chkStlDerivative');
      const stlAccelerationToggle = el('chkStlAcceleration');
      let showPeriodLines = false;

      const volumeCanvas = document.getElementById('volChart');
      const rsiCanvas = document.getElementById('rsiChart');
      const macdCanvas = document.getElementById('macdChart');
      const volumeCtx = volumeCanvas ? volumeCanvas.getContext('2d') : null;
      const rsiCtx = rsiCanvas ? rsiCanvas.getContext('2d') : null;
      const macdCtx = macdCanvas ? macdCanvas.getContext('2d') : null;
      let volumeChart = null;
      let rsiChart = null;
      let macdChart = null;

      let lastPriceRows = [];

      let indicatorRangeMs = null;

      // Lightweight Charts indicator panes

      let lwVolChart = null, lwVolSeries = null;

      let lwRsiChart = null, lwRsiSeries = null;

      let lwMacdChart = null, lwMacdHist = null, lwMacdLine = null, lwMacdSignal = null;

      let lwAtrChart = null, lwAtrSeries = null;
      let lwAdxChart = null, lwAdxLine = null, lwAdxPlus = null, lwAdxMinus = null;

      let lwDerivChart = null, lwDerivSpeedSeries = null, lwDerivAccelSeries = null;

      // Overlay canvas for dashed period lines on the candlestick chart
      let lwOverlay = null, lwOverlayCtx = null;
      let chartPeriodWindows = [];

      let lwSyncing = false;
      let lwRangeTimer = null;
      let lwSubscriptionsEnabled = false;
      let lwVolSubscribed = false, lwRsiSubscribed = false, lwMacdSubscribed = false; // sync disabled
      let lwDerivSubscribed = false;
      let lwAtrSubscribed = false, lwAdxSubscribed = false;
      let lwVolHasData = false, lwRsiHasData = false, lwMacdHasData = false;
      let lwDerivHasSpeed = false, lwDerivHasAccel = false;

      // Cached indicators for chip computation
      let lastRsiValues = [];
      let lastMacdObj = { macd: [], signal: [], histogram: [] };
      let lastAtrValues = [];
      let lastAdxObj = { adx: [], plusDI: [], minusDI: [] };
      let lastVolumesArr = [];
      let indicatorSignals = {};

      const PREF_ENDPOINT = '/api/preferences';
      let prefQueue = {};
      let prefTimer = null;
      let chartRefreshTimer = null;
      
      let lwInitialFitted = false;

      const btnNews = el('btnNews');
      const btnNewsFull = el('btnNewsFull');
      const newsStatus = el('newsStatus');
      let newsRefreshTimer = null;
      let lastNewsUpdatedAt = null;
      const NEWS_BUTTON_DEFAULT = btnNews ? btnNews.textContent || 'Refresh News' : 'Refresh News';

      const setNewsStatus = (message, tone = 'info') => {
        if (!newsStatus) return;
        let color = 'var(--muted)';
        if (tone === 'ok') color = 'var(--accent)';
        if (tone === 'error') color = 'var(--sell)';
        if (tone === 'warn') color = '#fb8c00';
        newsStatus.style.color = color;
        newsStatus.textContent = message || '';
      };

      const currentSymbol = () => (symbolSelect && symbolSelect.value ? symbolSelect.value.trim().toUpperCase() : APP_DEFAULT_SYMBOL);
      const currentTf = () => (tfSelect && tfSelect.value ? tfSelect.value.trim().toUpperCase() : DEFAULT_TF);
      const currentBarsLimit = () => Math.max(10, Number(countInput && countInput.value ? countInput.value : DEFAULT_BARS) || DEFAULT_BARS);
      applyTechWindowDefault(true);
      ensureStrategyForKind(isFxPair(currentSymbol()) ? 'forex_pair' : 'stock');

      // Trade AI model preference
      const aiModelSelect = el('aiModelSelect');
      const getTradeAiModel = () => {
        const val = aiModelSelect && aiModelSelect.value ? aiModelSelect.value.trim() : '';
        return val || 'deepseek-chat';
      };
      if (aiModelSelect) {
        aiModelSelect.value = 'deepseek-chat';
        aiModelSelect.addEventListener('change', () => {
          const model = getTradeAiModel();
          try { queuePrefUpdate('trade_ai_model', model); } catch (e) {}
        });
        // Load saved preference (non-blocking)
        (async () => {
          try {
            const r = await fetch(`${PREF_ENDPOINT}?keys=trade_ai_model`, { cache: 'no-store' });
            const js = await r.json();
            const saved = js && js.prefs && js.prefs.trade_ai_model;
            if (saved && typeof saved === 'string') {
              aiModelSelect.value = saved;
            }
          } catch {}
        })();
      }

      const isoToLocalInput = (iso) => {
        if (!iso) return '';
        const date = new Date(iso);
        if (Number.isNaN(date.getTime())) return '';
        const pad = (v) => String(v).padStart(2, '0');
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      };

      const localInputToIso = (value) => {
        if (!value) return null;
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return null;
        return date.toISOString();
      };

      function updateStlInputsFromState() {
        if (stlAllToggle) stlAllToggle.checked = !!stlAllData;
        if (stlAutoToggle) stlAutoToggle.checked = !!stlAutoPeriod;
        if (stlPeriodInput) {
          stlPeriodInput.disabled = !!stlAutoPeriod;
          const effective = Number.isFinite(stlManualPeriod) && stlManualPeriod > 0 ? Math.round(stlManualPeriod) : DEFAULT_STL_MANUAL_PERIOD;
          stlPeriodInput.value = effective;
        }
        if (stlPeriodLinesToggle) stlPeriodLinesToggle.checked = !!showPeriodLines;
        const disableRange = !!stlAllData;
        if (stlStartInput) {
          stlStartInput.disabled = disableRange;
          stlStartInput.value = disableRange ? '' : (stlTargetStart ? isoToLocalInput(stlTargetStart) : stlStartInput.value);
        }
        if (stlEndInput) {
          stlEndInput.disabled = disableRange;
          stlEndInput.value = disableRange ? '' : (stlTargetEnd ? isoToLocalInput(stlTargetEnd) : stlEndInput.value);
        }
        if (stlRunsSelect && stlRunsSelect.options.length === 0) {
          stlRunsSelect.innerHTML = '<option value=\"\">Latest (auto)</option>';
        }
      if (stlDeleteBtn) stlDeleteBtn.disabled = !stlSelectedRunId;
      }

      const formatDateShort = (iso) => {
        if (!iso) return '';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return iso;
        return d.toISOString().slice(0, 10);
      };

      const formatDateTime = (iso) => {
        if (!iso) return '';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return iso;
        return d.toISOString().slice(0, 16).replace('T', ' ');
      };

      const formatEpochDateTime = (epochSec) => {
        if (!Number.isFinite(epochSec)) return '';
        const d = new Date(epochSec * 1000);
        if (Number.isNaN(d.getTime())) return '';
        return d.toISOString().slice(0, 16).replace('T', ' ');
      };

      const formatTechNumber = (value) => {
        if (!Number.isFinite(value)) return '—';
        const abs = Math.abs(value);
        if (abs >= 100000) return value.toFixed(0);
        if (abs >= 1000) return value.toFixed(2);
        if (abs >= 100) return value.toFixed(3);
        if (abs >= 1) return value.toFixed(4);
        if (abs >= 0.01) return value.toFixed(6);
        return value.toFixed(8);
      };

      // STL runs lazy list state
      let stlRunsAll = [];
      let stlRunsShown = 5;
      const stlRunsPageSize = 5;
      function renderStlRunsList(selectedId) {
        if (!stlRunsSelect) return;
        const ensureVisible = (id) => {
          if (!id) return;
          const idx = stlRunsAll.findIndex(r => String(r && r.id) === String(id));
          if (idx >= 0 && idx >= stlRunsShown) stlRunsShown = Math.min(stlRunsAll.length, Math.ceil((idx+1)/stlRunsPageSize)*stlRunsPageSize);
        };
        ensureVisible(selectedId);
        stlRunsSelect.innerHTML = '';
        stlRunsSelect.appendChild(new Option('Latest (auto)', ''));
        const slice = stlRunsAll.slice(0, stlRunsShown);
        slice.forEach((run) => {
          if (!run) return;
          const label = `${formatDateShort(run.start_ts)} → ${formatDateShort(run.end_ts)} • P${run.period}`;
          const opt = new Option(label, String(run.id));
          if (selectedId && String(run.id) === String(selectedId)) opt.selected = true;
          stlRunsSelect.appendChild(opt);
        });
        if (stlRunsAll.length > stlRunsShown) {
          const more = new Option('More…', '__more__');
          stlRunsSelect.appendChild(more);
        }
        if (!selectedId) stlRunsSelect.value = '';
        if (stlDeleteBtn) stlDeleteBtn.disabled = !stlRunsSelect.value || stlRunsSelect.value === '__more__';
      }
      function populateStlRuns(runs, selectedId) {
        stlRunsAll = Array.isArray(runs) ? runs.slice() : [];
        stlRunsShown = Math.min(stlRunsAll.length, stlRunsPageSize);
        renderStlRunsList(selectedId);
      }

      function updateIndicatorCharts(rows) {
        if (Array.isArray(rows) && rows.length) {
          lastPriceRows = rows.slice();
        } else {
          lastPriceRows = [];
        }
        if (currentTimeRange) {
          applyIndicatorViewport(currentTimeRange, currentLogicalRange);
        } else {
          indicatorRangeMs = null;
          updateIndicatorDisplay(lastPriceRows);
        }
        // Compute and cache indicator values for chips
        try {
          lastVolumesArr = rows.map((r) => {
            const cand = [r.real_volume, r.tick_volume, r.volume]
              .map((v) => Number(v))
              .filter((v) => Number.isFinite(v) && v > 0);
            return cand.length ? cand[0] : 0;
          });
          const closes = rows.map((r) => Number.isFinite(Number(r.close)) ? Number(r.close) : 0);
          lastRsiValues = computeRSI(closes) || [];
          lastMacdObj = computeMACD(closes) || { macd: [], signal: [], histogram: [] };
          // ATR/ADX
          ensureLwAtr();
          ensureLwAdx();
          const atrObj = computeAtrSeries(rows) || { atr: [], tr: [] };
          lastAtrValues = atrObj.atr || [];
          const adxObj = computeAdxSeries(rows, atrObj.tr) || { adx: [], plusDI: [], minusDI: [] };
          lastAdxObj = adxObj;
          if (lwAtrSeries) {
            const pts = rows.map((row, i) => ({ time: Math.floor(new Date(row.ts).getTime() / 1000), value: Number(lastAtrValues[i] || 0) }));
            lwAtrSeries.setData(pts.filter(p => Number.isFinite(p.value)));
          }
          if (lwAdxLine && lwAdxPlus && lwAdxMinus) {
            const toPts = (arr) => rows.map((row, i) => {
              const v = Number(arr[i]);
              return (Number.isFinite(v) ? { time: Math.floor(new Date(row.ts).getTime() / 1000), value: v } : null);
            }).filter(Boolean);
            lwAdxLine.setData(toPts(lastAdxObj.adx || []));
            lwAdxPlus.setData(toPts(lastAdxObj.plusDI || []));
            lwAdxMinus.setData(toPts(lastAdxObj.minusDI || []));
          }
          // Recompute signals and redraw chips
          computeIndicatorSignals();
          redrawPeriodLines();
        } catch (err) { /* ignore signal computation errors */ }
      }
      const flushPrefQueue = async () => {
        if (!Object.keys(prefQueue).length) {
          prefTimer = null;
          return;
        }
        const payload = prefQueue;
        prefQueue = {};
        prefTimer = null;
        try {
          await fetch(PREF_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            cache: 'no-store',
            body: JSON.stringify(payload),
          });
        } catch (err) {
          debugWarn('[App] Preference update failed', err);
        }
      };

      const queuePrefUpdate = (key, value) => {
        if (!key) return;
        prefQueue[key] = value ?? '';
        if (!prefTimer) {
          prefTimer = setTimeout(flushPrefQueue, 400);
        }
      };

      const scheduleChartRefresh = (reason) => {
        if (chartRefreshTimer) {
          clearTimeout(chartRefreshTimer);
        }
        chartRefreshTimer = setTimeout(async () => {
          chartRefreshTimer = null;
          try {
            debugLog('[App] Refreshing chart due to', reason);
            await refreshChart();
          } catch (err) {
            debugWarn('[App] Chart refresh failed for', reason, err);
          }
        }, 400);
      };

      const scheduleNewsRefresh = (reason) => {
        if (newsRefreshTimer) {
          clearTimeout(newsRefreshTimer);
        }
        newsRefreshTimer = setTimeout(async () => {
          newsRefreshTimer = null;
          try {
            debugLog('[App] Refreshing news due to', reason);
            await refreshNews({ reason, disableButton: false });
          } catch (err) {
            debugWarn('[App] News refresh failed for', reason, err);
          }
        }, 350);
      };

      const newsAnalysisCache = new Map();
      let healthState = { kind: null, offset: 0, strategy: null, group: null, excludeStrategy: null };
      const chartPeriodPluginId = 'periodOverlay';
      if (window.Chart && window.Chart.register && !window.__periodOverlayRegistered) {
        const periodOverlayPlugin = {
          id: chartPeriodPluginId,
          beforeDraw(chart) {
            if (!chartPeriodWindows.length) return;
            const { ctx, chartArea, scales } = chart;
            if (!chartArea || !scales || !scales.x) return;
            const xScale = scales.x;
            const { top, bottom } = chartArea;
            ctx.save();
            chartPeriodWindows.forEach((windowInfo, idx) => {
              const startPx = xScale.getPixelForValue(windowInfo.start.valueOf());
              const endPx = xScale.getPixelForValue(windowInfo.end.valueOf());
              if (!Number.isFinite(startPx) || !Number.isFinite(endPx) || endPx <= startPx) {
                return;
              }
              const shadeColor = idx % 2 === 0 ? 'rgba(216, 67, 21, 0.05)' : 'rgba(216, 67, 21, 0.12)';
              ctx.fillStyle = shadeColor;
              ctx.fillRect(startPx, top, endPx - startPx, bottom - top);
              ctx.strokeStyle = 'rgba(216, 67, 21, 0.4)';
              ctx.setLineDash([6, 6]);
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(startPx, top);
              ctx.lineTo(startPx, bottom);
              ctx.stroke();
              if (idx === chartPeriodWindows.length - 1) {
                ctx.beginPath();
                ctx.moveTo(endPx, top);
                ctx.lineTo(endPx, bottom);
                ctx.stroke();
              }
            });
            ctx.setLineDash([]);
            ctx.restore();
          },
        };
        window.Chart.register(periodOverlayPlugin);
        window.__periodOverlayRegistered = true;
      }

      const newsArticleKey = (article) => {
        if (!article) return '';
        return (
          article.url ||
          article.id ||
          article.article_id ||
          `${article.title || article.headline || ''}|${article.publishedAt || article.published_at || article.date || ''}`
        );
      };

      const computeEMA = (series, period) => {
        const ema = new Array(series.length).fill(null);
        if (!Array.isArray(series) || series.length === 0) return ema;
        const multiplier = 2 / (period + 1);
        let sum = 0;
        let count = 0;
        let firstIdx = -1;
        for (let i = 0; i < series.length; i++) {
          const value = series[i];
          if (value == null) {
            continue;
          }
          if (firstIdx === -1) {
            firstIdx = i;
          }
          sum += value;
          count += 1;
          if (count === period) {
            const avg = sum / period;
            ema[i] = avg;
            let prev = avg;
            for (let j = i + 1; j < series.length; j++) {
              const nextVal = series[j];
              if (nextVal == null) {
                ema[j] = null;
                continue;
              }
              prev = ((nextVal - prev) * multiplier) + prev;
              ema[j] = prev;
            }
            break;
          }
        }
        return ema;
      };

      const computeRSI = (values, period = 14) => {
        const result = new Array(values.length).fill(null);
        if (!Array.isArray(values) || values.length <= period) return result;
        let gains = 0;
        let losses = 0;
        for (let i = 1; i <= period; i++) {
          const delta = values[i] - values[i - 1];
          if (delta >= 0) {
            gains += delta;
          } else {
            losses += Math.abs(delta);
          }
        }
        let avgGain = gains / period;
        let avgLoss = losses / period;
        result[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
        for (let i = period + 1; i < values.length; i++) {
          const delta = values[i] - values[i - 1];
          const gain = delta > 0 ? delta : 0;
          const loss = delta < 0 ? Math.abs(delta) : 0;
          avgGain = ((avgGain * (period - 1)) + gain) / period;
          avgLoss = ((avgLoss * (period - 1)) + loss) / period;
          if (avgLoss === 0) {
            result[i] = 100;
          } else {
            const rs = avgGain / avgLoss;
            result[i] = 100 - (100 / (1 + rs));
          }
        }
        return result;
      };

      const computeMACD = (values, fast = 12, slow = 26, signal = 9) => {
        const macdLine = new Array(values.length).fill(null);
        const signalLine = new Array(values.length).fill(null);
        const histogram = new Array(values.length).fill(null);
        if (!Array.isArray(values) || values.length === 0) {
          return { macd: macdLine, signal: signalLine, histogram };
        }
        const fastEma = computeEMA(values, fast);
        const slowEma = computeEMA(values, slow);
        for (let i = 0; i < values.length; i++) {
          const fastVal = fastEma[i];
          const slowVal = slowEma[i];
          if (fastVal != null && slowVal != null) {
            macdLine[i] = fastVal - slowVal;
          }
        }
        const signalEma = computeEMA(macdLine, signal);
        for (let i = 0; i < values.length; i++) {
          const sigVal = signalEma[i];
          if (sigVal != null) {
            signalLine[i] = sigVal;
          }
          const macdVal = macdLine[i];
          if (macdVal != null && sigVal != null) {
            histogram[i] = macdVal - sigVal;
          }
        }
        return { macd: macdLine, signal: signalLine, histogram };
      };

      const computeTrueRangeSeries = (rows) => {
        if (!Array.isArray(rows)) return [];
        const out = new Array(rows.length).fill(null);
        for (let i = 0; i < rows.length; i += 1) {
          const high = Number(rows[i]?.high);
          const low = Number(rows[i]?.low);
          if (!Number.isFinite(high) || !Number.isFinite(low)) {
            out[i] = null;
            continue;
          }
          const base = Math.abs(high - low);
          if (i === 0) {
            out[i] = base;
            continue;
          }
          const prevClose = Number(rows[i - 1]?.close);
          if (!Number.isFinite(prevClose)) {
            out[i] = base;
            continue;
          }
          const range2 = Math.abs(high - prevClose);
          const range3 = Math.abs(low - prevClose);
          out[i] = Math.max(base, range2, range3);
        }
        return out;
      };

      const computeAtrSeries = (rows, period = 14) => {
        const tr = computeTrueRangeSeries(rows);
        const atr = new Array(tr.length).fill(null);
        if (!tr.length) return { atr, tr };
        let sum = 0;
        for (let i = 0; i < tr.length; i += 1) {
          const value = Number(tr[i]);
          sum += Number.isFinite(value) ? value : 0;
          if (i >= period) {
            const drop = Number(tr[i - period]);
            sum -= Number.isFinite(drop) ? drop : 0;
          }
          if (i >= period - 1) {
            const denom = Math.min(period, i + 1);
            atr[i] = denom > 0 ? sum / denom : null;
          }
        }
        return { atr, tr };
      };

      const computeAdxSeries = (rows, trSeries, period = 14) => {
        const len = Array.isArray(rows) ? rows.length : 0;
        const adx = new Array(len).fill(null);
        const plusDI = new Array(len).fill(null);
        const minusDI = new Array(len).fill(null);
        if (!len) return { adx, plusDI, minusDI };
        const plusDM = new Array(len).fill(0);
        const minusDM = new Array(len).fill(0);
        for (let i = 1; i < len; i += 1) {
          const high = Number(rows[i]?.high);
          const low = Number(rows[i]?.low);
          const prevHigh = Number(rows[i - 1]?.high);
          const prevLow = Number(rows[i - 1]?.low);
          if (!Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(prevHigh) || !Number.isFinite(prevLow)) {
            plusDM[i] = 0;
            minusDM[i] = 0;
            continue;
          }
          const upMove = high - prevHigh;
          const downMove = prevLow - low;
          plusDM[i] = (upMove > downMove && upMove > 0) ? upMove : 0;
          minusDM[i] = (downMove > upMove && downMove > 0) ? downMove : 0;
        }
        let sumTR = 0;
        let sumPlus = 0;
        let sumMinus = 0;
        const dxWindow = [];
        let dxSum = 0;
        for (let i = 0; i < len; i += 1) {
          const trVal = Number(trSeries?.[i]);
          const plusVal = plusDM[i] || 0;
          const minusVal = minusDM[i] || 0;
          sumTR += Number.isFinite(trVal) ? trVal : 0;
          sumPlus += plusVal;
          sumMinus += minusVal;
          if (i >= period) {
            const oldTr = Number(trSeries?.[i - period]);
            sumTR -= Number.isFinite(oldTr) ? oldTr : 0;
            sumPlus -= plusDM[i - period] || 0;
            sumMinus -= minusDM[i - period] || 0;
          }
          if (i >= period - 1 && sumTR > 0) {
            const plusPct = (sumPlus / sumTR) * 100;
            const minusPct = (sumMinus / sumTR) * 100;
            plusDI[i] = plusPct;
            minusDI[i] = minusPct;
            const denom = plusPct + minusPct;
            const dx = denom === 0 ? 0 : (Math.abs(plusPct - minusPct) / denom) * 100;
            dxWindow.push(dx);
            dxSum += dx;
            if (dxWindow.length > period) {
              dxSum -= dxWindow.shift();
            }
            adx[i] = dxWindow.length ? dxSum / dxWindow.length : dx;
          }
        }
        return { adx, plusDI, minusDI };
      };

      const computeBollingerBands = (values, period = 20, stdMultiplier = 2) => {
        const upper = new Array(values.length).fill(null);
        const lower = new Array(values.length).fill(null);
        const middle = new Array(values.length).fill(null);
        if (!Array.isArray(values) || values.length < period) {
          return { upper, lower, middle };
        }
        const window = [];
        for (let i = 0; i < values.length; i++) {
          const val = values[i];
          if (val == null) {
            window.length = 0;
            continue;
          }
          window.push(val);
          if (window.length > period) {
            window.shift();
          }
          if (window.length === period) {
            const mean = window.reduce((acc, v) => acc + v, 0) / period;
            const variance = window.reduce((acc, v) => acc + (v - mean) ** 2, 0) / period;
            const std = Math.sqrt(variance);
            middle[i] = mean;
            upper[i] = mean + stdMultiplier * std;
            lower[i] = mean - stdMultiplier * std;
          }
        }
        return { upper, lower, middle };
      };

      const ensureVolumeChart = () => {
        if (volumeChart || !volumeCtx) return;
        volumeChart = new window.Chart(volumeCtx, {
          type: 'bar',
          parsing: false,
          data: {
            labels: [],
            datasets: [
              {
                label: 'Volume',
                data: [],
                backgroundColor: 'rgba(25, 118, 210, 0.35)',
                borderWidth: 0,
                barPercentage: 1.0,
                categoryPercentage: 1.0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                type: 'time',
                time: { tooltipFormat: 'MMM d HH:mm' },
                bounds: 'ticks',
                offset: false,
                ticks: { maxRotation: 0, autoSkip: true },
                grid: { display: false },
              },
              y: {
                position: 'right',
                beginAtZero: true,
                title: { display: false },
                grid: { color: '#e0e6ef' },
              },
            },
          },
        });
      };

      const ensureRsiChart = () => {
        if (rsiChart || !rsiCtx) return;
        rsiChart = new window.Chart(rsiCtx, {
          type: 'line',
          parsing: false,
          data: {
            labels: [],
            datasets: [
              {
                label: 'RSI',
                data: [],
                borderColor: '#8e24aa',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.15,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            interaction: { intersect: false, mode: 'index' },
            scales: {
              x: {
                type: 'time',
                time: { tooltipFormat: 'MMM d HH:mm' },
                bounds: 'ticks',
                offset: false,
                ticks: { maxRotation: 0, autoSkip: true },
                grid: { display: false },
              },
              y: {
                position: 'right',
                min: 0,
                max: 100,
                ticks: { stepSize: 20 },
                grid: { color: '#e0e6ef' },
              },
            },
          },
        });
      };

      const ensureLwVol = () => {
        if (!lwVolChart) {
          const elVol = document.getElementById('lwVol');
          if (!elVol) return;
          lwVolChart = LightweightCharts.createChart(elVol, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwVolSeries && lwVolChart) {
          lwVolSeries = lwVolChart.addHistogramSeries({
            base: 0,
            priceFormat: { type: 'volume' },
            color: 'rgba(120, 144, 156, 0.4)',
          });
        }
        if (!lwVolSubscribed && lwVolChart) {
          lwVolChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwVolChart);
          });
          lwVolSubscribed = true;
        }
      };

      // Account Balance and PnL (Chart.js, decoupled from LW)
      let balanceChart = null;
      let pnlChart = null;
      let fetchingBalance = false;
      let fetchingClosed = false;
      const ensureBalanceChart = () => {
        if (balanceChart) return true;
        const canvas = document.getElementById('balanceChartCanvas');
        if (!canvas) return false;
        const ctx = canvas.getContext('2d');
        balanceChart = new window.Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              { label: 'Balance', data: [], borderColor: '#1b5e20', borderWidth: 1.4, pointRadius: 0, tension: 0.1, yAxisID: 'y' },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: true } },
            interaction: { intersect: false, mode: 'index' },
            parsing: false,
            scales: {
              x: { type: 'time', time: { tooltipFormat: 'MMM d HH:mm' }, ticks: { maxRotation: 0, autoSkip: true }, grid: { display: false } },
              y: { position: 'left', grid: { color: '#e0e6ef' } },
            },
          },
        });
        return true;
      };

      const ensurePnlChart = () => {
        if (pnlChart) return true;
        const canvas = document.getElementById('pnlChartCanvas');
        if (!canvas) return false;
        const ctx = canvas.getContext('2d');
        pnlChart = new window.Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              { label: 'Closed PnL (cum)', data: [], borderColor: '#ff9800', borderWidth: 1.6, pointRadius: 2, pointHoverRadius: 3, tension: 0.1 },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: true } },
            interaction: { intersect: false, mode: 'nearest' },
            parsing: false,
            scales: {
              x: { type: 'linear', ticks: { stepSize: 1 }, grid: { display: false } },
              y: { position: 'left', grid: { color: '#e0e6ef' } },
            },
            elements: { line: { stepped: false }, point: { radius: 2 } },
          },
        });
        return true;
      };

      async function refreshBalanceSeries() {
        if (fetchingBalance) return; fetchingBalance = true;
        try {
          await ensureSelectedAccountSession?.();
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : '';
          const url = acct
            ? `/api/account/balance_series?user=lachlan&limit=1000&daily=1&account=${encodeURIComponent(acct)}`
            : '/api/account/balance_series?user=lachlan&limit=1000&daily=1';
          const r = await fetch(url, { cache: 'no-store' });
          const js = await r.json().catch(()=>({}));
          try {
            console.log('[PnL] auto refresh deals=', (js.deals||[]).length, 'cum=', (js.cum||[]).length);
            const deals = Array.isArray(js.deals) ? js.deals : [];
            const samp = deals.slice(-10).map(d => ({ ts: d.ts, sym: d.symbol, profit: Number(d.profit||0) }));
            console.log('[PnL] auto deals sample (last 10)=', samp);
          } catch {}
          if (!r.ok || !js || js.ok !== true) return;
          if (!ensureBalanceChart()) return;
          const points = (js.rows || [])
            .map(row => {
              const t = Date.parse(row.ts);
              const v = Number(row.balance);
              if (!Number.isFinite(t) || !Number.isFinite(v)) return null;
              return { x: t, y: v };
            })
            .filter(Boolean);
          balanceChart.data.datasets[0].data = points;
          balanceChart.update('none');
        } catch (e) {
          // swallow UI errors
        } finally { fetchingBalance = false; }
      }

      async function refreshClosedDealsSeries() {
        if (fetchingClosed) return; fetchingClosed = true;
        const btn = document.getElementById('btnFetchClosed');
        const prev = btn ? btn.textContent : '';
        if (btn) { btn.disabled = true; btn.textContent = 'Fetching…'; }
        try {
          // Use auto source for refresh; ensure selected account session so server resolves correct account_id
          await ensureSelectedAccountSession?.();
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : '';
          let url = '/api/account/closed_deals?days=5000&source=auto&debug=1&nonzero=1';
          if (acct) url += `&account=${encodeURIComponent(acct)}`;
          const r = await fetch(url, { cache: 'no-store' });
          const js = await r.json().catch(()=>({}));
          if (!ensurePnlChart()) return;
          // Recompute cumulative on the client too, to cross-check any server-side filtering/mismatch.
          let deals = Array.isArray(js.deals) ? js.deals.slice() : [];
          // Apply the same nonzero filter on the client side (skip p+c+s == 0)
          deals = deals.filter(d => {
            const p = Number(d.profit||0), c = Number(d.commission||0), s = Number(d.swap||0);
            return Math.abs(p + c + s) > 1e-12;
          });
          // Sort by timestamp just in case
          deals.sort((a,b) => (Date.parse(a.ts||0) - Date.parse(b.ts||0)));
          let cumFromDeals = [];
          {
            let acc = 0;
            for (const d of deals) {
              const p = Number(d.profit||0), c = Number(d.commission||0), s = Number(d.swap||0);
              if (Number.isFinite(p) && Number.isFinite(c) && Number.isFinite(s)) acc += (p+c+s);
              cumFromDeals.push({ ts: d.ts, value: acc });
            }
          }
          const cumServer = Array.isArray(js.cum) ? js.cum : [];
          const useCum = (cumServer.length >= cumFromDeals.length ? cumServer : cumFromDeals);
          const cum = useCum
            .map((row, i) => {
              const v = Number(row.value ?? 0);
              if (!Number.isFinite(v)) return null;
              return { x: i + 1, y: v };
            })
            .filter(Boolean);
          try {
            const headDeals = deals.slice(0, 4).map(d => ({ ts: d.ts, sym: d.symbol, profit: Number(d.profit||0) }));
            const tailDeals = deals.slice(-4).map(d => ({ ts: d.ts, sym: d.symbol, profit: Number(d.profit||0) }));
            const headCum = useCum.slice(0, 4).map(c => ({ ts: c.ts, v: Number(c.value||0) }));
            const tailCum = useCum.slice(-4).map(c => ({ ts: c.ts, v: Number(c.value||0) }));
            console.log('[PnL] acct=', acct || '(session)', 'deals=', deals.length, 'cum(server)=', cumServer.length, 'cum(recomp)=', cumFromDeals.length);
            console.log('[PnL] deals head=', headDeals, 'tail=', tailDeals);
            console.log('[PnL] cum head=', headCum, 'tail=', tailCum);
          } catch {}
          pnlChart.data.datasets[0].data = cum;
          try { console.log('[PnL] chart dataset points=', pnlChart.data.datasets[0].data.length); } catch {}
          try { status(`PnL updated: ${cum.length} pts${acct ? ` (acct ${acct})` : ''}`); } catch {}
          pnlChart.update('none');
        } catch (e) {
          // swallow UI errors
        } finally {
          if (btn) { btn.disabled = false; btn.textContent = prev || 'Fetch Closed'; }
          fetchingClosed = false;
        }
      }

      const ensureLwDeriv = () => {
        if (!lwDerivChart) {
          const elDeriv = document.getElementById('lwDeriv');
          if (!elDeriv) return;
          lwDerivChart = LightweightCharts.createChart(elDeriv, {
            rightPriceScale: { visible: true, scaleMargins: { top: 0.2, bottom: 0.2 } },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (lwDerivChart && !lwDerivSpeedSeries) {
          const dashed = (LightweightCharts && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dashed !== undefined)
            ? LightweightCharts.LineStyle.Dashed
            : (LightweightCharts && LightweightCharts.LineStyle ? LightweightCharts.LineStyle.Solid : 2);
          lwDerivSpeedSeries = lwDerivChart.addLineSeries({
            color: '#d84315',
            lineWidth: 2,
            lineStyle: dashed,
          });
        }
        if (lwDerivChart && !lwDerivAccelSeries) {
          const dotted = (LightweightCharts && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dotted !== undefined)
            ? LightweightCharts.LineStyle.Dotted
            : (LightweightCharts && LightweightCharts.LineStyle ? LightweightCharts.LineStyle.Solid : 3);
          lwDerivAccelSeries = lwDerivChart.addLineSeries({
            color: '#8e24aa',
            lineWidth: 1.5,
            lineStyle: dotted,
          });
        }
        if (!lwDerivSubscribed && lwDerivChart) {
          lwDerivChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwDerivChart);
          });
          lwDerivSubscribed = true;
        }
      };

      const ensureLwRsi = () => {
        if (!lwRsiChart) {
          const elRsi = document.getElementById('lwRsi');
          if (!elRsi) return;
          lwRsiChart = LightweightCharts.createChart(elRsi, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwRsiSeries && lwRsiChart) {
          lwRsiSeries = lwRsiChart.addLineSeries({ color: '#8e24aa', lineWidth: 2 });
        }
        if (!lwRsiSubscribed && lwRsiChart) {
          lwRsiChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwRsiChart);
          });
          lwRsiSubscribed = true;
        }
      };

const ensureLwMacd = () => {
  if (!lwMacdChart) {
          const elMacd = document.getElementById('lwMacd');
          if (!elMacd) return;
          lwMacdChart = LightweightCharts.createChart(elMacd, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (lwMacdChart && !lwMacdHist) {
          lwMacdHist = lwMacdChart.addHistogramSeries({ base: 0 });
        }
        if (lwMacdChart && !lwMacdLine) {
          lwMacdLine = lwMacdChart.addLineSeries({ color: '#1b9aaa', lineWidth: 2 });
        }
        if (lwMacdChart && !lwMacdSignal) {
          lwMacdSignal = lwMacdChart.addLineSeries({ color: '#ef6c00', lineWidth: 2 });
        }
        if (!lwMacdSubscribed && lwMacdChart) {
          lwMacdChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwMacdChart);
          });
          lwMacdSubscribed = true;
  }
};

      const ensureLwAtr = () => {
        if (!lwAtrChart) {
          const el = document.getElementById('lwAtr');
          if (!el) return;
          lwAtrChart = LightweightCharts.createChart(el, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwAtrSeries && lwAtrChart) {
          lwAtrSeries = lwAtrChart.addLineSeries({ color: '#455a64', lineWidth: 2 });
        }
        if (!lwAtrSubscribed && lwAtrChart) {
          lwAtrChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwAtrChart);
          });
          lwAtrSubscribed = true;
        }
      };

      const ensureLwAdx = () => {
        if (!lwAdxChart) {
          const el = document.getElementById('lwAdx');
          if (!el) return;
          lwAdxChart = LightweightCharts.createChart(el, {
            rightPriceScale: { visible: true },
            leftPriceScale: { visible: false },
            timeScale: { rightOffset: getRightOffset(), fixRightEdge: false },
            grid: { vertLines: { color: '#efefef' }, horzLines: { color: '#efefef' } },
          });
        }
        if (!lwAdxLine && lwAdxChart) {
          lwAdxLine = lwAdxChart.addLineSeries({ color: '#1976d2', lineWidth: 2 });
        }
        if (!lwAdxPlus && lwAdxChart) {
          lwAdxPlus = lwAdxChart.addLineSeries({ color: '#2ecc71', lineWidth: 1.5 });
        }
        if (!lwAdxMinus && lwAdxChart) {
          lwAdxMinus = lwAdxChart.addLineSeries({ color: '#e74c3c', lineWidth: 1.5 });
        }
        if (!lwAdxSubscribed && lwAdxChart) {
          lwAdxChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            handleChartRangeChange(lwAdxChart);
          });
          lwAdxSubscribed = true;
        }
      };

      function updateStlDerivativeSeries() {
        ensureLwDeriv();
        const showSpeed = !stlDerivativeToggle || !!stlDerivativeToggle.checked;
        const showAccel = !stlAccelerationToggle || !!stlAccelerationToggle.checked;
        if (lwDerivSpeedSeries) {
          lwDerivSpeedSeries.setData(showSpeed ? stlSpeedPoints : []);
        }
        if (lwDerivAccelSeries) {
          lwDerivAccelSeries.setData(showAccel ? stlAccelPoints : []);
        }
        const combinedValues = [];
        if (showSpeed) {
          stlSpeedPoints.forEach((pt) => combinedValues.push(Number(pt.value) || 0));
        }
        if (showAccel) {
          stlAccelPoints.forEach((pt) => combinedValues.push(Number(pt.value) || 0));
        }
        const maxAbs = combinedValues.reduce((acc, val) => Math.max(acc, Math.abs(val)), 0);
        const range = maxAbs > 0 ? maxAbs * 1.05 : 1;
        const provider = () => ({ priceRange: { minValue: -range, maxValue: range } });
        if (lwDerivSpeedSeries && typeof lwDerivSpeedSeries.setAutoscaleInfoProvider === 'function') {
          lwDerivSpeedSeries.setAutoscaleInfoProvider(provider);
        }
        if (lwDerivAccelSeries && typeof lwDerivAccelSeries.setAutoscaleInfoProvider === 'function') {
          lwDerivAccelSeries.setAutoscaleInfoProvider(provider);
        }
        if (lwDerivChart) {
          lwDerivChart.priceScale('right').applyOptions({ scaleMargins: { top: 0.2, bottom: 0.2 } });
        }
        lwDerivHasSpeed = showSpeed && stlSpeedPoints.length > 0;
        lwDerivHasAccel = showAccel && stlAccelPoints.length > 0;
      }

      const ensureLwOverlay = () => {
        if (!lwContainer) return;
        if (!lwOverlay) {
          lwOverlay = document.createElement('canvas');
          lwOverlay.id = 'lwOverlay';
          lwOverlay.className = 'lw-overlay';
          lwContainer.appendChild(lwOverlay);
          lwOverlayCtx = lwOverlay.getContext('2d');
        }
        resizeLwOverlay();
      };

      const resizeLwOverlay = () => {
        if (!lwOverlay || !lwContainer) return;
        const rect = lwContainer.getBoundingClientRect();
        const cssW = Math.max(1, Math.floor(rect.width || lwContainer.clientWidth || 0));
        const cssH = Math.max(1, Math.floor(rect.height || lwContainer.clientHeight || 0));
        const dpr = (window.devicePixelRatio || 1);
        lwOverlayDpr = dpr;
        // Size internal buffer by DPR for crisp alignment
        const bufW = Math.max(1, Math.floor(cssW * dpr));
        const bufH = Math.max(1, Math.floor(cssH * dpr));
        if (lwOverlay.width !== bufW) lwOverlay.width = bufW;
        if (lwOverlay.height !== bufH) lwOverlay.height = bufH;
        // Ensure CSS size matches container
        lwOverlay.style.width = cssW + 'px';
        lwOverlay.style.height = cssH + 'px';
        if (lwOverlayCtx) {
          // Reset and scale to CSS pixel space
          lwOverlayCtx.setTransform(1, 0, 0, 1, 0, 0);
          lwOverlayCtx.clearRect(0, 0, bufW, bufH);
          lwOverlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        redrawPeriodLines();
      };

      const clearLwOverlay = () => {
        if (!lwOverlayCtx || !lwOverlay) return;
        lwOverlayCtx.clearRect(0, 0, lwOverlay.width, lwOverlay.height);
      };

      const drawLwPeriodLines = (period) => {
        if (!showPeriodLines || !usePeriodGrid || !lwChart || !lwOverlayCtx || !lastPriceRows.length || !period || period < 1) {
          clearLwOverlay();
          // Still draw chips even when lines disabled
          drawSignalChips();
          return;
        }
        const vis = lwChart.timeScale().getVisibleRange();
        if (!vis || vis.from == null || vis.to == null) {
          clearLwOverlay();
          return;
        }
        const fromSec = vis.from;
        const toSec = vis.to;
        const cssH = Math.max(1, Math.floor(lwContainer.clientHeight || lwOverlay.clientHeight || 0));
        const ctx = lwOverlayCtx;
        // Clear in CSS pixel space
        ctx.save();
        ctx.setTransform(lwOverlayDpr, 0, 0, lwOverlayDpr, 0, 0);
        ctx.clearRect(0, 0, lwOverlay.width / lwOverlayDpr, lwOverlay.height / lwOverlayDpr);
        ctx.save();
        ctx.strokeStyle = 'rgba(216, 67, 21, 0.6)';
        ctx.setLineDash([6, 5]);
        ctx.lineWidth = 1;
        // Use precomputed boundary times anchored to a specific bar time
        const times = Array.isArray(periodBoundaryTimes) ? periodBoundaryTimes : [];
        for (const tSec of times) {
          if (tSec < fromSec - period * 60 || tSec > toSec + period * 60) continue;
          const x = lwChart.timeScale().timeToCoordinate(tSec);
          if (x == null || !Number.isFinite(x)) continue;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cssH);
          ctx.stroke();
        }
        ctx.restore();
        ctx.restore();
        // Draw chips after period lines
        drawSignalChips();
      };

      const redrawPeriodLines = () => {
        const p = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
        drawLwPeriodLines(Number.isFinite(p) ? p : null);
      };

      function computeIndicatorSignals() {
        const latestIdx = lastPriceRows.length - 1;
        if (latestIdx < 0) { indicatorSignals = {}; return; }
        const lastRow = lastPriceRows[latestIdx] || {};
        const closes = lastPriceRows.map(r => Number(r.close) || 0);
        const upCandle = Number(lastRow.close) >= Number(lastRow.open);
        // Helper: SMA
        const sma = (arr, n) => {
          const out = new Array(arr.length).fill(null);
          let sum = 0;
          for (let i=0;i<arr.length;i++) {
            sum += arr[i];
            if (i>=n) sum -= arr[i-n];
            if (i>=n-1) out[i] = sum / n;
          }
          return out;
        };
        // Helper: z-score over available values (ignoring nulls)
        const zscore = (val, arr) => {
          const x = arr.filter(v => Number.isFinite(v));
          if (!x.length) return 0;
          const mu = x.reduce((a,b)=>a+b,0)/x.length;
          const sd = Math.sqrt(x.reduce((a,b)=>a + Math.pow(b-mu,2),0) / x.length) || 1;
          return (val - mu) / sd;
        };
        // SMA 20/50 crossover
        const sma20 = sma(closes, 20);
        const sma50 = sma(closes, 50);
        let sigSma = '-';
        if (sma20[latestIdx] != null && sma50[latestIdx] != null) {
          sigSma = (sma20[latestIdx] > sma50[latestIdx]) ? 'BUY' : (sma20[latestIdx] < sma50[latestIdx]) ? 'SELL' : '-';
        }
        // STL residual z-score (contrarian): < -1.96 => BUY, > +1.96 => SELL
        let sigStl = '-';
        if (Array.isArray(stlResidPoints) && stlResidPoints.length) {
          const vals = stlResidPoints.map(p => Number(p.value)||0);
          const latest = Number(stlResidPoints[stlResidPoints.length-1].value)||0;
          const z = zscore(latest, vals);
          sigStl = z <= -1.96 ? 'BUY' : (z >= 1.96 ? 'SELL' : '-');
        }
        // STL speed z-score (momentum): > +1.96 => BUY, < -1.96 => SELL
        let sigStlSpd = '-';
        if (Array.isArray(stlSpeedPoints) && stlSpeedPoints.length) {
          const vals = stlSpeedPoints.map(p => Number(p.value)||0);
          const latest = Number(stlSpeedPoints[stlSpeedPoints.length-1].value)||0;
          const z = zscore(latest, vals);
          sigStlSpd = z >= 1.96 ? 'BUY' : (z <= -1.96 ? 'SELL' : '-');
        }
        // RSI threshold
        let sigRsi = '-';
        const rsi = Number(lastRsiValues[latestIdx]);
        if (Number.isFinite(rsi)) {
          sigRsi = rsi <= 30 ? 'BUY' : (rsi >= 70 ? 'SELL' : '-');
        }
        // MACD: line vs signal + histogram slope
        let sigMacd = '-';
        const m = Number(lastMacdObj.macd[latestIdx]);
        const s = Number(lastMacdObj.signal[latestIdx]);
        const h = Number(lastMacdObj.histogram[latestIdx]);
        const hPrev = Number(lastMacdObj.histogram[latestIdx-1]);
        if ([m,s,h].every(Number.isFinite)) {
          const rising = Number.isFinite(hPrev) ? (h > hPrev) : false;
          if (m > s && rising) sigMacd = 'BUY';
          else if (m < s && !rising) sigMacd = 'SELL';
        }
        // Volume: spike vs mean with candle direction
        let sigVol = '-';
        if (lastVolumesArr.length) {
          const meanV = lastVolumesArr.reduce((a,b)=>a+b,0) / Math.max(1,lastVolumesArr.length);
          const v = Number(lastVolumesArr[latestIdx]||0);
          if (Number.isFinite(v) && v >= 1.5 * meanV) {
            sigVol = upCandle ? 'BUY' : 'SELL';
          }
        }
        // ATR: high volatility breakout with candle direction (weak)
        let sigAtr = '-';
        const atr = Number(lastAtrValues[latestIdx]);
        if (Number.isFinite(atr)) {
          const avgAtr = lastAtrValues.filter(Number.isFinite).reduce((a,b)=>a+b,0) / Math.max(1,lastAtrValues.filter(Number.isFinite).length);
          if (Number.isFinite(avgAtr) && atr > 1.25 * avgAtr) sigAtr = upCandle ? 'BUY' : 'SELL';
        }
        // ADX: trend strength + direction via +DI / -DI
        let sigAdx = '-';
        const adx = Number(lastAdxObj.adx && lastAdxObj.adx[latestIdx]);
        const pdi = Number(lastAdxObj.plusDI && lastAdxObj.plusDI[latestIdx]);
        const mdi = Number(lastAdxObj.minusDI && lastAdxObj.minusDI[latestIdx]);
        if ([adx,pdi,mdi].every(Number.isFinite)) {
          if (adx >= 25) sigAdx = (pdi > mdi) ? 'BUY' : (pdi < mdi ? 'SELL' : '-');
        }
        indicatorSignals = {
          SMA: sigSma,
          STL: sigStl,
          STLSpeed: sigStlSpd,
          RSI: sigRsi,
          MACD: sigMacd,
          VOL: sigVol,
          ATR: sigAtr,
          ADX: sigAdx,
        };
      }

      function drawSignalChips() {
        if (!lwOverlay || !lwOverlayCtx || !lwChart) return;
        const ctx = lwOverlayCtx;
        const dpr = lwOverlayDpr || (window.devicePixelRatio || 1);
        const cssW = lwOverlay.width / dpr;
        const cssH = lwOverlay.height / dpr;
        // Chips are fixed to the top-left corner of the chart area
        const startY = 26; // move further down from top edge
        const lineH = 18;
        const padX = 6;
        const radius = 6;
        // Draw chips stack (SMA at top)
        const entries = Object.entries(indicatorSignals || {});
        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Background clear in a left strip only (avoid wiping the whole overlay)
        ctx.clearRect(0, 0, 260, Math.min(cssH, startY + (entries.length+1)*lineH + 8));
        let y = startY;
        const textColor = '#111';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        for (const [label, sig] of entries) {
          let bg = 'rgba(158,158,158,0.18)';
          let border = '#9e9e9e';
          if (sig === 'BUY') { bg = 'rgba(46,204,113,0.18)'; border = '#2ecc71'; }
          else if (sig === 'SELL') { bg = 'rgba(231,76,60,0.18)'; border = '#e74c3c'; }
          const text = `${label}: ${sig || '-'}`;
          const w = Math.min(180, Math.max(60, ctx.measureText(text).width + padX * 2));
          const x = 60; // left-aligned, pulled fully inside the plot area
          // rounded rect
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + lineH - radius);
          ctx.quadraticCurveTo(x + w, y + lineH, x + w - radius, y + lineH);
          ctx.lineTo(x + radius, y + lineH);
          ctx.quadraticCurveTo(x, y + lineH, x, y + lineH - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.fillStyle = bg;
          ctx.fill();
          ctx.strokeStyle = border;
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.fillStyle = textColor;
          ctx.fillText(text, x + padX, y + 12);
          y += lineH + 4;
        }
        ctx.restore();
      }

      const computePeriodBoundaryTimes = (period) => {
        periodBoundaryTimes = [];
        periodAnchorTime = null;
        if (!lwChart || !lwLastTimes.length || !period || period < 1) return;
        // Determine anchor time: selected run start_ts mapped to nearest bar time, otherwise first bar
        let anchorIdx = 0;
        if (stlLastMeta && stlLastMeta.start_ts) {
          const anchorSecRaw = Math.floor(new Date(stlLastMeta.start_ts).getTime() / 1000);
          // find first index whose time >= anchorSecRaw
          for (let i = 0; i < lwLastTimes.length; i++) {
            if (lwLastTimes[i] >= anchorSecRaw) { anchorIdx = i; break; }
          }
        }
        periodAnchorTime = lwLastTimes[anchorIdx] || lwLastTimes[0];
        // Walk left and right from anchor by multiples of period (bar count)
        const times = [];
        for (let idx = anchorIdx; idx >= 0; idx -= period) {
          times.push(lwLastTimes[idx]);
        }
        for (let idx = anchorIdx + period; idx < lwLastTimes.length; idx += period) {
          times.push(lwLastTimes[idx]);
        }
        // Sort ascending and unique
        times.sort((a, b) => a - b);
        const uniq = [];
        let prev = null;
        for (const t of times) {
          if (prev === null || t !== prev) uniq.push(t);
          prev = t;
        }
        periodBoundaryTimes = uniq;
      };

      const applyLightweightPeriodOverlay = (rows, period) => {
        if (!lwSeries || typeof lwSeries.setMarkers !== 'function') {
          clearLwOverlay();
          return;
        }
        if (!showPeriodLines || !period || period < 1 || !Array.isArray(periodBoundaryTimes)) {
          lwSeries.setMarkers([]);
          clearLwOverlay();
          return;
        }
        const markers = periodBoundaryTimes.map((t) => ({
          time: t,
          position: 'belowBar',
          shape: 'arrowUp',
          color: '#d84315',
          text: 'P',
        }));
        lwSeries.setMarkers(markers);
        clearLwOverlay();
      };

      const applyChartPeriodOverlay = (rows, period) => {
        if (!Array.isArray(rows) || !rows.length || !period || period < 1 || !showPeriodLines) {
          chartPeriodWindows = [];
          if (chart && curType === 'line') chart.update('none');
          return;
        }
        const eff = Math.max(1, Math.floor(period));
        const windows = [];
        for (let start = 0; start < rows.length; start += eff) {
          const endIndex = Math.min(rows.length - 1, start + eff);
          const startDate = new Date(rows[start].ts);
          const endDate = new Date(rows[endIndex].ts);
          if (!Number.isFinite(startDate.valueOf()) || !Number.isFinite(endDate.valueOf())) continue;
          windows.push({ start: startDate, end: endDate });
        }
        chartPeriodWindows = windows;
        if (chart && curType === 'line') chart.update('none');
      };

      const updatePeriodOverlays = (period) => {
        if (!period || period < 1 || !lastPriceRows.length) {
          chartPeriodWindows = [];
          if (lwSeries && typeof lwSeries.setMarkers === 'function') lwSeries.setMarkers([]);
          clearLwOverlay();
          if (chart && curType === 'line') chart.update('none');
          return;
        }
        const eff = Math.max(1, Math.floor(period));
        if (showPeriodLines) {
          applyChartPeriodOverlay(lastPriceRows, eff);
        } else {
          chartPeriodWindows = [];
          if (chart && curType === 'line') chart.update('none');
        }
        computePeriodBoundaryTimes(eff);
        applyLightweightPeriodOverlay(lastPriceRows, eff);
      };

      const rangeAlmostEqual = (x, y) => Math.abs((x || 0) - (y || 0)) < 1e-4;
      const rangesEqual = (a, b) => a && b && rangeAlmostEqual(a.from, b.from) && rangeAlmostEqual(a.to, b.to);
      const setRangeIfNeeded = (chart, range) => {
        if (!chart || !range || range.from == null || range.to == null) return;
        if (!Number.isFinite(range.from) || !Number.isFinite(range.to)) return;
        const cur = chart.timeScale().getVisibleRange();
        if (!rangesEqual(cur, range)) {
          try {
            chart.timeScale().setVisibleRange(range);
          } catch (err) {
            console.warn('[ChartSync] setVisibleRange failed', err);
          }
        }
      };
      const logicalRangesEqual = (a, b) => {
        if (!a && !b) return true;
        if (!a || !b) return false;
        return rangeAlmostEqual(a.from, b.from) && rangeAlmostEqual(a.to, b.to);
      };
      const setLogicalRangeIfNeeded = (chart, logicalRange) => {
        if (!chart || !logicalRange || logicalRange.from == null || logicalRange.to == null) return;
        if (!Number.isFinite(logicalRange.from) || !Number.isFinite(logicalRange.to)) return;
        const cur = chart.timeScale().getVisibleLogicalRange();
        if (!logicalRangesEqual(cur, logicalRange)) {
          try {
            chart.timeScale().setVisibleLogicalRange(logicalRange);
          } catch (err) {
            console.warn('[ChartSync] setVisibleLogicalRange failed', err);
          }
        }
      };
      const syncAllChartsToRange = (sourceChart, range, logicalRange) => {
        if (!logicalRange || logicalRange.from == null || logicalRange.to == null) return;
        lwSyncing = true;
        try {
          if (lwChart && sourceChart !== lwChart) {
            setLogicalRangeIfNeeded(lwChart, logicalRange);
          }
          if (lwVolChart && lwVolHasData && sourceChart !== lwVolChart) {
            setLogicalRangeIfNeeded(lwVolChart, logicalRange);
          }
          if (lwRsiChart && lwRsiHasData && sourceChart !== lwRsiChart) {
            setLogicalRangeIfNeeded(lwRsiChart, logicalRange);
          }
          if (lwMacdChart && lwMacdHasData && sourceChart !== lwMacdChart) {
            setLogicalRangeIfNeeded(lwMacdChart, logicalRange);
          }
          if (lwDerivChart && (lwDerivHasSpeed || lwDerivHasAccel) && sourceChart !== lwDerivChart) {
            setLogicalRangeIfNeeded(lwDerivChart, logicalRange);
          }
          if (lwAtrChart && (lastAtrValues && lastAtrValues.length) && sourceChart !== lwAtrChart) {
            setLogicalRangeIfNeeded(lwAtrChart, logicalRange);
          }
          if (lwAdxChart && (lastAdxObj && (lastAdxObj.adx||[]).length) && sourceChart !== lwAdxChart) {
            setLogicalRangeIfNeeded(lwAdxChart, logicalRange);
          }
        } finally {
          lwSyncing = false;
        }
      };
      const handleChartRangeChange = (chartInstance) => {
        if (!chartInstance || lwSyncing || !lwSubscriptionsEnabled) return;
        if (lwRangeTimer) cancelAnimationFrame(lwRangeTimer);
        lwRangeTimer = requestAnimationFrame(() => {
          const range = chartInstance.timeScale().getVisibleRange();
          const logicalRange = chartInstance.timeScale().getVisibleLogicalRange();
          const effectiveLogical = logicalRange || currentLogicalRange || null;
          if (effectiveLogical && effectiveLogical.from != null && effectiveLogical.to != null) {
            if (logicalRangesEqual(currentLogicalRange, effectiveLogical)) {
              return;
            }
            currentLogicalRange = effectiveLogical;
            syncAllChartsToRange(chartInstance, null, effectiveLogical);
            if (curType === 'line') {
              applyIndicatorViewport(range, effectiveLogical);
            }
            if (curType === 'candlestick') {
              redrawPeriodLines();
            }
          } else {
            currentTimeRange = null;
            currentLogicalRange = null;
            if (curType === 'line') {
              applyIndicatorViewport(null, null);
            }
            if (curType === 'candlestick') {
              redrawPeriodLines();
            }
          }
        });
      };

      function isFxPair(sym) {
        return /^[A-Z]{6,7}$/.test((sym||'').toUpperCase());
      }
      function splitPair(sym) { const s=(sym||'').toUpperCase(); return { base: s.slice(0,3), quote: s.slice(3,6) }; }

      function openHealth(kind, preferredStrategy) {
      healthState.kind = kind;
      healthState.offset = 0;
      healthState.runs = [];
      const modal = el('healthModal');
      if (!modal) return;
      // Title: use Tech+AI Health Check when Tech snapshot strategy is in use
      const titleEl = el('healthModalTitle');
      if (titleEl) {
        if (preferredStrategy === 'tech_snapshot_10q.json' || preferredStrategy === 'tech_snapshot_10q_position.json') {
          titleEl.textContent = 'Tech+AI Health Check';
        } else {
          titleEl.textContent = 'Basic Health Check';
        }
      }
      // Ensure the dropdown reflects a sane default for this kind/symbol
      ensureStrategyForKind(kind);
      // Resolve the strategy to use for history explicitly to avoid leakage (e.g. ai_trade_plan)
      if (preferredStrategy && healthStrategySelect) {
        const hasOption = !!healthStrategySelect.querySelector(`option[value="${preferredStrategy}"]`);
        if (hasOption) {
          healthStrategyUserOverride = true;
          healthStrategySelect.value = preferredStrategy;
        }
        healthState.strategy = preferredStrategy;
        // If Tech snapshot is selected, group as 'tech' to filter history appropriately
        if (preferredStrategy === 'tech_snapshot_10q.json' || preferredStrategy === 'tech_snapshot_10q_position.json') {
          healthState.group = 'tech';
        } else {
          healthState.group = null;
        }
      } else {
        // Default to grouping by 'basic' so history shows all basic templates
        healthState.strategy = null;
        healthState.group = 'basic';
      }
      // No exclude filter needed once strategy is explicit
      healthState.excludeStrategy = null;
      modal.style.display = 'flex';
      const sym = symbolSelect.value.toUpperCase();
        const info = el('healthInfo');
        if (kind === 'forex_pair') {
          const pq = isFxPair(sym) ? splitPair(sym) : { base: sym.slice(0,3), quote: sym.slice(3,6) };
          info.textContent = `Pair: ${pq.base}/${pq.quote}`;
        } else {
          info.textContent = `Stock: ${sym}`;
        }
        el('healthResultsBox').innerHTML = '';
        loadHealthHistory();
      }

      function openHealthAuto() {
        const sym = symbolSelect.value.toUpperCase();
        const kind = isFxPair(sym) ? 'forex_pair' : 'stock';
        healthState.runs = [];
        openHealth(kind, null);
      }

      const buildTechTable = (title, headers, rows) => {
        const headCells = headers.map((label) => `<th style="text-align:right; padding:4px 6px; border-bottom:1px solid var(--line);">${esc(label)}</th>`).join('');
        const bodyHtml = rows.length
          ? rows.map((row) => {
              const timeCell = `<td style="padding:4px 6px; border-bottom:1px solid var(--line);">${esc(row.time || '')}</td>`;
              const valueCells = row.values.map((val) => `<td style="text-align:right; padding:4px 6px; border-bottom:1px solid var(--line);">${esc(val)}</td>`).join('');
              return `<tr>${timeCell}${valueCells}</tr>`;
            }).join('')
          : `<tr><td colspan="${headers.length + 1}" style="padding:10px; text-align:center; color:var(--muted);"><em>No data</em></td></tr>`;
        return `<div style="border:1px solid var(--line); border-radius:8px; padding:10px; background:var(--panel);">
          <div style="font-weight:600; margin-bottom:6px;">${esc(title)}</div>
          <table style="width:100%; border-collapse:collapse; font-size:13px;">
            <thead>
              <tr>
                <th style="text-align:left; padding:4px 6px; border-bottom:1px solid var(--line);">Time</th>
                ${headCells}
              </tr>
            </thead>
            <tbody>
              ${bodyHtml}
            </tbody>
          </table>
        </div>`;
      };

      function openTechHealth() {
        applyTechWindowDefault(false);
        const modal = el('techModal');
        const box = el('techSummaryBox');
        const metaBox = el('techSummaryMeta');
        if (!modal || !box || !metaBox) return;
        const symbol = currentSymbol();
        const tf = currentTf();
        const rows = Array.isArray(lastPriceRows) ? lastPriceRows : [];
        const windowSize = Math.max(1, resolveTechWindow());
        const startIdx = Math.max(rows.length - windowSize, 0);
        const windowRows = rows.slice(startIdx);
        const closes = rows.map((r) => Number(r?.close));
        const volumes = rows.map((r) => {
          const stack = [r?.real_volume, r?.tick_volume, r?.volume]
            .map((v) => Number(v))
            .filter((v) => Number.isFinite(v) && v > 0);
          return stack.length ? stack[0] : null;
        });
        const rsiValues = computeRSI(closes);
        const macdObj = computeMACD(closes);
        const { atr, tr } = computeAtrSeries(rows);
        const adxObj = computeAdxSeries(rows, tr);

        const buildFromArray = (arr) => windowRows.map((row, offset) => {
          const idx = startIdx + offset;
          const raw = arr ? arr[idx] : null;
          const numeric = Number(raw);
          const formatted = raw != null && Number.isFinite(numeric) ? formatTechNumber(numeric) : '—';
          const ts = row && row.ts ? formatDateTime(row.ts) : '';
          return { time: ts, values: [formatted] };
        });

        const buildFromArrays = (arrays) => windowRows.map((row, offset) => {
          const idx = startIdx + offset;
          const values = arrays.map((arr) => {
            const raw = arr ? arr[idx] : null;
            const numeric = Number(raw);
            return raw != null && Number.isFinite(numeric) ? formatTechNumber(numeric) : '—';
          });
          const ts = row && row.ts ? formatDateTime(row.ts) : '';
          return { time: ts, values };
        });

        const slicePoints = (points) => {
          if (!Array.isArray(points) || !points.length) return [];
          return points.slice(Math.max(points.length - windowSize, 0)).map((pt) => ({
            time: formatEpochDateTime(pt.time),
            values: [Number.isFinite(Number(pt.value)) ? formatTechNumber(Number(pt.value)) : '—'],
          }));
        };

        const priceData = buildFromArray(closes);
        const volumeData = buildFromArray(volumes);
        const rsiData = buildFromArray(rsiValues);
        const boll = computeBollingerBands(closes);
        const bollData = buildFromArrays([boll.middle, boll.upper, boll.lower]);
        const macdData = buildFromArrays([macdObj.macd, macdObj.signal, macdObj.histogram]);
        const atrData = buildFromArray(atr);
        const adxData = buildFromArrays([adxObj.adx, adxObj.plusDI, adxObj.minusDI]);
        const trendData = slicePoints(stlTrendPoints);
        const seasonalData = slicePoints(stlSeasonPoints);
        const residData = slicePoints(stlResidPoints);
        const speedData = slicePoints(stlSpeedPoints);
        const accelData = slicePoints(stlAccelPoints);

        const sections = [
          buildTechTable(`${tf} Close Price`, ['Value'], priceData),
          buildTechTable('Bollinger (20,2)', ['Mid', 'Upper', 'Lower'], bollData),
          buildTechTable('Volume', ['Value'], volumeData),
          buildTechTable('STL Trend', ['Value'], trendData),
          buildTechTable('STL Seasonal', ['Value'], seasonalData),
          buildTechTable('STL Residual', ['Value'], residData),
          buildTechTable('STL Speed (ΔTrend)', ['Value'], speedData),
          buildTechTable('STL Acceleration (ΔSpeed)', ['Value'], accelData),
          buildTechTable('RSI (14)', ['Value'], rsiData),
          buildTechTable('MACD (12,26,9)', ['MACD', 'Signal', 'Hist'], macdData),
          buildTechTable('ATR (14)', ['Value'], atrData),
          buildTechTable('ADX (14)', ['ADX', '+DI', '-DI'], adxData),
        ];

        box.innerHTML = sections.join('');
        const metaParts = [symbol, `TF ${tf}`, 'Seasonal-Trend decomposition using Loess (STL)'];
        if (stlLastMeta && Number.isFinite(Number(stlLastMeta.period))) {
          metaParts.push(`STL period ${Number(stlLastMeta.period)}`);
        }
        metaParts.push(`N=${windowSize}`);
        metaBox.textContent = metaParts.join(' • ');
        modal.style.display = 'flex';
      }

      const renderHealthOutcome = (container, payload) => {
        if (!container) return;
        const answers = Array.isArray(payload.answers)
          ? payload.answers
          : (Array.isArray(payload.questions) ? payload.questions : []);
        const score = payload.score ?? (payload.scores && payload.scores.NET);
        const signal = payload.signal ?? 'NEUTRAL';
        const strategyUsed = payload.strategy || (payload.meta && payload.meta.strategy) || '';
        const baseCode = payload.base || (payload.meta && payload.meta.base);
        const quoteCode = payload.quote || (payload.meta && payload.meta.quote);
        const scoresObj = payload.scores || (payload.meta && payload.meta.scores) || null;
        const pillHtml = answers.map((ans, idx) => {
          const val = ans && Object.prototype.hasOwnProperty.call(ans, 'answer') ? ans.answer : null;
          const explanation = esc((ans && ans.explanation) || '');
          let label;
          let bg;
          let border;
          let textColor;
          let extra = '';
          if (val && typeof val === 'object' && Object.prototype.hasOwnProperty.call(val, 'position')) {
            const pos = String(val.position || '').toUpperCase();
            const isBuy = pos !== 'SELL';
            label = isBuy ? 'BUY' : 'SELL';
            bg = isBuy ? 'rgba(46,204,113,0.12)' : 'rgba(231,76,60,0.12)';
            border = isBuy ? '#2ecc71' : '#e74c3c';
            textColor = isBuy ? '#1b5e20' : '#b71c1c';
            const sl = Number(val.sl);
            const tp = Number(val.tp);
            const parts = [];
            if (Number.isFinite(sl)) parts.push(`SL ${sl.toFixed(2)}`);
            if (Number.isFinite(tp)) parts.push(`TP ${tp.toFixed(2)}`);
            if (parts.length) extra = `<span class="pill" style="margin-left:6px;">${esc(parts.join(' • '))}</span>`;
          } else if (typeof val === 'boolean') {
            const isTrue = val === true;
            label = isTrue ? 'YES' : 'NO';
            bg = isTrue ? 'rgba(46,204,113,0.12)' : 'rgba(231,76,60,0.12)';
            border = isTrue ? '#2ecc71' : '#e74c3c';
            textColor = isTrue ? '#1b5e20' : '#b71c1c';
          } else if (typeof val === 'string') {
            label = val.toUpperCase();
            if (label === 'BULLISH') {
              bg = 'rgba(46,204,113,0.12)';
              border = '#2ecc71';
              textColor = '#1b5e20';
            } else if (label === 'BEARISH') {
              bg = 'rgba(231,76,60,0.12)';
              border = '#e74c3c';
              textColor = '#b71c1c';
            } else {
              // Neutral color for currency-code answers (e.g., EUR/USD)
              bg = 'rgba(33,150,243,0.12)';
              border = '#2196f3';
              textColor = '#0d47a1';
            }
          } else {
            label = val == null ? '—' : String(val);
            bg = 'rgba(158,158,158,0.12)';
            border = '#9e9e9e';
            textColor = '#424242';
          }
          return `<div style="display:flex; flex-direction:column; gap:4px;">
            <div style="display:flex; gap:8px; align-items:center;">
              <span style="width:28px; color:var(--muted)">${idx + 1}.</span>
              <span class="pill" style="background:${bg}; border-color:${border}; color:${textColor};">
                ${esc(label)}
              </span>${extra}
            </div>
            <div style="font-size:12px; color:var(--muted); padding-left:28px;">${explanation || '<em>No explanation</em>'}</div>
          </div>`;
        }).join('');
        let scoreLine = `<div class="row" style="justify-content:space-between;"><strong>Score: ${score ?? '—'}</strong><strong>${esc(signal)}</strong></div>`;
        const strategyLine = `<div style="font-size:12px; color:var(--muted); margin-top:4px;">Strategy: ${esc(strategyUsed || '—')}</div>`;
        let countsLine = '';
        if (scoresObj && typeof scoresObj === 'object') {
          const hasBaseQuote = Object.prototype.hasOwnProperty.call(scoresObj, 'BASE') || Object.prototype.hasOwnProperty.call(scoresObj, 'QUOTE');
          const hasBullBear = Object.prototype.hasOwnProperty.call(scoresObj, 'BULLISH') || Object.prototype.hasOwnProperty.call(scoresObj, 'BEARISH');
          const hasBuySell = Object.prototype.hasOwnProperty.call(scoresObj, 'BUY') || Object.prototype.hasOwnProperty.call(scoresObj, 'SELL');
          const netVal = Object.prototype.hasOwnProperty.call(scoresObj, 'NET') ? scoresObj.NET : null;
          const segments = [];
          if (hasBaseQuote) {
            const baseCount = baseCode && Object.prototype.hasOwnProperty.call(scoresObj, 'BASE') ? scoresObj.BASE : null;
            const quoteCount = quoteCode && Object.prototype.hasOwnProperty.call(scoresObj, 'QUOTE') ? scoresObj.QUOTE : null;
            if (baseCode != null && baseCount != null) segments.push(`${esc(baseCode)}=${baseCount}`);
            if (quoteCode != null && quoteCount != null) segments.push(`${esc(quoteCode)}=${quoteCount}`);
          }
          if (hasBullBear) {
            const bull = Object.prototype.hasOwnProperty.call(scoresObj, 'BULLISH') ? scoresObj.BULLISH : null;
            const bear = Object.prototype.hasOwnProperty.call(scoresObj, 'BEARISH') ? scoresObj.BEARISH : null;
            if (bull != null) segments.push(`BULLISH=${bull}`);
            if (bear != null) segments.push(`BEARISH=${bear}`);
          }
          if (hasBuySell) {
            const buy = Object.prototype.hasOwnProperty.call(scoresObj, 'BUY') ? scoresObj.BUY : null;
            const sell = Object.prototype.hasOwnProperty.call(scoresObj, 'SELL') ? scoresObj.SELL : null;
            if (buy != null) segments.push(`BUY=${buy}`);
            if (sell != null) segments.push(`SELL=${sell}`);
          }
          if (netVal != null) segments.push(`NET=${netVal}`);
          if (segments.length) {
            countsLine = `<div style="font-size:12px; color:var(--muted); margin-top:2px;">${segments.join(' • ')}</div>`;
          }
        }
        // Optional position block from +Position strategies
        let positionBlock = '';
        const pos = payload.position || null;
        if (pos && typeof pos === 'object') {
          const posLabel = String(pos.position || '').toUpperCase();
          const isBuy = posLabel === 'BUY';
          const bg = isBuy ? 'rgba(46,204,113,0.12)' : 'rgba(231,76,60,0.12)';
          const border = isBuy ? '#2ecc71' : '#e74c3c';
          const color = isBuy ? '#1b5e20' : '#b71c1c';
          const slStr = Number.isFinite(Number(pos.sl)) ? formatTechNumber(Number(pos.sl)) : '—';
          const tpStr = Number.isFinite(Number(pos.tp)) ? formatTechNumber(Number(pos.tp)) : '—';
          const expl = (pos.explanation || '').toString();
          positionBlock = `
            <div style="margin-top:8px; padding:8px; border:1px solid var(--line); border-radius:8px; background:var(--panel);">
              <div class="row" style="justify-content:space-between; align-items:center;">
                <div style="display:flex; gap:8px; align-items:center;">
                  <strong>Trade Orientation</strong>
                  <span class="pill" style="background:${bg}; border-color:${border}; color:${color};">${esc(posLabel)}</span>
                </div>
                <div style="font-size:12px; color:var(--muted);">SL ${esc(slStr)} • TP ${esc(tpStr)}</div>
              </div>
              <div style="font-size:12px; color:var(--muted); margin-top:6px;">${esc(expl)}</div>
            </div>`;
        }
        container.innerHTML = `${scoreLine}${strategyLine}${countsLine}${positionBlock}<div style="display:flex; flex-direction:column; gap:6px; margin-top:8px;">${pillHtml}</div>`;
      };

      async function loadHealthHistory() {
        const box = el('healthHistoryBox');
        box.innerHTML = '<em style="color:var(--muted)">Loading…</em>';
        const sym = symbolSelect.value.toUpperCase();
        const params = new URLSearchParams();
        if (healthState.kind === 'forex_pair') {
          const pq = isFxPair(sym) ? splitPair(sym) : { base: sym.slice(0,3), quote: sym.slice(3,6) };
          params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote);
        } else {
          params.set('kind','stock'); params.set('symbol', sym);
        }
        params.set('limit','5'); params.set('offset', String(healthState.offset||0));
        if (healthState.strategy) { params.set('strategy', healthState.strategy); }
        if (healthState.group) { params.set('group', healthState.group); }
        if (healthState.excludeStrategy) { params.set('exclude_strategy', healthState.excludeStrategy); }
        if (healthState.strategy === 'tech_snapshot_10q.json' || healthState.strategy === 'tech_snapshot_10q_position.json') { params.set('tf', currentTf()); }
        try {
          const res = await fetch(`/api/health/runs?${params.toString()}`);
          const data = await res.json();
          const runs = (data && data.runs) || [];
          if ((healthState.offset||0) === 0) { box.innerHTML = ''; }
          if (!Array.isArray(healthState.runs)) healthState.runs = [];
          const startIdx = healthState.runs.length;
          healthState.runs = healthState.runs.concat(runs);
          const html = runs.map((r, i) => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ansMeta = r.answers || {};
            const sig = ansMeta.signal || (ansMeta.scores && ansMeta.scores.signal) || '';
            const sc = (ansMeta.score ?? ansMeta.NET ?? '') ?? '';
            const strat = ansMeta.strategy || '';
            const summaryParts = [];
            if (sig) summaryParts.push(sig);
            if (sc !== '') summaryParts.push(sc);
            if (strat) summaryParts.push(strat);
            const summary = summaryParts.join(' • ');
            const idx = startIdx + i;
            return `<button class="row" data-run-idx="${idx}" style="justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%; text-align:left; cursor:pointer;">
              <span style="font-size:13px; color:var(--muted);">${t}</span>
              <span style="font-weight:600;">${summary}</span>
            </button>`;
          }).join('');
          if (html) box.insertAdjacentHTML('beforeend', html);

          if (!runs.length && (healthState.offset||0) === 0) {
            box.innerHTML = '<em style="color:var(--muted)">No recent checks</em>';
          }
        } catch (e) {
          box.innerHTML = '<em style="color:var(--muted)">Failed to load</em>';
        }
      }

      async function startHealthRun() {
        const sym = symbolSelect.value.toUpperCase();
        const n = Math.max(1, Math.min(20, Number(el('healthNewsCount').value || 20)));
        const barsN = Math.max(10, Math.min(500, Number(resolveTechWindow && resolveTechWindow() || 50)));
        const tfNow = currentTf();
        const body = { symbol: sym, news_count: n, timeframe: tfNow, n_bars: barsN };
        const strategyName = healthStrategySelect ? healthStrategySelect.value : '';
        if (strategyName) {
          body.strategy = strategyName;
        }
        // When running the technical snapshot strategy, attach the snapshot text and timeframe
        if (strategyName === 'tech_snapshot_10q.json') {
          try {
            const snapshot = buildTechSnapshotString();
            body.tech_snapshot = snapshot;
            body.timeframe = tfNow;
          } catch (err) {
            console.warn('Failed to build tech snapshot', err);
          }
        }
        console.log('[Health] using strategy', strategyName || '(auto)');
        const outBox = el('healthResultsBox');
        outBox.innerHTML = '<div style="color:var(--muted)">Running… this can take ~30–60s</div>';
        try {
          // Optimistically show running state on Basic freshness
          if (typeof setHealthFreshRunning === 'function') setHealthFreshRunning();
          // Optional model override for Basic Health
          const basicModelSel = document.getElementById('basicAiModel');
          const basicModel = basicModelSel && basicModelSel.value ? basicModelSel.value : '';
          if (basicModel) body.model = basicModel;
          const res = await fetch('/api/health/run', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify(body)
          });
          const data = await res.json();
          if (!data || data.ok !== true) {
            outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(data && data.error) || 'unknown'}</em>`;
            return;
          }
          renderHealthOutcome(outBox, data);
          loadHealthHistory();
          await refreshTechFreshness();
          await refreshHealthFreshness();
          refreshTechFreshness();
        } catch (e) {
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e}</em>`;
        }
      }

      async function startTechAiRun() {
        const sym = symbolSelect.value.toUpperCase();
        const outBox = el('healthResultsBox');
        try {
          const snapshot = buildTechSnapshotString();
            const body = {
              symbol: sym,
              strategy: (document.getElementById('techAiStrategy') && document.getElementById('techAiStrategy').value) ? document.getElementById('techAiStrategy').value : 'tech_snapshot_10q_position.json',
              timeframe: currentTf(),
              tech_snapshot: snapshot
            };
          // Optional model override for Tech+AI
          const techModelSel = document.getElementById('techAiModel');
          const techModel = techModelSel && techModelSel.value ? techModelSel.value : '';
          if (techModel) body.model = techModel;
          console.log('[Health][TechAI] running tech snapshot for', sym, currentTf());
          if (typeof setTechFreshRunning === 'function') setTechFreshRunning();
          outBox.innerHTML = '<div style="color:var(--muted)">Running Tech+AI…</div>';
          const res = await fetch('/api/health/run', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            cache: 'no-store',
            body: JSON.stringify(body)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data || data.ok !== true) {
            outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(data && data.error) || res.statusText || 'unknown'}</em>`;
            return;
          }
          renderHealthOutcome(outBox, data);
          // After a Tech+AI run, show Tech group history filtered by the chosen strategy
          if (typeof healthState === 'object') {
            healthState.group = 'tech';
            healthState.strategy = body.strategy || 'tech_snapshot_10q_position.json';
            healthState.offset = 0;
          }
          loadHealthHistory();
          // Update Tech freshness badge (Basic is independent; do not touch here)
          try { await refreshTechFreshness(); } catch {}
        } catch (e) {
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
        }
      }

      function buildTechSnapshotString() {
        // Build a compact textual snapshot matching the Technical Snapshot modal tables
        applyTechWindowDefault(false);
        const rows = Array.isArray(lastPriceRows) ? lastPriceRows : [];
        const windowSize = Math.max(1, resolveTechWindow());
        const startIdx = Math.max(rows.length - windowSize, 0);
        const windowRows = rows.slice(startIdx);
        const closes = rows.map((r) => Number(r?.close));
        const volumes = rows.map((r) => {
          const stack = [r?.real_volume, r?.tick_volume, r?.volume].map((v) => Number(v)).filter((v) => Number.isFinite(v) && v > 0);
          return stack.length ? stack[0] : null;
        });
        const rsiValues = computeRSI(closes);
        const macdObj = computeMACD(closes);
        const { atr, tr } = computeAtrSeries(rows);
        const adxObj = computeAdxSeries(rows, tr);

        const fmtRow = (ts, vals) => `${formatDateTime(ts)}\t${vals.map((v)=> (Number.isFinite(Number(v)) ? formatTechNumber(Number(v)) : '—')).join('\t')}`;
        const toBlock = (title, headers, dataRows) => {
          const lines = [title, 'Time\t' + headers.join('\t')];
          for (const r of dataRows) lines.push(fmtRow(r.ts, r.values));
          return lines.join('\n');
        };
        const buildSeries = (arr) => windowRows.map((row, offset) => ({ ts: row.ts, values: [arr[startIdx + offset]] }));
        const buildSeries3 = (a,b,c) => windowRows.map((row, offset) => ({ ts: row.ts, values: [a[startIdx + offset], b[startIdx + offset], c[startIdx + offset]] }));
        const slicePts = (pts) => {
          if (!Array.isArray(pts) || !pts.length) return [];
          const p = pts.slice(Math.max(pts.length - windowSize, 0));
          return p.map((pt) => ({ ts: (pt.time*1000), values: [pt.value] }));
        };

        const parts = [];
        const symbol = currentSymbol();
        const tf = currentTf();
        const head = `${symbol} • TF ${tf}` + (stlLastMeta && Number.isFinite(Number(stlLastMeta.period)) ? ` • STL period ${Number(stlLastMeta.period)}` : '') + ` • N=${windowSize}`;
        parts.push(head);
        parts.push(toBlock(`${tf} Close Price`, ['Value'], buildSeries(closes)));
        const boll = computeBollingerBands(closes);
        parts.push(toBlock('Bollinger (20,2)', ['Mid','Upper','Lower'], buildSeries3(boll.middle, boll.upper, boll.lower)));
        parts.push(toBlock('Volume', ['Value'], buildSeries(volumes)));
        parts.push(toBlock('STL Trend', ['Value'], slicePts(stlTrendPoints)));
        parts.push(toBlock('STL Seasonal', ['Value'], slicePts(stlSeasonPoints)));
        parts.push(toBlock('STL Residual', ['Value'], slicePts(stlResidPoints)));
        parts.push(toBlock('STL Speed (ΔTrend)', ['Value'], slicePts(stlSpeedPoints)));
        parts.push(toBlock('STL Acceleration (ΔSpeed)', ['Value'], slicePts(stlAccelPoints)));
        parts.push(toBlock('RSI (14)', ['Value'], buildSeries(rsiValues)));
        parts.push(toBlock('MACD (12,26,9)', ['MACD','Signal','Hist'], buildSeries3(macdObj.macd, macdObj.signal, macdObj.histogram)));
        parts.push(toBlock('ATR (14)', ['Value'], buildSeries(atr)));
        parts.push(toBlock('ADX (14)', ['ADX','+DI','-DI'], buildSeries3(adxObj.adx, adxObj.plusDI, adxObj.minusDI)));
        return parts.join('\n\n');
      }

      const btnHealthCheck = document.getElementById('btnHealthCheck');
      const btnHealthStart = document.getElementById('btnHealthStart');
      const btnHealthMore = document.getElementById('btnHealthMore');
      const btnHealthClose = document.getElementById('btnHealthClose');
      const btnTechHealth = document.getElementById('btnTechHealth');
      const btnTechAiHealth = document.getElementById('btnTechAiHealth');
      const btnAiBuySell = document.getElementById('btnAiBuySell');
      const btnAutoAiTrade = document.getElementById('btnAutoAiTrade');
      const aiLeverageInput = document.getElementById('aiLeverage');
      const btnTechClose = document.getElementById('btnTechClose');
      const autoBasicToggle = document.getElementById('chkAutoBasic');
      const autoTechToggle = document.getElementById('chkAutoTech');
      let autoBasicRunning = false;
      let autoTechRunning = false;
      let autoCheckPoller = null;
      const AUTO_BASIC_MIN_MS = 15 * 60 * 1000; // 15 minutes guard
      const AUTO_TECH_MIN_MS = 10 * 60 * 1000; // 10 minutes guard
      const getABasicLastKey = () => `auto_basic_last:${currentSymbol()}:${currentTf()}`;
      const getATechLastKey = () => `auto_tech_last:${currentSymbol()}:${currentTf()}`;
      const getLastAt = (k) => { try { return Number(localStorage.getItem(k) || '0'); } catch { return 0; } };
      const setLastAt = (k, t) => { try { localStorage.setItem(k, String(t || Date.now())); } catch {} };
      const tradeModal = document.getElementById('tradeModal');
      const autoModal = document.getElementById('autoModal');
      const btnAutoClose = document.getElementById('btnAutoClose');
      const btnAutoStart = document.getElementById('btnAutoStart');
      const autoHistoryBox = document.getElementById('autoHistoryBox');
      const autoMeta = document.getElementById('autoMeta');
      const tradeInfo = document.getElementById('tradeInfo');
      const tradeResultsBox = document.getElementById('tradeResultsBox');
      const autoLogBox = document.getElementById('autoAiLogBox');
      const btnAutoMore = document.getElementById('btnAutoMore');
      const tradeHistoryBox = document.getElementById('tradeHistoryBox');
      const btnTradeStartBuy = document.getElementById('btnTradeStartBuy');
      const btnTradeStartSell = document.getElementById('btnTradeStartSell');
      const planSelect = document.getElementById('selectPlanRun');
      const btnPlanMore = document.getElementById('btnPlanMore');
      const btnTradeClose = document.getElementById('btnTradeClose');
      const btnTradeMore = document.getElementById('btnTradeMore');
      let tradeState = { action: 'BUY', offset: 0, basicRunId: null, techRunId: null };
      let autoSelectOffset = 0; // kept for dropdown API (not used in modal)
      let autoHistoryOffset = 0;
      function getAutoLogBoxEl() {
        return document.getElementById('autoLogBoxModal') || document.getElementById('autoAiLogBox');
      }
      function appendAutoLog(msg, level='info') {
        try {
          const ts = new Date().toLocaleTimeString();
          const color = level === 'error' ? '#e74c3c' : (level === 'warn' ? '#ff9800' : 'var(--muted)');
          const line = `<div><span style="color:${color};">[${ts}]</span> ${esc(msg)}</div>`;
          const box = getAutoLogBoxEl();
          if (box) { box.insertAdjacentHTML('beforeend', line); box.scrollTop = box.scrollHeight; }
          if (!tradeState.autoSteps) tradeState.autoSteps = [];
          tradeState.autoSteps.push({ ts: new Date().toISOString(), level, message: msg });
        } catch {}
      }
      if (btnHealthCheck) btnHealthCheck.addEventListener('click', openHealthAuto);
      const healthFreshEl = document.getElementById('healthFreshIndicator');
      const setHealthFreshRunning = () => {
        if (!healthFreshEl) return;
        healthFreshEl.textContent = 'Checking…';
        healthFreshEl.style.background = 'rgba(158,158,158,0.12)';
        healthFreshEl.style.borderColor = '#9e9e9e';
        healthFreshEl.style.color = '#424242';
        healthFreshEl.title = 'Running Basic Health…';
      };
      const renderHealthFresh = (info) => {
        if (!healthFreshEl) return;
        const hasCount = info && info.new_count != null;
        const freshCount = hasCount ? Number(info.new_count) : null;
        const lastUsed = Number((info && info.last_run_news_count) || 0);
        const status = info && typeof info.status === 'string' ? info.status.toLowerCase() : 'unknown';
        const isFresh = (status === 'fresh') || (hasCount && freshCount === 0);
        const isStale = (status === 'stale') || (hasCount && freshCount > 0);
        let label = '—';
        let bg = 'rgba(158,158,158,0.12)';
        let border = '#9e9e9e';
        let color = '#424242';
        if (isFresh && !isStale) {
          label = 'Up to date';
          bg = 'rgba(46,204,113,0.12)';
          border = '#2ecc71';
          color = '#1b5e20';
        } else if (isStale) {
          const n = hasCount ? Math.max(0, Number(freshCount)) : '?';
          label = `Outdated +${n}`;
          bg = 'rgba(231,76,60,0.12)';
          border = '#e74c3c';
          color = '#b71c1c';
        }
        healthFreshEl.textContent = label;
        healthFreshEl.style.background = bg;
        healthFreshEl.style.borderColor = border;
        healthFreshEl.style.color = color;
        const tip = [];
        if (info && info.last_run_at) tip.push(`Last check: ${new Date(info.last_run_at).toLocaleString()}`);
        if (info && info.baseline_at) tip.push(`Last news used: ${new Date(info.baseline_at).toLocaleString()}`);
        if (info && info.latest_news_at) tip.push(`Latest news (available): ${new Date(info.latest_news_at).toLocaleString()}`);
        tip.push(`Used in last run: ${lastUsed}`);
        if (hasCount) tip.push(`New since: ${freshCount}`);
        healthFreshEl.title = tip.join(' \n');
      };
      async function refreshHealthFreshness() {
        try {
          const sym = currentSymbol();
          const strat = (healthStrategySelect && healthStrategySelect.value) ? healthStrategySelect.value : '';
          const params = new URLSearchParams({ symbol: sym });
          if (strat) params.set('strategy', strat);
          const r = await fetch(`/api/health/freshness?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js && js.ok) {
            renderHealthFresh(js);
            if (typeof maybeAutoRunBasic === 'function') maybeAutoRunBasic(js);
          }
        } catch (e) {
          // ignore
        }
      }

      // Tech+AI freshness (bars outdated)
      const techFreshEl = document.getElementById('techFreshIndicator');
      const setTechFreshRunning = () => {
        if (!techFreshEl) return;
        techFreshEl.textContent = 'Computing…';
        techFreshEl.style.background = 'rgba(158,158,158,0.12)';
        techFreshEl.style.borderColor = '#9e9e9e';
        techFreshEl.style.color = '#424242';
        techFreshEl.title = 'Running Tech+AI…';
      };
      const renderTechFresh = (info) => {
        if (!techFreshEl) return;
        let label = '—';
        let bg = 'rgba(158,158,158,0.12)';
        let border = '#9e9e9e';
        let color = '#424242';
        if (info && info.status === 'fresh') {
          label = 'Tech up-to-date';
          bg = 'rgba(46,204,113,0.12)';
          border = '#2ecc71';
          color = '#1b5e20';
        } else if (info && info.status === 'stale') {
          const n = Number(info.outdated_bars || 0);
          label = `Outdated +${n}`;
          bg = 'rgba(231,76,60,0.12)';
          border = '#e74c3c';
          color = '#b71c1c';
        }
        techFreshEl.textContent = label;
        techFreshEl.style.background = bg;
        techFreshEl.style.borderColor = border;
        techFreshEl.style.color = color;
        const tip = [];
        if (info && info.last_bar_ts_used) tip.push(`Last bar used: ${new Date(info.last_bar_ts_used).toLocaleString()}`);
        if (info && info.latest_bar_ts) tip.push(`Latest bar: ${new Date(info.latest_bar_ts).toLocaleString()}`);
        techFreshEl.title = tip.join(' \n');
      };
      async function refreshTechFreshness() {
        try {
          const sym = currentSymbol();
          const tf = currentTf();
          const params = new URLSearchParams({ symbol: sym, tf });
          const r = await fetch(`/api/tech/freshness?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js && js.ok) {
            renderTechFresh(js);
            if (typeof maybeAutoRunTech === 'function') maybeAutoRunTech(js);
          }
        } catch (e) {
          // ignore
        }
      }

      // --- Auto Check (per symbol × timeframe) ---
      const getAutoBasicKey = () => `auto_check_basic:${currentSymbol()}:${currentTf()}`;
      const getAutoTechKey = () => `auto_check_tech:${currentSymbol()}:${currentTf()}`;
      const isAutoBasicEnabled = () => !!(autoBasicToggle && !autoBasicToggle.disabled && autoBasicToggle.checked);
      const isAutoTechEnabled = () => !!(autoTechToggle && !autoTechToggle.disabled && autoTechToggle.checked);
      const applyAutoBasicState = (on) => { if (autoBasicToggle) autoBasicToggle.checked = !!on; };
      const applyAutoTechState = (on) => { if (autoTechToggle) autoTechToggle.checked = !!on; };
      async function loadAutoBasicPref() {
        if (!autoBasicToggle) return;
        try {
          const key = encodeURIComponent(getAutoBasicKey());
          const r = await fetch(`${PREF_ENDPOINT}?keys=${key}`, { cache: 'no-store' });
          const js = await r.json();
          const val = js && js.prefs ? js.prefs[getAutoBasicKey()] : null;
          applyAutoBasicState(String(val || '').toLowerCase() === '1');
        } catch {}
      }
      async function loadAutoTechPref() {
        if (!autoTechToggle) return;
        try {
          const key = encodeURIComponent(getAutoTechKey());
          const r = await fetch(`${PREF_ENDPOINT}?keys=${key}`, { cache: 'no-store' });
          const js = await r.json();
          const val = js && js.prefs ? js.prefs[getAutoTechKey()] : null;
          applyAutoTechState(String(val || '').toLowerCase() === '1');
        } catch {}
      }
      if (autoBasicToggle) autoBasicToggle.addEventListener('change', () => {
        const key = getAutoBasicKey();
        const on = isAutoBasicEnabled();
        try { queuePrefUpdate(key, on ? '1' : '0'); } catch {}
        ensureAutoCheckPoller();
      });
      if (autoTechToggle) autoTechToggle.addEventListener('change', () => {
        const key = getAutoTechKey();
        const on = isAutoTechEnabled();
        try { queuePrefUpdate(key, on ? '1' : '0'); } catch {}
        ensureAutoCheckPoller();
      });

      function ensureAutoCheckPoller() {
        if (!autoCheckPoller) {
          autoCheckPoller = setInterval(async () => {
            try {
              if (isAutoTechEnabled()) await refreshTechFreshness();
              if (isAutoBasicEnabled()) await refreshHealthFreshness();
            } catch {}
          }, 60000);
        }
      }
      ensureAutoCheckPoller();

      async function maybeAutoRunBasic(info) {
        if (!isAutoBasicEnabled()) return;
        const stale = info && info.status === 'stale' && Number(info.new_count || 0) > 0;
        if (!stale || autoBasicRunning) return;
        // Cooldown guard to protect provider quota
        const lastKey = getABasicLastKey();
        const lastAt = getLastAt(lastKey);
        if (Date.now() - lastAt < AUTO_BASIC_MIN_MS) return;
        autoBasicRunning = true;
        try {
          if (typeof setHealthFreshRunning === 'function') setHealthFreshRunning();
          await startHealthRun();
        } catch (e) {
          console.warn('[AutoCheck] Basic run failed', e);
        } finally {
          autoBasicRunning = false;
          setLastAt(lastKey, Date.now());
          try { await refreshHealthFreshness(); } catch {}
        }
      }

      async function maybeAutoRunTech(info) {
        if (!isAutoTechEnabled()) return;
        const stale = info && info.status === 'stale' && Number(info.outdated_bars || 0) > 0;
        if (!stale || autoTechRunning) return;
        // Cooldown guard to avoid repeated runs
        const lastKey = getATechLastKey();
        const lastAt = getLastAt(lastKey);
        if (Date.now() - lastAt < AUTO_TECH_MIN_MS) return;
        autoTechRunning = true;
        try {
          if (typeof setTechFreshRunning === 'function') setTechFreshRunning();
          await startTechAiRun();
        } catch (e) {
          console.warn('[AutoCheck] Tech run failed', e);
        } finally {
          autoTechRunning = false;
          setLastAt(lastKey, Date.now());
          try { await refreshTechFreshness(); } catch {}
        }
      }
      if (btnHealthStart) btnHealthStart.addEventListener('click', () => {
        const strat = (healthState && healthState.strategy) || '';
        if (strat === 'tech_snapshot_10q.json' || strat === 'tech_snapshot_10q_position.json') {
          startTechAiRun();
        } else {
          startHealthRun();
        }
      });
      if (btnHealthMore) btnHealthMore.addEventListener('click', ()=> { healthState.offset = (healthState.offset||0) + 5; loadHealthHistory(); });
      if (btnHealthClose) btnHealthClose.addEventListener('click', ()=> { const modal = el('healthModal'); if (modal) modal.style.display = 'none'; });
      if (btnTechHealth) btnTechHealth.addEventListener('click', openTechHealth);
      if (btnTechAiHealth) btnTechAiHealth.addEventListener('click', () => {
        // Open modal filtered to Tech strategy; wait for user to click Start
        const sym = symbolSelect.value.toUpperCase();
        const kind = isFxPair(sym) ? 'forex_pair' : 'stock';
        const techSel = document.getElementById('techAiStrategy');
        const techStrat = techSel && techSel.value ? techSel.value : 'tech_snapshot_10q.json';
        openHealth(kind, techStrat);
      });

      // Inline AI trade plan preview (below Buy/Sell buttons)
      let lastAiPlan = null;
      let aiPlanReqSeq = 0;
      const btnExecutePlan = document.getElementById('btnExecutePlan');
      const posSizeHint = document.getElementById('posSizeHint');
      let lastAccountBalance = null;
      let lastAccountCurrency = null;
      const updateExecuteBtn = () => {
        if (!btnExecutePlan) return;
        const ok = !!(lastAiPlan && lastAiPlan.position && (lastAiPlan.position === 'BUY' || lastAiPlan.position === 'SELL'));
        btnExecutePlan.disabled = !ok;
      };

      // Position size hint helpers
      const getLeverageValue = () => {
        const el = document.getElementById('aiLeverage');
        const raw = Number(el && el.value);
        return (Number.isFinite(raw) && raw > 0) ? raw : 10;
      };
      const getSafeLotsKey = () => `safe_max_lots:${currentSymbol()}:${currentTf()}`;
      const contractSizeForSymbol = (sym) => {
        const s = (sym || '').toUpperCase();
        if (/^[A-Z]{6,7}$/.test(s) && !s.startsWith('XAU') && !s.startsWith('XAG')) return 100000; // FX standard lot
        if (s.startsWith('XAU')) return 100; // Gold: 100 oz/lot
        if (s.startsWith('XAG')) return 5000; // Silver: 5000 oz/lot
        return 100; // default
      };
      const unitLabelForSymbol = (sym) => {
        const s = (sym || '').toUpperCase();
        if (s.startsWith('XAU') || s.startsWith('XAG')) return 'oz/lot';
        return 'units/lot';
      };
      const pipSizeForSymbol = (sym) => {
        const s = (sym || '').toUpperCase();
        if (s.startsWith('XAU') || s.startsWith('XAG')) return 0.01; // metals often 0.01
        // JPY quote pairs use 0.01 pip; others 0.0001
        const quote = s.slice(3,6);
        if (quote === 'JPY') return 0.01;
        return 0.0001;
      };
      const latestClose = () => {
        if (Array.isArray(lastPriceRows) && lastPriceRows.length) {
          const v = Number(lastPriceRows[lastPriceRows.length - 1]?.close);
          return Number.isFinite(v) ? v : null;
        }
        return null;
      };
      let __lastLoginSession = '';
      let __lastLoginFailUntil = 0;
      async function ensureSelectedAccountSession() {
        try {
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : (window.lastAccountPref || '');
          if (!acct || acct === __lastLoginSession) return;
          const now = Date.now();
          if (now < __lastLoginFailUntil) return;
          const rlogin = await fetch('/api/account/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ login: acct }), cache:'no-store' });
          const jlogin = await rlogin.json().catch(()=>({}));
          if (rlogin.ok && jlogin && jlogin.ok) {
            __lastLoginSession = acct;
            __lastLoginFailUntil = 0;
          } else {
            __lastLoginFailUntil = Date.now() + 30_000; // cooldown 30s
          }
        } catch {}
      }

      async function refreshAccountBalanceQuick() {
        try {
          await ensureSelectedAccountSession();
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : '';
          const url = acct ? `/api/account/balance_series?user=lachlan&limit=1&account=${encodeURIComponent(acct)}` : '/api/account/balance_series?user=lachlan&limit=1';
          const r = await fetch(url, { cache: 'no-store' });
          const js = await r.json().catch(()=>({}));
          const rows = Array.isArray(js.rows) ? js.rows : [];
          if (rows.length) {
            const last = rows[rows.length - 1];
            lastAccountBalance = Number(last.balance);
            lastAccountCurrency = last.currency || null;
          }
        } catch {}
      }
      function updatePositionSizeHint() {
        if (!posSizeHint) return;
        const sym = currentSymbol();
        const lev = getLeverageValue();
        const px = latestClose();
        const bal = Number(lastAccountBalance);
        if (!Number.isFinite(px) || !Number.isFinite(bal)) {
          posSizeHint.textContent = 'Position size: — (awaiting price/balance)';
          return;
        }
        const contract = contractSizeForSymbol(sym);
        const unitLbl = unitLabelForSymbol(sym);
        const denom = px * contract;
        const lots = denom > 0 ? (bal * lev) / denom : 0;
        const lotsStr = (lots || 0).toFixed(2);
        const pxStr = Number(px).toFixed(2);
        const cur = lastAccountCurrency ? lastAccountCurrency : '$';
        // Pip and move value references
        const pipSize = pipSizeForSymbol(sym);
        const moveValuePerLot = contract; // $ per 1.00 price unit move per lot
        const pipValuePerLot = contract * pipSize; // $ per pip per lot (approx for USD account)
        const pipValueStr = pipValuePerLot.toFixed(2);
        const moveValueStr = moveValuePerLot.toFixed(2);

        // Risk-based sizing
        const riskInput = document.getElementById('riskPercent');
        const riskVal = Number(riskInput && riskInput.value) || 1.0;
        const stopInput = document.getElementById('stopDistance');
        const stopUnitSel = document.getElementById('stopUnit');
        const stopUnit = (stopUnitSel && stopUnitSel.value) || 'price';
        const stopRaw = Number(stopInput && stopInput.value);
        const stop = Number.isFinite(stopRaw) && stopRaw > 0 ? stopRaw : 10;
        const riskAmt = bal * (riskVal/100);
        const riskPerLot = stopUnit === 'pips' ? (stop * pipValuePerLot) : (stop * moveValuePerLot);
        const riskLots = riskPerLot > 0 ? (riskAmt / riskPerLot) : 0;
        const riskLotsStr = riskLots.toFixed(2);
        const suggestedLots = Math.min(lots, riskLots);
        const suggestedStr = suggestedLots.toFixed(2);

        // Determine which safe lots to use for blowout calc: manual override if present
        const safeLotsEl = document.getElementById('safeMaxLotsInput');
        const manualLotsRaw = Number(safeLotsEl && safeLotsEl.value);
        const usedLots = (Number.isFinite(manualLotsRaw) && manualLotsRaw > 0) ? manualLotsRaw : (Number(lotsStr) || 0);
        let blowLongStr = '—', blowShortStr = '—';
        if (usedLots > 0 && contract > 0) {
          const blowMove = bal / (usedLots * contract); // price units
          const digits = priceDigits ? priceDigits(sym, isFxPair(sym) ? 'forex' : 'equity') : 2;
          const blowLong = px - blowMove;
          const blowShort = px + blowMove;
          blowLongStr = Number.isFinite(blowLong) ? blowLong.toFixed(digits) : '—';
          blowShortStr = Number.isFinite(blowShort) ? blowShort.toFixed(digits) : '—';
        }

        posSizeHint.innerHTML = `
          <div>${sym} • ${cur}${bal.toFixed(2)} × lev ${lev} ÷ (${pxStr} × ${contract.toLocaleString()} ${unitLbl}) ≈ ${lotsStr} lots (auto safe max)</div>
          <div>Risk-based lots: <strong>${riskLotsStr}</strong> (risk ${riskVal.toFixed(1)}%, stop ${stop} ${stopUnit})</div>
          <div>Suggested lots: <strong>${suggestedStr}</strong> (min of safe and risk)</div>
          <div style="opacity:0.8;">Ref: 1.00 price unit ≈ ${cur}${moveValueStr}/lot; 1 pip ≈ ${cur}${pipValueStr}/lot</div>
        `;
        const blowBox = document.getElementById('blowoutHint');
        if (blowBox) {
          blowBox.innerHTML = `Lose-all price (assuming <strong>${usedLots.toFixed(2)}</strong> lots): <strong>Long ≈ ${blowLongStr}</strong> • <strong>Short ≈ ${blowShortStr}</strong>`;
        }
        // Do not overwrite manual safe lots here; user can set it below.
        try { queuePrefUpdate(getLevKey(), String(lev)); } catch {}
        try { queuePrefUpdate(`risk_percent:${sym}:${currentTf()}`, String(riskVal)); } catch {}
        try { queuePrefUpdate(`stop_distance:${sym}:${currentTf()}`, String(stop)); } catch {}
        try { queuePrefUpdate(`stop_unit:${sym}:${currentTf()}`, String(stopUnit)); } catch {}
      }
      // Initialize balance and hook calculators (run after dependencies are defined)
      (async () => { try { await refreshAccountBalanceQuick(); } finally { updatePositionSizeHint(); } })();
      setInterval(() => { refreshAccountBalanceQuick().then(updatePositionSizeHint).catch(()=>{}); }, 60000);
      if (symbolSelect) symbolSelect.addEventListener('change', () => { updatePositionSizeHint(); });
      if (tfSelect) tfSelect.addEventListener('change', () => { updatePositionSizeHint(); });
      const aiLevEl = document.getElementById('aiLeverage');
      // Per-symbol×TF leverage preference
      const getLevKey = () => `ai_leverage:${currentSymbol()}:${currentTf()}`;
      async function loadLeveragePref() {
        if (!aiLevEl) return;
        try {
          const key = encodeURIComponent(getLevKey());
          const r = await fetch(`${PREF_ENDPOINT}?keys=${key}`, { cache: 'no-store' });
          const js = await r.json();
          const raw = js && js.prefs ? js.prefs[getLevKey()] : null;
          if (raw != null && raw !== '') {
            const num = Number(raw);
            if (Number.isFinite(num) && num > 0) {
              aiLevEl.value = String(num);
            }
          }
        } catch {}
        updatePositionSizeHint();
      }
      // Risk pref helpers
      const getRiskKey = () => `risk_percent:${currentSymbol()}:${currentTf()}`;
      const getStopKey = () => `stop_distance:${currentSymbol()}:${currentTf()}`;
      const getStopUnitKey = () => `stop_unit:${currentSymbol()}:${currentTf()}`;
      async function loadRiskPrefs() {
        const rEl = document.getElementById('riskPercent');
        const sEl = document.getElementById('stopDistance');
        const uEl = document.getElementById('stopUnit');
        try {
          const keys = [getRiskKey(), getStopKey(), getStopUnitKey()].map(encodeURIComponent).join(',');
          const r = await fetch(`${PREF_ENDPOINT}?keys=${keys}`, { cache: 'no-store' });
          const js = await r.json();
          const rp = js && js.prefs ? js.prefs[getRiskKey()] : null;
          const sd = js && js.prefs ? js.prefs[getStopKey()] : null;
          const su = js && js.prefs ? js.prefs[getStopUnitKey()] : null;
          if (rEl && rp != null) { const v = Number(rp); if (Number.isFinite(v)) { rEl.value = String(v); const lab = document.getElementById('riskPercentVal'); if (lab) lab.textContent = `${v.toFixed(1)}%`; } }
          if (sEl && sd != null) { const v = Number(sd); if (Number.isFinite(v) && v>0) sEl.value = String(v); }
          if (uEl && su != null) { uEl.value = String(su); }
        } catch {}
        updatePositionSizeHint();
      }
      if (aiLevEl) aiLevEl.addEventListener('input', () => {
        updatePositionSizeHint();
        try { queuePrefUpdate(getLevKey(), String(getLeverageValue())); } catch {}
      });
      // Load saved leverage on startup and whenever the symbol/TF changes
      loadLeveragePref();
      loadRiskPrefs();
      if (symbolSelect) symbolSelect.addEventListener('change', () => { loadLeveragePref(); loadRiskPrefs(); loadSafeLotsPref(); });
      if (tfSelect) tfSelect.addEventListener('change', () => { loadLeveragePref(); loadRiskPrefs(); loadSafeLotsPref(); });
      const riskEl = document.getElementById('riskPercent');
      const riskVal = document.getElementById('riskPercentVal');
      if (riskEl) riskEl.addEventListener('input', () => { if (riskVal) riskVal.textContent = `${Number(riskEl.value).toFixed(1)}%`; updatePositionSizeHint(); try { queuePrefUpdate(getRiskKey(), String(riskEl.value)); } catch {} });
      const stopEl = document.getElementById('stopDistance');
      if (stopEl) stopEl.addEventListener('input', () => { updatePositionSizeHint(); try { queuePrefUpdate(getStopKey(), String(stopEl.value)); } catch {} });
      const stopUnitEl = document.getElementById('stopUnit');
      if (stopUnitEl) stopUnitEl.addEventListener('change', () => { updatePositionSizeHint(); try { queuePrefUpdate(getStopUnitKey(), String(stopUnitEl.value)); } catch {} });
      // Safe max lots manual override
      const safeLotsEl = document.getElementById('safeMaxLotsInput');
      async function loadSafeLotsPref() {
        if (!safeLotsEl) return;
        try {
          const key = encodeURIComponent(getSafeLotsKey());
          const r = await fetch(`${PREF_ENDPOINT}?keys=${key}`, { cache: 'no-store' });
          const js = await r.json();
          const raw = js && js.prefs ? js.prefs[getSafeLotsKey()] : null;
          if (raw != null && raw !== '') {
            safeLotsEl.value = String(raw);
          } else {
            // Set a sensible default and persist it so other panels see it
            safeLotsEl.value = '0.10';
            try { queuePrefUpdate(getSafeLotsKey(), '0.10'); } catch {}
          }
        } catch {}
      }
      loadSafeLotsPref();
      if (safeLotsEl) {
        const saveSafeLots = () => {
          const v = Number(safeLotsEl.value);
          if (Number.isFinite(v) && v >= 0) {
            try { queuePrefUpdate(getSafeLotsKey(), String(v)); } catch {}
          }
          // Recompute hint (updates lose-all price instantly)
          try { updatePositionSizeHint(); } catch {}
        };
        safeLotsEl.addEventListener('input', saveSafeLots);
        safeLotsEl.addEventListener('change', saveSafeLots);
        safeLotsEl.addEventListener('blur', saveSafeLots);
      }
      async function updateAiPlanPreview() {
        const outBox = el('aiTradePlanBox');
        if (!outBox) return;
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const reqId = ++aiPlanReqSeq;
        const lev = getLeverageValue();
        outBox.textContent = 'Drafting plan…';
        try {
          const snapshot = buildTechSnapshotString();
          const side = (typeof tradeState !== 'undefined' && tradeState && tradeState.action) ? tradeState.action : 'BUY';
          const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
          const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (reqId !== aiPlanReqSeq || currentSymbol() !== sym || currentTf() !== tf) return;
          if (!r.ok || !js || js.ok !== true) { outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(js && js.error) || r.statusText || 'unknown'}</em>`; return; }
          const p = js.plan || {};
          lastAiPlan = { position: (p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: js.symbol, timeframe: js.timeframe };
          const enforced = js.enforced ? ' (risk cap applied)' : '';
          const created = js.created_at ? new Date(js.created_at).toLocaleString() : '';
          outBox.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center;">
            <strong>Plan</strong><span style="font-size:12px; color:var(--muted)">${esc(js.symbol)} ${esc(js.timeframe)} • lev ${esc(js.leverage)}${enforced}${created ? ` • ${esc(created)}` : ''}</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;">
            <span class="pill" style="background:${p.position==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${p.position==='BUY'?'#2ecc71':'#e74c3c'};">${esc(p.position||'')}</span>
            <span class="pill">SL: ${esc(p.stop_loss)}</span>
            <span class="pill">TP: ${esc(p.take_profit)}</span>
          </div>
          <div style="margin-top:6px; color:var(--muted);">${esc(p.explanation||'')}</div>`;
          try { loadAiPlanHistory(); } catch {}
          updateExecuteBtn();
          try { loadAiPlanHistory(); } catch {}
        } catch (e) {
          if (reqId !== aiPlanReqSeq || currentSymbol() !== sym || currentTf() !== tf) return;
          outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
          lastAiPlan = null; updateExecuteBtn();
        }
      }

      // Load latest existing AI trade plan for current symbol/TF (no new AI call)
      async function loadLatestAiPlanPreview() {
        const outBox = el('aiTradePlanBox');
        if (!outBox) return;
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) {
          const pq = splitPair(sym);
          params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote);
        } else {
          params.set('kind','stock'); params.set('symbol', sym);
        }
        params.set('limit','1');
        params.set('strategy','ai_trade_plan');
        params.set('tf', tf);
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = (js && js.runs) || [];
          if (!runs.length) { outBox.innerHTML = ''; try { await loadInlinePlanDropdown({ append:false }); } catch {} return; }
          const run = runs[0];
          const ans = run.answers || run.answers_json || {};
          const plan = ans.plan || {};
          const pos = (plan.position || '').toUpperCase();
          const enforced = (ans.meta && ans.meta.enforced) ? ' (risk cap applied)' : '';
          lastAiPlan = { position: pos, stop_loss: plan.stop_loss, take_profit: plan.take_profit, symbol: sym, timeframe: tf };
          const created = run.created_at ? new Date(run.created_at).toLocaleString() : '';
          outBox.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center;">
            <strong>Plan</strong><span style="font-size:12px; color:var(--muted)">${esc(sym)} ${esc(tf)}${enforced}${created ? ` • ${esc(created)}` : ''}</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;">
            <span class="pill" style="background:${pos==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${pos==='BUY'?'#2ecc71':'#e74c3c'};">${esc(pos || '-')}
            </span>
            <span class="pill">SL: ${esc(plan.stop_loss)}</span>
            <span class="pill">TP: ${esc(plan.take_profit)}</span>
          </div>
          <div style="margin-top:6px; color:var(--muted);">${esc(plan.explanation || '')}</div>`;
          updateExecuteBtn();
          // Sync the inline plan selector to latest
          try { inlinePlanOffset = 0; await loadInlinePlanDropdown({ append:false, selectRunId: run.id }); } catch {}
          try { loadAiPlanHistory(); } catch {}
        } catch (e) { outBox.innerHTML = ''; lastAiPlan = null; updateExecuteBtn(); }
      }

      // Inline AI Trade Plan dropdown (latest 5 with lazy load)
      let inlinePlanOffset = 0;
      const inlinePlanSelect = document.getElementById('inlinePlanSelect');
      const btnInlinePlanMore = document.getElementById('btnInlinePlanMore');
      async function loadInlinePlanDropdown({ append = false, selectRunId = null } = {}) {
        if (!inlinePlanSelect) return;
        const sym = currentSymbol();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
        else { params.set('kind','stock'); params.set('symbol', sym); }
        params.set('strategy','ai_trade_plan'); params.set('tf', tf); params.set('limit','5'); params.set('offset', String(inlinePlanOffset));
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = Array.isArray(js.runs) ? js.runs : [];
          if (!append) inlinePlanSelect.innerHTML = '';
          if (!runs.length && !append) { inlinePlanSelect.innerHTML = '<option value="">(no plans)</option>'; return; }
          const opts = runs.map(run => `<option value="${String(run.id)}">${esc(runIdLabel(run))}</option>`).join('');
          inlinePlanSelect.insertAdjacentHTML('beforeend', opts);
          // Default to latest or provided id
          if (!append) {
            const defVal = selectRunId ? String(selectRunId) : (runs.length ? String(runs[0].id) : '');
            if (defVal) inlinePlanSelect.value = defVal;
          } else if (selectRunId) {
            inlinePlanSelect.value = String(selectRunId);
          }
          // Render selected into the preview box and update lastAiPlan
          if (inlinePlanSelect.value) {
            const selectedId = Number(inlinePlanSelect.value);
            await renderInlineSelectedPlan(selectedId);
          }
        } catch {}
      }
      async function renderInlineSelectedPlan(runId) {
        const sym = currentSymbol();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
        else { params.set('kind','stock'); params.set('symbol', sym); }
        params.set('strategy','ai_trade_plan'); params.set('tf', tf); params.set('limit', String(inlinePlanOffset + 5)); params.set('offset','0');
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const all = Array.isArray(js.runs) ? js.runs : [];
          const run = all.find(x => Number(x.id) === Number(runId));
          if (!run) return;
          const ans = run.answers || run.answers_json || {};
          const p = ans.plan || {};
          const created = run.created_at ? new Date(run.created_at).toLocaleString() : '';
          const outBox = el('aiTradePlanBox');
          const enforced = (ans.meta && ans.meta.enforced) ? ' (risk cap applied)' : '';
          if (outBox) outBox.innerHTML = `<div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n            <strong>Plan</strong><span style=\"font-size:12px; color:var(--muted)\">${esc(sym)} ${esc(tf)}${enforced}${created ? ` • ${esc(created)}` : ''}</span>\n          </div>\n          <div style=\"margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;\">\n            <span class=\"pill\" style=\"background:${(p.position||'').toUpperCase()==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${(p.position||'').toUpperCase()==='BUY'?'#2ecc71':'#e74c3c'};\">${esc((p.position||'').toUpperCase())}</span>\n            <span class=\"pill\">SL: ${esc(p.stop_loss)}</span>\n            <span class=\"pill\">TP: ${esc(p.take_profit)}</span>\n          </div>\n          <div style=\"margin-top:6px; color:var(--muted);\">${esc(p.explanation||'')}</div>`;
          // Update execute button context
          lastAiPlan = { position: String(p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: sym, timeframe: tf };
          updateExecuteBtn();
        } catch {}
      }
      if (inlinePlanSelect) inlinePlanSelect.addEventListener('change', () => { const v = Number(inlinePlanSelect.value); if (Number.isFinite(v)) renderInlineSelectedPlan(v); });
      if (btnInlinePlanMore) btnInlinePlanMore.addEventListener('click', async () => { inlinePlanOffset += 5; await loadInlinePlanDropdown({ append: true }); });

      // Dedicated AI Trade Plan history (separate from Basic/Tech history)
      async function loadAiPlanHistory(limit=5, offset=0) {
        const box = el('aiPlanHistoryBox');
        if (!box) return;
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
        else { params.set('kind','stock'); params.set('symbol', sym); }
        params.set('strategy','ai_trade_plan'); params.set('tf', tf); params.set('limit', String(limit)); params.set('offset', String(offset));
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = Array.isArray(js.runs) ? js.runs : [];
          if (!runs.length && offset === 0) { box.innerHTML = '<em style="color:var(--muted)">No recent AI plans</em>'; return; }
          const html = runs.map((r) => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ans = r.answers || {};
            const plan = ans.plan || {};
            const pos = (plan.position || '').toUpperCase();
            const sl = plan.stop_loss; const tp = plan.take_profit;
            const posPill = pos ? `<span class=\"pill\" style=\"background:${pos==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${pos==='BUY'?'#2ecc71':'#e74c3c'};\">${pos}</span>` : '';
            return `<div class=\"row\" style=\"justify-content:space-between; border:1px dashed var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n              <span style=\"font-size:12px; color:var(--muted);\">${t}</span>\n              <span>${posPill} <span style=\"font-size:12px; color:var(--muted);\">SL ${esc(sl)} • TP ${esc(tp)}</span></span>\n            </div>`;
          }).join('');
          if (offset === 0) box.innerHTML = '';
          if (html) box.insertAdjacentHTML('beforeend', html);
        } catch (e) { if (offset === 0) box.innerHTML = '<em style="color:var(--muted)">Failed to load</em>'; }
      }
      async function runAiTradePlan(side) {
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const lev = getLeverageValue();
        const outBox = tradeResultsBox;
        if (outBox) outBox.textContent = 'Drafting plan…';
        try {
          const snapshot = buildTechSnapshotString();
          const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
          if (Number.isFinite(Number(tradeState.basicRunId))) body.basic_run_id = Number(tradeState.basicRunId);
          if (Number.isFinite(Number(tradeState.techRunId))) body.tech_run_id = Number(tradeState.techRunId);
          const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (!r.ok || !js || js.ok !== true) { if (outBox) outBox.innerHTML = `<em style=color:var(--sell)>Failed: ${(js && js.error) || r.statusText || 'unknown'}</em>`; return; }
          const p = js.plan || {};
          const enforced = js.enforced ? ' (risk cap applied)' : '';
          const created = js.created_at ? new Date(js.created_at).toLocaleString() : '';
          if (outBox) outBox.innerHTML = `<div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n            <strong>Plan</strong><span style=\"font-size:12px; color:var(--muted)\">${esc(js.symbol)} ${esc(js.timeframe)} • lev ${esc(js.leverage)}${enforced}${created ? ` • ${esc(created)}` : ''}</span>\n          </div>\n          <div style=\"margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;\">\n            <span class=\"pill\" style=\"background:${p.position==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${p.position==='BUY'?'#2ecc71':'#e74c3c'};\">${esc(p.position||'')}</span>\n            <span class=\"pill\">SL: ${esc(p.stop_loss)}</span>\n            <span class=\"pill\">TP: ${esc(p.take_profit)}</span>\n          </div>\n          <div style=\"margin-top:6px; color:var(--muted);\">${esc(p.explanation||'')}</div>`;
          // Update inline preview cache and Execute button
          lastAiPlan = { position: (p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: js.symbol, timeframe: js.timeframe };
          updateExecuteBtn();
          tradeState.offset = 0;
          loadTradeHistory();
          try { loadAiPlanHistory(); } catch {}
        } catch (e) {
          if (outBox) outBox.innerHTML = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
        }
      }
      function runIdLabel(run) {
        try {
          const t = run.created_at ? new Date(run.created_at).toLocaleString() : '';
          const ans = run.answers || run.answers_json || {};
          // Prefer position from plan (BUY/SELL). Fallback to generic signal. Default to NEUTRAL when missing.
          let sig = '';
          try { sig = (ans.plan && ans.plan.position ? String(ans.plan.position) : String(ans.signal || '')).toUpperCase(); } catch {}
          if (!sig) sig = 'NEUTRAL';
          const sc = (ans.score ?? (ans.scores && ans.scores.NET)) ?? '';
          const strat = ans.strategy || '';
          const parts = [];
          if (t) parts.push(t);
          if (sig) parts.push(String(sig));
          if (sc !== '') parts.push(`NET=${sc}`);
          if (strat) parts.push(strat);
          return parts.join(' • ');
        } catch { return 'run'; }
      }
      let planSelectOffset = 0;
      async function loadPlanDropdown({ append = false, selectRunId = null } = {}) {
        if (!planSelect) return;
        const sym = currentSymbol();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
        else { params.set('kind','stock'); params.set('symbol', sym); }
        params.set('strategy','ai_trade_plan'); params.set('tf', tf); params.set('limit','5'); params.set('offset', String(planSelectOffset));
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = Array.isArray(js.runs) ? js.runs : [];
          if (!append) planSelect.innerHTML = '';
          if (!runs.length && !append) {
            planSelect.innerHTML = '<option value="">(no plans)</option>';
            return;
          }
          const opts = runs.map(run => `<option value="${String(run.id)}">${esc(runIdLabel(run))}</option>`).join('');
          planSelect.insertAdjacentHTML('beforeend', opts);
          // Default to latest when first load, or to provided run id
          if (!append) {
            const defVal = selectRunId ? String(selectRunId) : (runs.length ? String(runs[0].id) : '');
            if (defVal) planSelect.value = defVal;
          } else if (selectRunId) {
            planSelect.value = String(selectRunId);
          }
          // Render the selected plan
          if (planSelect.value) {
            const selectedId = Number(planSelect.value);
            await renderSelectedPlan(selectedId);
          }
        } catch (e) {
          /* ignore */
        }
      }
      async function renderSelectedPlan(runId) {
        const sym = currentSymbol();
        const tf = currentTf();
        // We already have the run list in the dropdown; in absence of a direct by-id API, fetch the window and pick the selected
        const params = new URLSearchParams();
        if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
        else { params.set('kind','stock'); params.set('symbol', sym); }
        params.set('strategy','ai_trade_plan'); params.set('tf', tf); params.set('limit', String(planSelectOffset + 5)); params.set('offset','0');
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const all = Array.isArray(js.runs) ? js.runs : [];
          const run = all.find(x => Number(x.id) === Number(runId));
          if (!run) return;
          const ans = run.answers || run.answers_json || {};
          const p = ans.plan || {};
          const created = run.created_at ? new Date(run.created_at).toLocaleString() : '';
          const outBox = el('tradeResultsBox');
          const enforced = (ans.meta && ans.meta.enforced) ? ' (risk cap applied)' : '';
          if (outBox) outBox.innerHTML = `<div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n            <strong>Plan</strong><span style=\"font-size:12px; color:var(--muted)\">${esc(sym)} ${esc(tf)}${enforced}${created ? ` • ${esc(created)}` : ''}</span>\n          </div>\n          <div style=\"margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;\">\n            <span class=\"pill\" style=\"background:${(p.position||'').toUpperCase()==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${(p.position||'').toUpperCase()==='BUY'?'#2ecc71':'#e74c3c'};\">${esc((p.position||'').toUpperCase())}</span>\n            <span class=\"pill\">SL: ${esc(p.stop_loss)}</span>\n            <span class=\"pill\">TP: ${esc(p.take_profit)}</span>\n          </div>\n          <div style=\"margin-top:6px; color:var(--muted);\">${esc(p.explanation||'')}</div>`;
          // Sync Execute Plan state
          lastAiPlan = { position: String(p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: sym, timeframe: tf };
          updateExecuteBtn();
        } catch (e) { /* ignore */ }
      }
      async function loadTradeSourceDropdowns() {
        const sym = currentSymbol();
        const tf = currentTf();
        const basicSel = el('selectBasicRun');
        const techSel = el('selectTechRun');
        // Basic
        try {
          const p = new URLSearchParams();
          if (isFxPair(sym)) { const pq = splitPair(sym); p.set('kind','forex_pair'); p.set('base', pq.base); p.set('quote', pq.quote); }
          else { p.set('kind','stock'); p.set('symbol', sym); }
          p.set('limit','5'); p.set('group','basic'); p.set('tf', tf);
          let r = await fetch(`/api/health/runs?${p.toString()}`, { cache:'no-store' });
          let js = await r.json().catch(()=>({}));
          let runs = Array.isArray(js.runs) ? js.runs : [];
          // Fallback: drop tf filter if none
          if (!runs.length) {
            const p2 = new URLSearchParams(p.toString());
            p2.delete('tf');
            r = await fetch(`/api/health/runs?${p2.toString()}`, { cache:'no-store' });
            js = await r.json().catch(()=>({}));
            runs = Array.isArray(js.runs) ? js.runs : [];
          }
          // Fallback: ask explicitly for default basic strategy if still empty
          if (!runs.length) {
            const p3 = new URLSearchParams();
            if (isFxPair(sym)) { const pq = splitPair(sym); p3.set('kind','forex_pair'); p3.set('base', pq.base); p3.set('quote', pq.quote); }
            else { p3.set('kind','stock'); p3.set('symbol', sym); }
            p3.set('limit','5');
            const preferMetal = isFxPair(sym) && isMetalPair(sym);
            p3.set('strategy', preferMetal ? 'metal_pair_compact_10q_position.json' : 'stocks_compact_10q_position.json');
            r = await fetch(`/api/health/runs?${p3.toString()}`, { cache:'no-store' });
            js = await r.json().catch(()=>({}));
            runs = Array.isArray(js.runs) ? js.runs : [];
          }
          if (basicSel) {
            basicSel.innerHTML = runs.map(run => `<option value="${String(run.id)}">${esc(runIdLabel(run))}</option>`).join('');
            tradeState.basicRunId = runs.length ? runs[0].id : null;
            basicSel.onchange = () => { const v = Number(basicSel.value); tradeState.basicRunId = Number.isFinite(v)? v : null; };
          }
        } catch {}
        // Tech
        try {
          const p2 = new URLSearchParams();
          if (isFxPair(sym)) { const pq = splitPair(sym); p2.set('kind','forex_pair'); p2.set('base', pq.base); p2.set('quote', pq.quote); }
          else { p2.set('kind','stock'); p2.set('symbol', sym); }
          p2.set('limit','5'); p2.set('group','tech'); p2.set('tf', tf);
          let r2 = await fetch(`/api/health/runs?${p2.toString()}`, { cache:'no-store' });
          let js2 = await r2.json().catch(()=>({}));
          let runs2 = Array.isArray(js2.runs) ? js2.runs : [];
          // Fallback: drop tf filter
          if (!runs2.length) {
            const p4 = new URLSearchParams(p2.toString()); p4.delete('tf');
            r2 = await fetch(`/api/health/runs?${p4.toString()}`, { cache:'no-store' });
            js2 = await r2.json().catch(()=>({}));
            runs2 = Array.isArray(js2.runs) ? js2.runs : [];
          }
          if (techSel) {
            techSel.innerHTML = runs2.map(run => `<option value="${String(run.id)}">${esc(runIdLabel(run))}</option>`).join('');
            tradeState.techRunId = runs2.length ? runs2[0].id : null;
            techSel.onchange = () => { const v = Number(techSel.value); tradeState.techRunId = Number.isFinite(v)? v : null; };
          }
        } catch {}
      }
      async function newBasicCheckForTrade() {
        const sym = currentSymbol();
        const tf = currentTf();
        const body = { symbol: sym, timeframe: tf };
        try {
          const res = await fetch('/api/health/run', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await res.json().catch(()=>({}));
          if (js && js.ok && js.run_id) {
            await loadTradeSourceDropdowns();
            const basicSel = el('selectBasicRun');
            if (basicSel) { basicSel.value = String(js.run_id); basicSel.dispatchEvent(new Event('change')); }
            return js.run_id;
          }
        } catch {}
        return null;
      }
      async function newTechCheckForTrade() {
        const sym = currentSymbol();
        const tf = currentTf();
        try {
          const snapshot = buildTechSnapshotString();
          const body = { symbol: sym, timeframe: tf, tech_snapshot: snapshot, strategy: 'tech_snapshot_10q_position.json' };
          const techModelSel = document.getElementById('techAiModel');
          const techModel = techModelSel && techModelSel.value ? techModelSel.value : '';
          if (techModel) body.model = techModel;
          const res = await fetch('/api/health/run', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await res.json().catch(()=>({}));
          if (js && js.ok && js.run_id) {
            await loadTradeSourceDropdowns();
            const techSel = el('selectTechRun');
            if (techSel) { techSel.value = String(js.run_id); techSel.dispatchEvent(new Event('change')); }
            return js.run_id;
          }
        } catch {}
        return null;
      }
      function openTradePlan(action) {
        tradeState.action = action || 'BUY';
        tradeState.offset = 0;
        if (tradeInfo) tradeInfo.textContent = `${currentSymbol()} • TF ${currentTf()}`;
        if (tradeResultsBox) tradeResultsBox.innerHTML = '';
        if (autoLogBox) autoLogBox.innerHTML = '';
        tradeState.autoSteps = [];
        if (tradeModal) tradeModal.style.display = 'flex';
        loadTradeSourceDropdowns();
        planSelectOffset = 0;
        loadPlanDropdown({ append: false });
        loadTradeHistory();
        try { loadAccountsSelect(); } catch {}
      }
      async function loadTradeHistory() {
        if (!tradeHistoryBox) return;
        if ((tradeState.offset||0) === 0) tradeHistoryBox.innerHTML = '<em style="color:var(--muted)">Loading…</em>';
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) {
          const pq = splitPair(sym);
          params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote);
        } else {
          params.set('kind','stock'); params.set('symbol', sym);
        }
        params.set('limit','5'); params.set('offset', String(tradeState.offset||0));
        params.set('strategy','ai_trade_plan');
        params.set('tf', tf);
        try {
          const res = await fetch(`/api/health/runs?${params.toString()}`);
          const data = await res.json();
          const runs = (data && data.runs) || [];
          if (!runs.length && (tradeState.offset||0) === 0) { tradeHistoryBox.innerHTML = '<em style="color:var(--muted)">No recent plans</em>'; return; }
          if ((tradeState.offset||0) === 0) { tradeHistoryBox.innerHTML = ''; }
          const html = runs.map((r) => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ans = r.answers || r.answers_json || {};
            const plan = ans.plan || {};
            const pos = (plan.position || '').toUpperCase();
            const sl = plan.stop_loss;
            const tp = plan.take_profit;
            const posPill = pos ? `<span class=\"pill\" style=\"background:${pos==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${pos==='BUY'?'#2ecc71':'#e74c3c'};\">${pos}</span>` : '';
            return `<div class=\"row\" style=\"justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n              <span style=\"font-size:13px; color:var(--muted);\">${t}</span>\n              <span>${posPill} <span style=\"font-size:12px; color:var(--muted);\">SL ${esc(sl)} • TP ${esc(tp)}</span></span>\n            </div>`;
          }).join('');
          tradeHistoryBox.insertAdjacentHTML('beforeend', html);
        } catch (e) {
          tradeHistoryBox.innerHTML = '<em style="color:var(--muted)">Failed to load</em>';
        }
      }
      if (btnAiBuySell) btnAiBuySell.addEventListener('click', ()=> openTradePlan('BUY'));
      const btnNewBasicRun = document.getElementById('btnNewBasicRun');
      const btnNewTechRun = document.getElementById('btnNewTechRun');
      if (btnNewBasicRun) btnNewBasicRun.addEventListener('click', newBasicCheckForTrade);
      if (btnNewTechRun) btnNewTechRun.addEventListener('click', newTechCheckForTrade);
      if (planSelect) planSelect.addEventListener('change', () => { const v = Number(planSelect.value); if (Number.isFinite(v)) renderSelectedPlan(v); });
      if (btnPlanMore) btnPlanMore.addEventListener('click', () => { planSelectOffset += 5; loadPlanDropdown({ append: true }); });
      if (btnTradeStartBuy) btnTradeStartBuy.addEventListener('click', ()=> runAiTradePlan('BUY'));
      if (btnTradeStartSell) btnTradeStartSell.addEventListener('click', ()=> runAiTradePlan('SELL'));
      if (btnTradeClose) btnTradeClose.addEventListener('click', ()=> { if (tradeModal) tradeModal.style.display = 'none'; });
      if (btnTradeMore) btnTradeMore.addEventListener('click', ()=> { tradeState.offset = (tradeState.offset||0) + 5; loadTradeHistory(); });
      // Auto AI Trade entry — add visible logs and a safe fallback opener
      function openAutoModalSafe() {
        try {
          status('Opening Auto AI Trade…');
          if (typeof openAutoModal === 'function') {
            openAutoModal();
            return;
          }
        } catch (e) {
          debugWarn('[Auto] openAutoModal threw before open:', e);
        }
        // Fallback: minimally show the modal if helper is not yet defined
        try {
          const m = document.getElementById('autoModal');
          if (m) {
            m.style.display = 'flex';
            m.setAttribute('aria-hidden', 'false');
            const logBox = document.getElementById('autoLogBoxModal');
            if (logBox) {
              logBox.innerHTML = '';
              logBox.insertAdjacentHTML('beforeend', '<div>[Auto] Modal opened (fallback)</div>');
            }
            const s = document.getElementById('btnAutoStart');
            if (s) { try { s.focus(); } catch {} }
            // Populate history when using fallback path
            try {
              autoHistoryOffset = 0;
              const box = document.getElementById('autoHistoryBox');
              if (box) box.innerHTML = '<em style="color:var(--muted)">Loading…</em>';
              loadAutoHistory(5, 0);
              try { updateAutoMirrors(); } catch {}
            } catch {}
          }
        } catch {}
      }
      if (btnAutoAiTrade) btnAutoAiTrade.addEventListener('click', openAutoModalSafe);
      // Mirror Basic/Tech/Plan settings into Auto modal (display-only)
      async function updateAutoMirrors() {
        const sym = currentSymbol();
        const tf = currentTf();
        const basicSel = document.getElementById('autoMirrorBasic');
        const techSel = document.getElementById('autoMirrorTech');
        const planSchemaSel = document.getElementById('autoPlanSchemaMirror');
        // Plan schema mirror from main plan selector
        try {
          const mainPlanSchema = document.getElementById('tradePlanSchema');
          if (planSchemaSel && mainPlanSchema) {
            planSchemaSel.innerHTML = mainPlanSchema.innerHTML;
            planSchemaSel.value = mainPlanSchema.value;
          }
        } catch {}
        // Basic runs (latest 5)
        try {
          const p = new URLSearchParams();
          if (isFxPair(sym)) { const pq = splitPair(sym); p.set('kind','forex_pair'); p.set('base', pq.base); p.set('quote', pq.quote); }
          else { p.set('kind','stock'); p.set('symbol', sym); }
          p.set('group','basic'); p.set('tf', tf); p.set('limit','5'); p.set('offset','0');
          const r = await fetch(`/api/health/runs?${p.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = Array.isArray(js.runs) ? js.runs : [];
          if (basicSel) {
            basicSel.innerHTML = runs.map(run => `<option value="${String(run.id)}">${esc(runIdLabel(run))}</option>`).join('') || '<option value="">(none)</option>';
            if (runs.length) basicSel.value = String(runs[0].id);
          }
        } catch {}
        // Tech runs (latest 5 for tech snapshot)
        try {
          const p = new URLSearchParams();
          if (isFxPair(sym)) { const pq = splitPair(sym); p.set('kind','forex_pair'); p.set('base', pq.base); p.set('quote', pq.quote); }
          else { p.set('kind','stock'); p.set('symbol', sym); }
          p.set('strategy','tech_snapshot_10q_position.json'); p.set('tf', tf); p.set('limit','5'); p.set('offset','0');
          const r = await fetch(`/api/health/runs?${p.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = Array.isArray(js.runs) ? js.runs : [];
          if (techSel) {
            techSel.innerHTML = runs.map(run => `<option value="${String(run.id)}">${esc(runIdLabel(run))}</option>`).join('') || '<option value="">(none)</option>';
            if (runs.length) techSel.value = String(runs[0].id);
          }
        } catch {}
      }
      function setAutoMirrorFreshness(basicFresh, techFresh) {
        try {
          // Accept either status strings or full freshness objects
          const norm = (v) => {
            if (!v) return { status: 'unknown' };
            if (typeof v === 'string') return { status: v };
            if (typeof v === 'object') return v;
            return { status: String(v) };
          };
          const b = norm(basicFresh);
          const t = norm(techFresh);
          const basicStatus = String((b.status||'')).toLowerCase();
          const techStatus  = String((t.status||'')).toLowerCase();
          const basicNewRaw = (b.new_count != null ? Number(b.new_count) : (b.new != null ? Number(b.new) : null));
          const techOutRaw  = (t.outdated_bars != null ? Number(t.outdated_bars) : (t.outdated != null ? Number(t.outdated) : null));
          const hasBasicNew = Number.isFinite(basicNewRaw);
          const hasTechOut  = Number.isFinite(techOutRaw);
          const basicIsStale = (basicStatus === 'stale') || (hasBasicNew && basicNewRaw > 0);
          const techIsStale  = (techStatus  === 'stale') || (hasTechOut  && techOutRaw  > 0);
          const basicIsFresh = (basicStatus === 'fresh') || (hasBasicNew && basicNewRaw === 0);
          const techIsFresh  = (techStatus  === 'fresh') || (hasTechOut  && techOutRaw  === 0);

          const bRow = document.getElementById('autoMirrorBasicRow');
          const tRow = document.getElementById('autoMirrorTechRow');
          if (bRow) { bRow.classList.toggle('stale-row', !!basicIsStale); bRow.classList.toggle('fresh-row', !!basicIsFresh && !basicIsStale); }
          if (tRow) { tRow.classList.toggle('stale-row', !!techIsStale);  tRow.classList.toggle('fresh-row',  !!techIsFresh && !techIsStale); }
          const bBad = document.getElementById('autoMirrorBasicStale');
          const tBad = document.getElementById('autoMirrorTechStale');
          const bFresh = document.getElementById('autoMirrorBasicFresh');
          const tFresh = document.getElementById('autoMirrorTechFresh');
          if (bBad) bBad.style.display = basicIsStale ? 'inline-block' : 'none';
          if (tBad) tBad.style.display = techIsStale  ? 'inline-block' : 'none';
          if (bFresh) bFresh.style.display = (basicIsFresh && !basicIsStale) ? 'inline-block' : 'none';
          if (tFresh) tFresh.style.display = (techIsFresh  && !techIsStale)  ? 'inline-block' : 'none';
        } catch {}
      }
      // Keep plan schema mirror synced if user changes it in the plan modal
      (function(){ const mainPlanSchema = document.getElementById('tradePlanSchema'); if (mainPlanSchema) mainPlanSchema.addEventListener('change', ()=>{ try { updateAutoMirrors(); } catch {} }); })();
      if (btnAutoClose) btnAutoClose.addEventListener('click', () => {
        if (autoModal) {
          autoModal.style.display = 'none';
          autoModal.setAttribute('aria-hidden', 'true');
        }
        const t = document.getElementById('btnAutoAiTrade');
        if (t) { try { t.focus(); } catch {} }
      });
      if (btnAutoStart) btnAutoStart.addEventListener('click', autoAiTrade);
      if (btnAutoMore) btnAutoMore.addEventListener('click', () => { autoHistoryOffset += 5; loadAutoHistory(5, autoHistoryOffset); });
      // Persist/load Auto SL scale preference per symbol×TF
      (function(){
        const slScaleEl = document.getElementById('autoSlScaleInput');
        if (!slScaleEl) return;
        const key = () => `auto_sl_scale:${currentSymbol()}:${currentTf()}`;
        const save = () => { const v = Number(slScaleEl.value||''); if (Number.isFinite(v) && v>0) { try { queuePrefUpdate(key(), String(v)); flushPrefQueue(); appendAutoLog(`SL scale set to ${v}`); } catch {} } };
        slScaleEl.addEventListener('change', save);
        slScaleEl.addEventListener('blur', save);
        // Load existing
        (async () => { try { const r = await fetch(`/api/preferences?keys=${encodeURIComponent(key())}`, { cache:'no-store' }); const js = await r.json().catch(()=>({})); const val = js && js.prefs ? js.prefs[key()] : null; if (val) slScaleEl.value = String(val); } catch {} })();
      })();
      // Accounts UI
      const btnAddAccountOpen = document.getElementById('btnAddAccountOpen');
      const addAccountModal = document.getElementById('addAccountModal');
      const btnAddAccountClose = document.getElementById('btnAddAccountClose');
      const btnAcctSave = document.getElementById('btnAcctSave');
      const btnAcctDelete = document.getElementById('btnAcctDelete');
      const btnAcctCancel = document.getElementById('btnAcctCancel');
      const autoAccountSelect = document.getElementById('autoAccountSelect');
      const tradeAccountSelect = document.getElementById('tradeAccountSelect'); // (modal, may be absent)
      const tradeAccountSelectInline = document.getElementById('tradeAccountSelectInline');
      // Periodic auto-trade inline controls
      const autoPeriodicAccountSelect = document.getElementById('autoPeriodicAccountSelect');
      const autoPeriodicToggle = document.getElementById('autoPeriodicToggle');
      const autoPeriodicPeriod = document.getElementById('autoPeriodicPeriod');
      const autoPeriodicVolumeInput = document.getElementById('autoPeriodicVolumeInput');
      const autoPeriodicSafeMaxInput = document.getElementById('autoPeriodicSafeMaxInput');
      const autoPeriodicSlToggle = document.getElementById('autoPeriodicSlToggle');
      const addAcctSelect = document.getElementById('addAcctSelect');
      const acctLoginInput = document.getElementById('acctLogin');
      const acctPasswordInput = document.getElementById('acctPassword');
      const acctServerInput = document.getElementById('acctServer');
      let accountsCache = [];
      let lastAccountPref = '';
      function setAllAccountSelects(value) {
        [autoAccountSelect, tradeAccountSelect, tradeAccountSelectInline, autoPeriodicAccountSelect].forEach(sel => {
          try { if (sel && value) sel.value = value; } catch {}
        });
      }
      function resolveSelectedAccountValue() {
        const fromInline = tradeAccountSelectInline && tradeAccountSelectInline.value;
        const fromPeriodic = autoPeriodicAccountSelect && autoPeriodicAccountSelect.value;
        const fromAuto = autoAccountSelect && autoAccountSelect.value;
        const fromModal = tradeAccountSelect && tradeAccountSelect.value;
        return String(fromInline || fromPeriodic || fromAuto || fromModal || lastAccountPref || '').trim();
      }
      async function loadAccountsSelect() {
        try {
          const r = await fetch('/api/accounts', { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const arr = Array.isArray(js.accounts) ? js.accounts : [];
          let last = js.last || '';
          // Fallback to prefs if API did not return last
          if (!last) {
            try {
              const pr = await fetch(`${PREF_ENDPOINT}?keys=last_account`, { cache:'no-store' });
              const pj = await pr.json().catch(()=>({}));
              const m = (pj && pj.prefs) || pj || {};
              last = m.last_account || '';
            } catch {}
          }
          lastAccountPref = last || '';
          const fill = (sel) => {
            if (!sel) return;
            sel.innerHTML = arr.length ? '' : '<option value="">(none)</option>';
            let picked = '';
            for (const a of arr) {
              const v = String(a.login||'');
              const opt = document.createElement('option');
              opt.value = v;
              opt.textContent = a.server ? `${v} (${a.server})` : v;
              sel.appendChild(opt);
              if (!picked) picked = v;
            }
            if (last) picked = last;
            if (picked) sel.value = picked;
          };
          fill(autoAccountSelect);
          fill(tradeAccountSelect);
          fill(tradeAccountSelectInline);
          fill(autoPeriodicAccountSelect);
          // After fill, ensure all selects show same last account for visual sync
          if (last) setAllAccountSelects(last);
          if (last) {
            try { await refreshAccountDependentPanels(); } catch {}
          }
        } catch {}
      }
      function findAccountInCache(login) {
        const target = String(login || '').trim();
        if (!target) return null;
        return accountsCache.find(a => String(a.login || '').trim() === target) || null;
      }
      function applyAccountToForm(login) {
        if (acctLoginInput) acctLoginInput.value = String(login || '');
        const rec = findAccountInCache(login);
        if (acctPasswordInput) acctPasswordInput.value = rec && rec.password ? rec.password : '';
        if (acctServerInput) acctServerInput.value = rec && rec.server ? rec.server : (acctServerInput.value || '');
      }
      async function loadAccountsIntoAddModal(preselect) {
        if (!addAcctSelect) return;
        try {
          const r = await fetch('/api/accounts?include_password=1', { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          accountsCache = Array.isArray(js.accounts) ? js.accounts : [];
          const last = preselect || js.last || '';
          addAcctSelect.innerHTML = '';
          const newOpt = document.createElement('option');
          newOpt.value = '';
          newOpt.textContent = 'Add new account...';
          addAcctSelect.appendChild(newOpt);
          let picked = '';
          for (const a of accountsCache) {
            const login = String(a.login || '');
            if (!login) continue;
            const opt = document.createElement('option');
            opt.value = login;
            opt.textContent = a.server ? `${login} (${a.server})` : login;
            addAcctSelect.appendChild(opt);
            if (!picked) picked = login;
          }
          if (last) picked = last;
          addAcctSelect.value = picked;
        } catch {
          accountsCache = [];
          addAcctSelect.innerHTML = '<option value=\"\">Add new account...</option>';
        }
        const selected = addAcctSelect.value || '';
        if (!selected && preselect) {
          applyAccountToForm(preselect);
        } else {
          applyAccountToForm(selected);
        }
        // Toggle delete availability
        if (btnAcctDelete) btnAcctDelete.disabled = !selected;
      }
      async function openAddAccount() {
        if (addAccountModal) {
          addAccountModal.style.display = 'flex';
          addAccountModal.setAttribute('aria-hidden','false');
          const current = resolveSelectedAccountValue();
          try { await loadAccountsIntoAddModal(current); } catch {}
          setTimeout(()=>{ if (acctLoginInput) acctLoginInput.focus(); }, 0);
        }
      }
      function closeAddAccount() { if (addAccountModal) { addAccountModal.style.display = 'none'; addAccountModal.setAttribute('aria-hidden','true'); } }
      if (btnAddAccountOpen) btnAddAccountOpen.addEventListener('click', openAddAccount);
      if (btnAddAccountClose) btnAddAccountClose.addEventListener('click', closeAddAccount);
      if (btnAcctCancel) btnAcctCancel.addEventListener('click', closeAddAccount);
      if (btnAcctSave) btnAcctSave.addEventListener('click', async ()=>{
        const login = String((document.getElementById('acctLogin')||{}).value||'').trim();
        const password = String((document.getElementById('acctPassword')||{}).value||'').trim();
        const server = String((document.getElementById('acctServer')||{}).value||'').trim();
        const selectedExisting = addAcctSelect ? String(addAcctSelect.value||'').trim() : '';
        if (!login || !password) { alert('Login and password required'); return; }
        try {
          const body = { login, password, server };
          if (selectedExisting) body.old_login = selectedExisting;
          const r = await fetch('/api/accounts', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
          const js = await r.json().catch(()=>({}));
          if (!r.ok || !js.ok) { alert('Failed to save account'); return; }
          closeAddAccount();
          await loadAccountsSelect();
          await loadAccountsIntoAddModal(login);
          setAllAccountSelects(login);
          try { await refreshAccountDependentPanels(); } catch {}
          // Persist selection as last_account in preferences
          try { persistLastAccount(login); } catch {}
        } catch { alert('Failed to save account'); }
      });
      if (addAcctSelect) addAcctSelect.addEventListener('change', ()=>{ applyAccountToForm(addAcctSelect.value || ''); if (btnAcctDelete) btnAcctDelete.disabled = !(addAcctSelect.value||''); });
      if (btnAcctDelete) btnAcctDelete.addEventListener('click', async ()=>{
        const target = addAcctSelect ? String(addAcctSelect.value||'').trim() : '';
        if (!target) return;
        if (!window.confirm(`Delete account ${target}?`)) return;
        try {
          const r = await fetch(`/api/accounts?login=${encodeURIComponent(target)}`, { method:'DELETE', cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (!r.ok || !js.ok) { alert('Failed to delete account'); return; }
          // Reload selects and modal list; pick new last from server
          await loadAccountsSelect();
          await loadAccountsIntoAddModal('');
          setAllAccountSelects(lastAccountPref || '');
          try { await refreshAccountDependentPanels(); } catch {}
        } catch { alert('Failed to delete account'); }
      });
      function persistLastAccount(v) { if (v) { lastAccountPref = v; queuePrefUpdate('last_account', v); try { flushPrefQueue(); } catch {} } }
      async function refreshAccountDependentPanels() {
        try { await ensureSelectedAccountSession?.(); } catch {}
        try { await refreshAccountBalanceQuick(); } catch {}
        try { updatePositionSizeHint(); } catch {}
        try { await refreshBalanceSeries(); } catch {}
        try { await refreshClosedDealsSeries(); } catch {}
        try { await refreshPositions(); } catch {}
      }
      const onAccountChangeSync = (sel) => async () => {
        const v = (sel && sel.value) || '';
        setAllAccountSelects(v);
        if (v) { persistLastAccount(v); }
        try { await refreshAccountDependentPanels(); } catch {}
      };
      if (autoAccountSelect) autoAccountSelect.addEventListener('change', onAccountChangeSync(autoAccountSelect));
      if (tradeAccountSelect) tradeAccountSelect.addEventListener('change', onAccountChangeSync(tradeAccountSelect));
      if (tradeAccountSelectInline) tradeAccountSelectInline.addEventListener('change', onAccountChangeSync(tradeAccountSelectInline));
      if (autoPeriodicAccountSelect) autoPeriodicAccountSelect.addEventListener('change', onAccountChangeSync(autoPeriodicAccountSelect));
      // Populate account dropdowns on initial load
      try { loadAccountsSelect(); } catch {}
      // Hoisted helpers for periodic auto-trade keys
      function getAutoPeriodicKey() { return `auto_trade_periodic:${currentSymbol()}:${currentTf()}`; }
      function getAutoPeriodicPeriodKey() { return `auto_trade_period:${currentSymbol()}:${currentTf()}`; }
      // Load periodic auto-trade prefs and arm timer (if enabled)
      try { loadAutoPeriodicPrefs(); } catch {}
      try { ensureAutoPeriodicTimer(); } catch {}
      
      // Periodic Auto AI Trade: preferences and scheduler
      // (replaced by hoisted function declarations above)
      async function loadAutoPeriodicPrefs() {
        const sym = currentSymbol();
        const tf = currentTf();
        const keys = [
          getAutoPeriodicKey(),
          getAutoPeriodicPeriodKey(),
          `auto_volume:${sym}:${tf}`,
          `safe_max_lots:${sym}:${tf}`,
          `auto_sl_enabled:${sym}:${tf}`,
        ];
        try {
          const r = await fetch(`${PREF_ENDPOINT}?keys=${encodeURIComponent(keys.join(','))}`, { cache: 'no-store' });
          const js = await r.json().catch(()=>({}));
          const map = (js && js.prefs) || js || {};
          if (autoPeriodicToggle) autoPeriodicToggle.checked = String(map[getAutoPeriodicKey()]||'0') === '1';
          if (autoPeriodicPeriod) {
            const minStr = String(map[getAutoPeriodicPeriodKey()]||'60');
            autoPeriodicPeriod.value = (/^\d+$/.test(minStr) ? minStr : '60');
          }
          const vol = map[`auto_volume:${sym}:${tf}`];
          if (autoPeriodicVolumeInput) autoPeriodicVolumeInput.value = (vol && Number(vol) > 0) ? String(vol) : '0.01';
          const safe = map[`safe_max_lots:${sym}:${tf}`];
          if (autoPeriodicSafeMaxInput) {
            if (safe != null && safe !== '') {
              autoPeriodicSafeMaxInput.value = String(safe);
            } else {
              // Fallback to existing manual override field if present
              const manual = document.getElementById('safeMaxLotsInput');
              const val = manual && manual.value ? String(manual.value) : '';
              autoPeriodicSafeMaxInput.value = val;
            }
          }
          const sl = map[`auto_sl_enabled:${sym}:${tf}`];
          if (autoPeriodicSlToggle) autoPeriodicSlToggle.checked = String(sl||'0') === '1';
        } catch {}
      }
      if (autoPeriodicToggle) autoPeriodicToggle.addEventListener('change', ()=>{
        queuePrefUpdate(getAutoPeriodicKey(), autoPeriodicToggle.checked ? '1' : '0');
        ensureAutoPeriodicTimer();
      });
      if (autoPeriodicPeriod) autoPeriodicPeriod.addEventListener('change', ()=>{
        const raw = Number(autoPeriodicPeriod.value);
        const safe = Number.isFinite(raw) && raw > 0 ? Math.round(raw) : 60;
        autoPeriodicPeriod.value = String(safe);
        queuePrefUpdate(getAutoPeriodicPeriodKey(), String(safe));
        ensureAutoPeriodicTimer();
      });
      if (autoPeriodicVolumeInput) autoPeriodicVolumeInput.addEventListener('change', ()=>{
        const v = String(autoPeriodicVolumeInput.value||'');
        const sym = currentSymbol(); const tf = currentTf();
        queuePrefUpdate(`auto_volume:${sym}:${tf}`, v);
        queuePrefUpdate(`trade_volume:${sym}:${tf}`, v);
        queuePrefUpdate('last_volume', v);
      });
      if (autoPeriodicSafeMaxInput) autoPeriodicSafeMaxInput.addEventListener('change', ()=>{
        const sym = currentSymbol(); const tf = currentTf();
        queuePrefUpdate(`safe_max_lots:${sym}:${tf}`, String(autoPeriodicSafeMaxInput.value||''));
      });
      if (autoPeriodicSlToggle) autoPeriodicSlToggle.addEventListener('change', ()=>{
        const sym = currentSymbol(); const tf = currentTf();
        const val = autoPeriodicSlToggle.checked ? '1' : '0';
        // Mirror to modal toggle if present
        try { const t = document.getElementById('autoSlToggle'); if (t) t.checked = (val === '1'); } catch {}
        queuePrefUpdate(`auto_sl_enabled:${sym}:${tf}`, val);
        try { flushPrefQueue(); } catch {}
      });
      let autoPeriodicTimer = null;
      let autoPeriodicRunning = false;
      function clearAutoPeriodicTimer() { if (autoPeriodicTimer) { clearInterval(autoPeriodicTimer); autoPeriodicTimer = null; } }
      function ensureAutoPeriodicTimer() {
        clearAutoPeriodicTimer();
        if (!autoPeriodicToggle || !autoPeriodicToggle.checked) return;
        const mins = Number(autoPeriodicPeriod && autoPeriodicPeriod.value);
        const ms = (Number.isFinite(mins) && mins > 0 ? mins : 60) * 60_000;
        autoPeriodicTimer = setInterval(async () => {
          if (autoPeriodicRunning) return;
          autoPeriodicRunning = true;
          try { await autoAiTrade(); } catch {} finally { autoPeriodicRunning = false; }
        }, ms);
      }
      // Persist Auto controls
      const autoSafeMaxInput = document.getElementById('autoSafeMaxInput');
      const autoVolumeInput = document.getElementById('autoVolumeInput');
      const autoSlToggle = document.getElementById('autoSlToggle');
      function _saveAutoPrefs() {
        const sym = currentSymbol(); const tf = currentTf();
        if (autoSafeMaxInput) queuePrefUpdate(`safe_max_lots:${sym}:${tf}`, String(autoSafeMaxInput.value||''));
        if (autoVolumeInput) { const v=String(autoVolumeInput.value||''); queuePrefUpdate(`auto_volume:${sym}:${tf}`, v); queuePrefUpdate(`trade_volume:${sym}:${tf}`, v); queuePrefUpdate('last_volume', v); }
        if (autoSlToggle) queuePrefUpdate(`auto_sl_enabled:${sym}:${tf}`, autoSlToggle.checked ? '1' : '0');
        try { flushPrefQueue(); } catch {}
      }
      if (autoSafeMaxInput) autoSafeMaxInput.addEventListener('change', ()=>{ _saveAutoPrefs(); try {
        // Re-evaluate Start enablement vs current open lots
        const meta = document.getElementById('autoMeta');
        const txt = meta ? meta.textContent : '';
        const match = /Open:\s([0-9]+\.[0-9]+) lots/.exec(txt||'');
        const openLots = match ? Number(match[1]) : NaN;
        const safeNum = Number((autoSafeMaxInput.value||'0'));
        if (btnAutoStart) btnAutoStart.disabled = Number.isFinite(openLots) && Number.isFinite(safeNum) && safeNum>0 ? (openLots > safeNum) : false;
      } catch{} });
      if (autoVolumeInput) autoVolumeInput.addEventListener('change', _saveAutoPrefs);
      if (autoSlToggle) autoSlToggle.addEventListener('change', ()=>{
        // Persist and mirror to periodic toggle for consistency
        _saveAutoPrefs();
        try { const pt = document.getElementById('autoPeriodicSlToggle'); if (pt) pt.checked = !!autoSlToggle.checked; } catch {}
      });
      async function executeAiPlan() {
        if (!lastAiPlan) return;
        const side = (lastAiPlan.position || '').toLowerCase();
        if (side !== 'buy' && side !== 'sell') return;
        const symbol = currentSymbol();
        // Ensure selected account is logged in before executing
        try {
          const tSelInline = document.getElementById('tradeAccountSelectInline');
          const tSel = document.getElementById('tradeAccountSelect');
          const aSel = document.getElementById('autoAccountSelect');
          const acct = (tSelInline && tSelInline.value) ? tSelInline.value
                    : (tSel && tSel.value) ? tSel.value
                    : (aSel && aSel.value) ? aSel.value
                    : '';
          if (acct) {
            status(`Switching account → ${acct}`);
            const rlogin = await fetch('/api/account/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ login: acct }), cache:'no-store' });
            const jlogin = await rlogin.json().catch(()=>({}));
            if (!rlogin.ok || !(jlogin && jlogin.ok)) { status('Account login failed — using current session'); }
          }
        } catch {}
        let volume = '0.01';
        const hv = el('volume') ? el('volume').value : '';
        if (hv && Number(hv) > 0) volume = String(hv);
        const sl = (lastAiPlan.stop_loss != null) ? String(lastAiPlan.stop_loss) : '';
        const tp = (lastAiPlan.take_profit != null) ? String(lastAiPlan.take_profit) : '';
        const msg = `Execute ${lastAiPlan.position} ${symbol}\nSL: ${sl || '-'}  TP: ${tp || '-'}\nProceed?`;
        if (!window.confirm(msg)) return;
        try {
          status('Submitting trade from plan...');
          const body = new URLSearchParams({ symbol, side, volume });
          if (sl) body.set('sl', sl);
          if (tp) body.set('tp', tp);
          const r = await fetch('/api/trade', { method:'POST', headers: { 'Content-Type':'application/x-www-form-urlencoded' }, body, cache: 'no-store' });
          const js = await r.json().catch(()=>({}));
          if (js && js.ok) {
            status(`Trade ok: ${JSON.stringify(js.result)}`);
            await refreshChart();
            await refreshPositions();
          } else {
            status(`Trade error: ${(js && js.error) || r.statusText}`);
          }
        } catch (e) {
          status(`Trade error: ${e && e.message || e}`);
        }
      }
      if (btnExecutePlan) btnExecutePlan.addEventListener('click', executeAiPlan);
      async function autoAiTrade() {
        try {
          if (btnAutoStart) { btnAutoStart.disabled = true; btnAutoStart.textContent = 'Running…'; }
          const sym = currentSymbol();
          const tf = currentTf();
          if (typeof setTechFreshRunning === 'function') setTechFreshRunning();
          if (autoLogBox) autoLogBox.innerHTML = '';
          tradeState.autoSteps = [];
          appendAutoLog(`Auto AI Trade started for ${sym} ${tf}`);
          status(`Auto AI Trade running: ${sym} ${tf}`);
          // Freshness snapshots
          let hj = null;
          try {
            const hf = await fetch(`/api/health/freshness?symbol=${encodeURIComponent(sym)}`, { cache:'no-store' });
            hj = await hf.json().catch(()=>({}));
            if (hf.ok && hj && hj.ok) {
              appendAutoLog(`Basic freshness: status=${hj.status} new=${hj.new_count ?? '—'}`);
            }
          } catch {}
          let tfj = null;
          try {
            const tfq = new URLSearchParams({ symbol: sym, tf });
            const tfres = await fetch(`/api/tech/freshness?${tfq.toString()}`, { cache:'no-store' });
            tfj = await tfres.json().catch(()=>({}));
            if (tfres.ok && tfj && tfj.ok) {
              appendAutoLog(`Tech freshness: status=${tfj.status} outdated_bars=${tfj.outdated_bars ?? '—'}`);
            }
          } catch {}
          // Color mirrors based on freshness
          try { setAutoMirrorFreshness(hj, tfj); } catch {}
          // Decide whether to run new checks based on freshness
          let runBasic = false, runTech = false;
          try { runBasic = (hj && hj.status === 'stale' && Number(hj.new_count||0) > 0); } catch {}
          try { runTech = (tfj && tfj.status === 'stale' && Number(tfj.outdated_bars||0) > 0); } catch {}
          if (runBasic) appendAutoLog('Outdated: Basic — running new check…'); else appendAutoLog('Basic is fresh — using latest run.');
          if (runTech) appendAutoLog('Outdated: Tech — running new check…'); else appendAutoLog('Tech is fresh — using latest run.');
          let basicId = null, techId = null;
          if (runBasic) basicId = await newBasicCheckForTrade();
          if (runTech) techId = await newTechCheckForTrade();
          // If not run, pick latest for mirrors/alignment
          if (!basicId) {
            try {
              const p = new URLSearchParams();
              if (isFxPair(sym)) { const pq = splitPair(sym); p.set('kind','forex_pair'); p.set('base', pq.base); p.set('quote', pq.quote); }
              else { p.set('kind','stock'); p.set('symbol', sym); }
              p.set('group','basic'); p.set('tf', tf); p.set('limit','1');
              const r0 = await fetch(`/api/health/runs?${p.toString()}`, { cache:'no-store' });
              const j0 = await r0.json().catch(()=>({}));
              basicId = (j0 && j0.runs && j0.runs[0] && j0.runs[0].id) || null;
            } catch {}
          }
          if (!techId) {
            try {
              const p = new URLSearchParams();
              if (isFxPair(sym)) { const pq = splitPair(sym); p.set('kind','forex_pair'); p.set('base', pq.base); p.set('quote', pq.quote); }
              else { p.set('kind','stock'); p.set('symbol', sym); }
              p.set('strategy','tech_snapshot_10q_position.json'); p.set('tf', tf); p.set('limit','1');
              const r0 = await fetch(`/api/health/runs?${p.toString()}`, { cache:'no-store' });
              const j0 = await r0.json().catch(()=>({}));
              techId = (j0 && j0.runs && j0.runs[0] && j0.runs[0].id) || null;
            } catch {}
          }
          // Update mirrors after checks and refresh colors
          try { await updateAutoMirrors(); } catch {}
          try {
            // Re-check freshness quickly to clear stale highlight
            const hf2 = await fetch(`/api/health/freshness?symbol=${encodeURIComponent(sym)}`, { cache:'no-store' });
            const hj2 = await hf2.json().catch(()=>({}));
            const tf2 = await fetch(`/api/tech/freshness?symbol=${encodeURIComponent(sym)}&tf=${encodeURIComponent(tf)}`, { cache:'no-store' });
            const tj2 = await tf2.json().catch(()=>({}));
            setAutoMirrorFreshness(hj2, tj2);
          } catch {}
          if (basicId) appendAutoLog(`Basic run id=${basicId}`);
          if (techId) appendAutoLog(`Tech run id=${techId}`);
          const params = new URLSearchParams();
          if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
          else { params.set('kind','stock'); params.set('symbol', sym); }
          params.set('strategy','tech_snapshot_10q_position.json');
          params.set('tf', tf);
          params.set('limit','1');
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const latest = Array.isArray(js.runs) && js.runs.length ? js.runs[0] : null;
          let side = null;
          if (latest) {
            const ans = latest.answers || latest.answers_json || {};
            const scores = ans.scores || {};
            if (typeof scores.NET === 'number') {
              if (scores.NET > 0) side = 'BUY';
              else if (scores.NET < 0) side = 'SELL';
            } else if (typeof ans.signal === 'string') {
              const sig = ans.signal.toUpperCase();
              if (sig.includes('BUY')) side = 'BUY';
              else if (sig.includes('SELL')) side = 'SELL';
            }
          }
          if (!side) {
            status('Tech+AI is neutral — no trade.');
            appendAutoLog('Skip: Tech+AI neutral — no trade.', 'warn');
            try {
              const save = await fetch('/api/auto_trade/log', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ symbol: sym, timeframe: tf, action: null, basic_run_id: basicId || null, tech_run_id: (latest && latest.id) || techId || null, plan_run_id: null, skipped: true, skip_reason: 'tech_neutral', steps: (tradeState.autoSteps || []) })
              });
              const saved = await save.json().catch(()=>({}));
              if (saved && saved.ok && saved.run_id) {
                appendAutoLog(`Saved log run id=${saved.run_id}`);
                autoHistoryOffset = 0;
                await loadAutoHistory(5, 0);
              }
            } catch {}
            return;
          }
          // Check Basic alignment with Tech
          let basicSide = null;
          if (basicId) {
            try {
              const pb = new URLSearchParams();
              if (isFxPair(sym)) { const pq = splitPair(sym); pb.set('kind','forex_pair'); pb.set('base', pq.base); pb.set('quote', pq.quote); }
              else { pb.set('kind','stock'); pb.set('symbol', sym); }
              pb.set('group','basic'); pb.set('tf', tf); pb.set('limit','50'); pb.set('offset','0');
              const rb = await fetch(`/api/health/runs?${pb.toString()}`, { cache:'no-store' });
              const jb = await rb.json().catch(()=>({}));
              const runsB = Array.isArray(jb.runs) ? jb.runs : [];
              const b = runsB.find(x => Number(x.id) === Number(basicId)) || (runsB.length ? runsB[0] : null);
              if (b) {
                const ansb = b.answers || b.answers_json || {};
                const scoresb = ansb.scores || {};
                if (typeof scoresb.NET === 'number') {
                  if (scoresb.NET > 0) basicSide = 'BUY'; else if (scoresb.NET < 0) basicSide = 'SELL';
                } else if (typeof ansb.signal === 'string') {
                  const sigb = String(ansb.signal).toUpperCase();
                  if (sigb.includes('BUY')) basicSide = 'BUY'; else if (sigb.includes('SELL')) basicSide = 'SELL';
                }
              }
            } catch {}
          }
          if (!basicSide) {
            appendAutoLog('Skip: Basic is neutral — not aligned with Tech.', 'warn');
            status('Basic check neutral — no trade.');
            try {
              const save = await fetch('/api/auto_trade/log', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ symbol: sym, timeframe: tf, action: null, basic_run_id: basicId || null, tech_run_id: (latest && latest.id) || techId || null, plan_run_id: null, skipped: true, skip_reason: 'basic_neutral', steps: (tradeState.autoSteps || []) })
              });
              const saved = await save.json().catch(()=>({}));
              if (saved && saved.ok && saved.run_id) {
                appendAutoLog(`Saved log run id=${saved.run_id}`);
                autoHistoryOffset = 0;
                await loadAutoHistory(5, 0);
              }
            } catch {}
            return;
          }
          if (basicSide !== side) {
            appendAutoLog(`Skip: Tech (${side}) and Basic (${basicSide}) not aligned.`, 'warn');
            status('Tech and Basic not aligned — no trade.');
            try {
              const save = await fetch('/api/auto_trade/log', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ symbol: sym, timeframe: tf, action: null, basic_run_id: basicId || null, tech_run_id: (latest && latest.id) || techId || null, plan_run_id: null, skipped: true, skip_reason: 'not_aligned', steps: (tradeState.autoSteps || []) })
              });
              const saved = await save.json().catch(()=>({}));
              if (saved && saved.ok && saved.run_id) {
                appendAutoLog(`Saved log run id=${saved.run_id}`);
                autoHistoryOffset = 0;
                await loadAutoHistory(5, 0);
              }
            } catch {}
            return;
          }
          appendAutoLog(`Signal: ${side}`);
          appendAutoLog(`Drafting ${side} plan…`);
          const planResp = await (async ()=>{
            const lev = getLeverageValue();
            const snapshot = buildTechSnapshotString();
            const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
            const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
            const js = await r.json().catch(()=>({}));
            return { ok: !!(js && js.ok), data: js };
          })();
          if (!planResp.ok) { appendAutoLog(`Plan failed: ${(planResp.data && planResp.data.error) || 'unknown'}`, 'error'); return; }
          const planRunId = planResp.data && planResp.data.run_id ? Number(planResp.data.run_id) : null;
          if (planRunId) appendAutoLog(`Plan run id=${planRunId}`);
          const p = (planResp.data && planResp.data.plan) || {};
          lastAiPlan = { position: (p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: sym, timeframe: tf };
          updateExecuteBtn();
          appendAutoLog('Executing order…');
          // Ensure selected account is logged in before trading
          let acctUsed = '';
          try {
            const acctInline = document.getElementById('autoPeriodicAccountSelect');
            const acctAuto = document.getElementById('autoAccountSelect');
            const acctTradeInline = document.getElementById('tradeAccountSelectInline');
            const acct = (acctInline && acctInline.value) ? acctInline.value
                      : (acctAuto && acctAuto.value) ? acctAuto.value
                      : (acctTradeInline && acctTradeInline.value) ? acctTradeInline.value
                      : '';
            acctUsed = acct || '';
            if (acct) {
              appendAutoLog(`Switch account → ${acct}`);
              const rlogin = await fetch('/api/account/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ login: acct }), cache:'no-store' });
              const jlogin = await rlogin.json().catch(()=>({}));
              if (!rlogin.ok || !(jlogin && jlogin.ok)) { appendAutoLog('Account login failed — proceeding with current session', 'warn'); }
            }
          } catch { appendAutoLog('Account login skipped', 'warn'); }
          const sideLower = (side||'').toLowerCase();
          // Use Auto volume if provided, else fall back to top Vol
          let vol = '0.01';
          const periodicVolEl = document.getElementById('autoPeriodicVolumeInput');
          const autoVolEl = document.getElementById('autoVolumeInput');
          if (periodicVolEl && Number(periodicVolEl.value) > 0) vol = String(periodicVolEl.value);
          else if (autoVolEl && Number(autoVolEl.value) > 0) vol = String(autoVolEl.value);
          else if (el('volume')) vol = String(el('volume').value);
          const body = new URLSearchParams({ symbol: sym, side: sideLower, volume: vol });
          // Respect Set Stop Loss toggle
          const inlineSl = document.getElementById('autoPeriodicSlToggle');
          const slToggle = document.getElementById('autoSlToggle');
          const slEnabled = !!((inlineSl && inlineSl.checked === true) || (slToggle && slToggle.checked === true));
          if (p.take_profit != null) body.set('tp', String(p.take_profit));
          // Fetch current price for log context
          let mkt = null;
          try {
            const rt = await fetch(`/api/tick?symbol=${encodeURIComponent(sym)}`, { cache:'no-store' });
            const jt = await rt.json().catch(()=>({}));
            if (jt && (jt.bid!=null || jt.ask!=null || jt.last!=null)) mkt = jt;
          } catch {}
          const px = mkt ? (sideLower==='buy' ? (mkt.ask ?? mkt.last ?? mkt.bid) : (mkt.bid ?? mkt.last ?? mkt.ask)) : null;
          // Plan SL and optional scale suggestion (but scaling is disabled for execution)
          const planSL = (slEnabled && p.stop_loss != null) ? Number(p.stop_loss) : null;
          try {
            const slScaleEl = document.getElementById('autoSlScaleInput');
            const scale = slScaleEl ? Number(slScaleEl.value||'1') : 1;
            if (slEnabled && planSL != null && px != null && Number.isFinite(scale) && scale>0 && scale !== 1) {
              const suggested = Number(px) + (planSL - Number(px)) * scale;
              appendAutoLog(`SL scale is DISABLED for execution. Context → side=${side}, price=${px.toFixed ? px.toFixed(2) : px}, planSL=${planSL.toFixed ? planSL.toFixed(2) : planSL}, scale=${scale}, suggestedSL=${suggested.toFixed ? suggested.toFixed(2) : suggested}. Using planSL unchanged.`);
            } else if (slEnabled && planSL != null) {
              appendAutoLog(`SL scale disabled. Using planSL=${planSL.toFixed ? planSL.toFixed(2) : planSL}.`);
            }
          } catch {}
          // Preflight: invalid SL relative to current price? (BUY: SL < price; SELL: SL > price)
          if (slEnabled && planSL != null && px != null) {
            const invalid = (sideLower === 'buy') ? (planSL >= px) : (planSL <= px);
            const relation = (sideLower === 'buy') ? 'below' : 'above';
            appendAutoLog(`SL preflight: side=${side} price=${px.toFixed ? px.toFixed(2) : px} planSL=${planSL.toFixed ? planSL.toFixed(2) : planSL} → ${invalid ? 'INVALID' : 'OK'} (BUY requires SL<price; SELL requires SL>price).` , invalid ? 'error' : 'info');
            if (invalid) {
              try {
                const save = await fetch('/api/auto_trade/log', {
                  method:'POST', headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ symbol: sym, timeframe: tf, action: null, basic_run_id: basicId || null, tech_run_id: (latest && latest.id) || techId || null, plan_run_id: planRunId || null, skipped: true, skip_reason: 'invalid_stops', steps: (tradeState.autoSteps || []) })
                });
                const saved = await save.json().catch(()=>({}));
                if (saved && saved.ok && saved.run_id) { appendAutoLog(`Saved log run id=${saved.run_id}`); autoHistoryOffset = 0; await loadAutoHistory(5, 0); }
              } catch {}
              // Abort before placing the order
              if (btnAutoStart) { btnAutoStart.disabled = false; btnAutoStart.textContent = 'Start'; }
              return;
            }
          }
          // Write original plan SL to request if enabled (scaling disabled for execution)
          if (slEnabled && planSL != null) { body.set('sl', String(planSL)); }
          appendAutoLog(`Order params: acct=${(acctUsed||'current')} side=${side} vol=${vol} price=${px!=null? String(px):'market'} ${slEnabled? `SL=${planSL!=null? String(planSL):'off'}` : 'SL=off'} ${p.take_profit!=null? `TP=${String(p.take_profit)}`:''}`);
          const tr = await fetch('/api/trade', { method:'POST', headers: { 'Content-Type':'application/x-www-form-urlencoded' }, body, cache: 'no-store' });
          const tj = await tr.json().catch(()=>({}));
          const ok = tr.ok && tj && (tj.ok === true || (tj.result && tj.result.ok === true));
          const orderId = (tj && tj.result && (tj.result.order || tj.result.deal)) ? (tj.result.order || tj.result.deal) : null;
          if (ok) {
            appendAutoLog(`Order placed: id=${orderId != null ? orderId : '—'}`);
          } else {
            const errMsg = (tj && (tj.error || (tj.result && (tj.result.comment || tj.result.error)) )) || `HTTP ${tr.status} ${tr.statusText}`;
            const code = (tj && tj.result && (tj.result.retcode != null)) ? ` (retcode=${tj.result.retcode})` : '';
            appendAutoLog(`Order failed: ${errMsg}${code}`, 'error');
          }
          try {
            const save = await fetch('/api/auto_trade/log', {
              method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ symbol: sym, timeframe: tf, action: side, basic_run_id: basicId || null, tech_run_id: (latest && latest.id) || techId || null, plan_run_id: planRunId || null, used_volume: vol, sl_enabled: slEnabled, order_result: tj || {}, steps: (tradeState.autoSteps || []) })
            });
            const saved = await save.json().catch(()=>({}));
            if (saved && saved.ok && saved.run_id) {
              appendAutoLog(`Saved log run id=${saved.run_id}`);
              autoHistoryOffset = 0;
              await loadAutoHistory(5, 0);
            }
          } catch {}
          try { await refreshChart(); } catch {}
          try { await refreshPositions(); } catch {}
          status('Auto AI Trade finished.');
        } catch (e) {
          status(`Auto AI Trade failed: ${e && e.message || e}`);
          appendAutoLog(`Auto AI Trade failed: ${e && e.message || e}`, 'error');
        } finally {
          if (btnAutoStart) { btnAutoStart.disabled = false; btnAutoStart.textContent = 'Start'; }
          // Refresh Tech freshness; leave Basic untouched (independent)
          try { await refreshTechFreshness(); } catch {}
        }
      }
      // (removed duplicate autoAiTrade definition)
      async function runAiTradePlan(side) {
        const sym = symbolSelect.value.toUpperCase();
        const tf = currentTf();
        const lev = getLeverageValue();
        const outBox = el('aiTradePlanBox');
        const outBoxModal = el('tradeResultsBox');
        if (outBox) outBox.textContent = 'Drafting plan…';
        if (outBoxModal) outBoxModal.textContent = 'Drafting plan…';
        // Disable Buy/Sell during processing and show progress text
        const buyBtn = document.getElementById('btnTradeStartBuy');
        const sellBtn = document.getElementById('btnTradeStartSell');
        const prevBuy = buyBtn ? buyBtn.textContent : '';
        const prevSell = sellBtn ? sellBtn.textContent : '';
        if (buyBtn) { buyBtn.disabled = true; buyBtn.textContent = side === 'BUY' ? 'Processing…' : '…'; }
        if (sellBtn) { sellBtn.disabled = true; sellBtn.textContent = side === 'SELL' ? 'Processing…' : '…'; }
        try {
          const snapshot = buildTechSnapshotString();
          const body = { symbol: sym, timeframe: tf, action: side, leverage: lev, tech_snapshot: snapshot, model: getTradeAiModel() };
          const r = await fetch('/api/ai/trade_plan', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body), cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          if (!r.ok || !js || js.ok !== true) {
            const err = `<em style=color:var(--sell)>Failed: ${(js && js.error) || r.statusText || 'unknown'}</em>`;
            if (outBox) outBox.innerHTML = err;
            if (outBoxModal) outBoxModal.innerHTML = err;
            return;
          }
          const p = js.plan || {};
          const enforced = js.enforced ? ' (risk cap applied)' : '';
          const created = js.created_at ? new Date(js.created_at).toLocaleString() : '';
          const html = `<div class="row" style="justify-content:space-between; align-items:center;">
            <strong>Plan</strong><span style="font-size:12px; color:var(--muted)">${esc(js.symbol)} ${esc(js.timeframe)} • lev ${esc(js.leverage)}${enforced}${created ? ` • ${esc(created)}` : ''}</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;">
            <span class="pill" style="background:${p.position==='BUY'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${p.position==='BUY'?'#2ecc71':'#e74c3c'};">${esc(p.position||'')}</span>
            <span class="pill">SL: ${esc(p.stop_loss)}</span>
            <span class="pill">TP: ${esc(p.take_profit)}</span>
          </div>
          <div style="margin-top:6px; color:var(--muted);">${esc(p.explanation||'')}</div>`;
          if (outBox) outBox.innerHTML = html;
          if (outBoxModal) outBoxModal.innerHTML = html;
          // Prepare plan for execution; do not auto-execute
          lastAiPlan = { position: (p.position||'').toUpperCase(), stop_loss: p.stop_loss, take_profit: p.take_profit, symbol: sym, timeframe: tf };
          updateExecuteBtn();
          const note = `<div style=\"margin-top:6px; font-size:12px; color:var(--muted);\">Plan ready — click Execute Plan to trade.</div>`;
          if (outBox) outBox.insertAdjacentHTML('beforeend', note);
          if (outBoxModal) outBoxModal.insertAdjacentHTML('beforeend', note);
          try { tradeState.offset = 0; await loadTradeHistory(); } catch {}
        } catch (e) {
          const err2 = `<em style=color:var(--sell)>Error: ${e && e.message || e}</em>`;
          if (outBox) outBox.innerHTML = err2;
          if (outBoxModal) outBoxModal.innerHTML = err2;
        } finally {
          if (buyBtn) { buyBtn.disabled = false; buyBtn.textContent = prevBuy || 'Buy'; }
          if (sellBtn) { sellBtn.disabled = false; sellBtn.textContent = prevSell || 'Sell'; }
        }
      }
      if (btnTechClose) btnTechClose.addEventListener('click', ()=> { const modal = el('techModal'); if (modal) modal.style.display = 'none'; });
      if (healthStrategySelect) {
        healthStrategySelect.addEventListener('change', () => { healthStrategyUserOverride = true; });
      }
      if (techHealthBarsInput) {
        techHealthBarsInput.addEventListener('input', () => { techHealthUserOverride = true; });
        const validateTechBars = () => {
          const raw = Number(techHealthBarsInput.value);
          if (!Number.isFinite(raw) || raw <= 0) {
            applyTechWindowDefault(true);
          } else {
            const clamped = Math.max(10, Math.min(500, Math.round(raw)));
            techHealthBarsInput.value = String(clamped);
          }
        };
        techHealthBarsInput.addEventListener('change', validateTechBars);
        techHealthBarsInput.addEventListener('blur', validateTechBars);
      }

      // Click history item to show saved result
      const healthHistoryBox = document.getElementById('healthHistoryBox');
      if (healthHistoryBox) {
        healthHistoryBox.addEventListener('click', (ev) => {
          const node = ev.target.closest('[data-run-idx]');
          if (!node) return;
          const idx = Number(node.getAttribute('data-run-idx'));
          const run = (healthState.runs || [])[idx];
          if (!run || !run.answers) return;
          const ans = run.answers;
          const payload = {
            questions: ans.questions || [],
            score: ans.score ?? ans.NET,
            signal: ans.signal || (ans.scores && ans.scores.signal) || '',
            strategy: ans.strategy || '',
            scores: ans.scores || null,
            base: run.base_ccy || (ans.meta && ans.meta.base),
            quote: run.quote_ccy || (ans.meta && ans.meta.quote),
          };
          const outBox = el('healthResultsBox');
          renderHealthOutcome(outBox, payload);
        });
      }

      const ensureMacdChart = () => {
        if (macdChart || !macdCtx) return;
        macdChart = new window.Chart(macdCtx, {
          type: 'bar',
          parsing: false,
          data: {
            labels: [],
            datasets: [
              {
                type: 'bar',
                label: 'Histogram',
                data: [],
                backgroundColor: (context) => {
                  const raw = context.raw;
                  const value = raw != null && typeof raw === 'object' ? raw.y : raw;
                  if (value == null) return 'rgba(158, 158, 158, 0.35)';
                  return value >= 0 ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)';
                },
                borderWidth: 0,
                barPercentage: 1.0,
                categoryPercentage: 1.0,
              },
              {
                type: 'line',
                label: 'MACD',
                data: [],
                borderColor: '#1b9aaa',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.15,
                fill: false,
              },
              {
                type: 'line',
                label: 'Signal',
                data: [],
                borderColor: '#ef6c00',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.15,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: true, position: 'top' } },
            interaction: { intersect: false, mode: 'index' },
            scales: {
              x: {
                type: 'time',
                time: { tooltipFormat: 'MMM d HH:mm' },
                bounds: 'ticks',
                offset: false,
                ticks: { maxRotation: 0, autoSkip: true },
                grid: { display: false },
              },
              y: {
                position: 'right',
                grid: { color: '#e0e6ef' },
              },
            },
          },
        });
      };

      const applyScaleBounds = (chartInstance) => {
        if (!chartInstance || !chartInstance.options || !chartInstance.options.scales || !chartInstance.options.scales.x) return;
        const scale = chartInstance.options.scales.x;
        if (indicatorRangeMs && Number.isFinite(indicatorRangeMs.min) && Number.isFinite(indicatorRangeMs.max)) {
          scale.min = indicatorRangeMs.min;
          scale.max = indicatorRangeMs.max;
        } else {
          scale.min = undefined;
          scale.max = undefined;
        }
      };

      const updateIndicatorDisplay = (rows) => {
        // When no data, clear indicator panes
        if (!rows || !rows.length) {
          if (lwVolSeries) lwVolSeries.setData([]);
          if (lwRsiSeries) lwRsiSeries.setData([]);
          if (lwMacdHist) lwMacdHist.setData([]);
          if (lwMacdLine) lwMacdLine.setData([]);
          if (lwMacdSignal) lwMacdSignal.setData([]);
          lwVolHasData = false;
          lwRsiHasData = false;
          lwMacdHasData = false;
          stlTrendPoints = [];
          stlSeasonPoints = [];
          stlResidPoints = [];
          stlSpeedPoints = [];
          stlAccelPoints = [];
          updateStlDerivativeSeries();
          if (chart && curType === 'line') {
            chart.data.labels = [];
            chart.data.datasets.forEach((ds) => { ds.data = []; });
            chart.update('none');
          }
          try { updatePositionSizeHint(); } catch {}
          return;
        }
        // Compute inputs
        const closes = rows.map((r) => Number.isFinite(Number(r.close)) ? Number(r.close) : 0);
        const volumes = rows.map((r) => {
          const cand = [r.real_volume, r.tick_volume, r.volume]
            .map((v) => Number(v))
            .filter((v) => Number.isFinite(v) && v > 0);
          return cand.length ? cand[0] : 0;
        });
        // Ensure LWC panes
        ensureLwVol();
        ensureLwRsi();
        ensureLwMacd();
        ensureLwDeriv();
        try { updatePositionSizeHint(); } catch {}
        // Volume histogram
        if (lwVolSeries) {
          const volPoints = rows.map((row, idx) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const y = volumes[idx];
            const up = Number(row.close) >= Number(row.open);
            const color = up ? 'rgba(76,175,80,0.5)' : 'rgba(244,67,54,0.5)';
            return { time: t, value: y, color };
          });
          lwVolSeries.setData(volPoints);
          lwVolHasData = volPoints.length > 0;
        }
        // RSI line
        if (lwRsiSeries) {
          const rsiValues = computeRSI(closes);
          const rsiPoints = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = rsiValues[i];
            return (v != null && Number.isFinite(v)) ? { time: t, value: v } : null;
          }).filter(Boolean);
          lwRsiSeries.setData(rsiPoints);
          lwRsiHasData = rsiPoints.length > 0;
        }
        // MACD histogram + lines
        if (lwMacdHist && lwMacdLine && lwMacdSignal) {
          const macdObj = computeMACD(closes);
          const hist = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = macdObj.histogram[i];
            const color = v >= 0 ? 'rgba(76,175,80,0.5)' : 'rgba(244,67,54,0.5)';
            return (v != null && Number.isFinite(v)) ? { time: t, value: v, color } : null;
          }).filter(Boolean);
          const macdLine = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = macdObj.macd[i];
            return (v != null && Number.isFinite(v)) ? { time: t, value: v } : null;
          }).filter(Boolean);
          const signal = rows.map((row, i) => {
            const t = Math.floor(new Date(row.ts).getTime() / 1000);
            const v = macdObj.signal[i];
            return (v != null && Number.isFinite(v)) ? { time: t, value: v } : null;
          }).filter(Boolean);
          lwMacdHist.setData(hist);
          lwMacdLine.setData(macdLine);
          lwMacdSignal.setData(signal);
          lwMacdHasData = hist.length > 0 || macdLine.length > 0 || signal.length > 0;
        }
        // Line chart overlay retains previous behavior if active
        if (chart && curType === 'line') {
          const boll = computeBollingerBands(closes);
          chart.data.labels = rows.map((r) => r.ts);
          if (chart.data.datasets[0]) chart.data.datasets[0].data = closes;
          if (chart.data.datasets[1]) chart.data.datasets[1].data = boll.middle;
          if (chart.data.datasets[2]) chart.data.datasets[2].data = boll.upper;
          if (chart.data.datasets[3]) chart.data.datasets[3].data = boll.lower;
          chart.update('none');
        }
      };

      const enforceIndicatorRange = (range, logicalRange) => {
        if (!range || range.from == null || range.to == null) return;
        lwSyncing = true;
        try {
          if (lwVolChart && lwVolHasData) {
            lwVolChart.timeScale().setVisibleRange(range);
          }
          if (lwRsiChart && lwRsiHasData) {
            lwRsiChart.timeScale().setVisibleRange(range);
          }
          if (lwMacdChart && lwMacdHasData) {
            lwMacdChart.timeScale().setVisibleRange(range);
          }
          if (lwDerivChart && (lwDerivHasSpeed || lwDerivHasAccel)) {
            lwDerivChart.timeScale().setVisibleRange(range);
          }
          if (logicalRange && logicalRange.from != null && logicalRange.to != null) {
            currentLogicalRange = logicalRange;
          }
        } catch (err) {
          console.warn('[ChartSync] indicator range error', err);
        } finally {
          lwSyncing = false;
        }
      };

      const applyIndicatorViewport = (range, logicalRange) => {
        if (range && range.from != null && range.to != null) {
          currentTimeRange = range;
          const fromMs = Number(range.from) * 1000;
          const toMs = Number(range.to) * 1000;
          indicatorRangeMs = (Number.isFinite(fromMs) && Number.isFinite(toMs))
            ? { min: fromMs, max: toMs }
            : null;
          if (logicalRange && curType === 'candlestick') {
            enforceIndicatorRange(range, logicalRange);
          }
        } else {
          currentTimeRange = null;
          indicatorRangeMs = null;
        }
        updateIndicatorDisplay(lastPriceRows);
        if (chart && curType === 'line') {
          applyScaleBounds(chart);
          chart.update('none');
        }
      };

      function makeChart(type) {
        curType = type;
        if (type === 'line') {
          lwContainer.style.display = 'none';
          canvas.style.display = 'block';
          if (lwOverlay && lwOverlayCtx) {
            lwOverlayCtx.clearRect(0, 0, lwOverlay.width, lwOverlay.height);
          }
          clearAllStlOverlaySeries();
          if (chart) {
            chart.destroy();
            chart = null;
          }
          const existing = window.Chart.getChart(canvas);
          if (existing) existing.destroy();
          chart = new window.Chart(ctx, {
            type: 'line',
            data: {
              labels: [],
              datasets: [
                { label: 'Close', data: [], borderColor: '#1976d2', borderWidth: 1.5, pointRadius: 0, tension: 0.15, fill: false },
                { label: 'Bollinger Mid', data: [], borderColor: '#607d8b', borderDash: [4, 4], borderWidth: 1, pointRadius: 0, tension: 0.15, fill: false },
                { label: 'Bollinger Upper', data: [], borderColor: '#ff9800', borderWidth: 1, pointRadius: 0, tension: 0.15, fill: false },
                { label: 'Bollinger Lower', data: [], borderColor: '#ff9800', borderWidth: 1, pointRadius: 0, tension: 0.15, fill: false },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: true, position: 'top' } },
              interaction: { intersect: false, mode: 'index' },
              scales: {
                x: { type: 'time', time: { tooltipFormat: 'MMM d HH:mm' }, ticks: { maxRotation: 0, autoSkip: true }, grid: { display: false } },
                y: { beginAtZero: false, grid: { color: '#e0e6ef' } },
              },
            },
          });
          currentTimeRange = null;
          currentLogicalRange = null;
          applyIndicatorViewport(null, null);
          clearStlOverlay('Switch to candlestick view to see STL overlay.', true);
          return chart;
        }

        canvas.style.display = 'none';
        lwContainer.style.display = 'block';
        if (!lwChart) {
          lwChart = LightweightCharts.createChart(lwContainer, {
            layout: { background: { color: '#f7f9fc' }, textColor: '#111' },
            grid: { vertLines: { color: '#e0e6ef' }, horzLines: { color: '#e0e6ef' } },
            crosshair: { mode: LightweightCharts.CrosshairMode.Magnet },
            rightPriceScale: { borderColor: '#e0e6ef' },
            timeScale: { borderColor: '#e0e6ef', rightOffset: getRightOffset(), fixRightEdge: false },
          });
          lwSeries = lwChart.addCandlestickSeries({
            upColor: '#2ecc71',
            downColor: '#e74c3c',
            wickUpColor: '#2ecc71',
            wickDownColor: '#e74c3c',
            borderVisible: false,
          });
          if (!lwBollingerUpper) {
            lwBollingerUpper = lwChart.addLineSeries({
              color: '#ff9800',
              lineWidth: 1.5,
              priceLineVisible: false,
              title: 'Bollinger Upper',
            });
          }
          if (!lwBollingerLower) {
            lwBollingerLower = lwChart.addLineSeries({
              color: '#ff9800',
              lineWidth: 1.5,
              priceLineVisible: false,
              title: 'Bollinger Lower',
            });
          }
          if (!lwBollingerMid) {
            lwBollingerMid = lwChart.addLineSeries({
              color: '#607d8b',
              lineWidth: 1,
              lineStyle: LightweightCharts.LineStyle.Dashed,
              priceLineVisible: false,
              title: 'Bollinger Mid',
            });
          }
          lwObserver = new ResizeObserver(() => {
            const rect = lwContainer.getBoundingClientRect();
            lwChart.applyOptions({
              width: rect.width || lwContainer.clientWidth || 800,
              height: rect.height || lwContainer.clientHeight || 400,
            });
          });
          lwObserver.observe(lwContainer);
          const rectInit = lwContainer.getBoundingClientRect();
          lwChart.applyOptions({
            width: rectInit.width || lwContainer.clientWidth || 800,
            height: rectInit.height || lwContainer.clientHeight || 400,
          });
          ensureLwOverlay();
          if (!lwTimeRangeSubscribed) {
            lwChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
              handleChartRangeChange(lwChart);
            });
            lwTimeRangeSubscribed = true;
          }
        }
        // Apply current chart shift offset to all panes
        try {
          const ro = getRightOffset();
          if (lwChart) lwChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwVolChart) lwVolChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwRsiChart) lwRsiChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwMacdChart) lwMacdChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwDerivChart) lwDerivChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwAtrChart) lwAtrChart.applyOptions({ timeScale: { rightOffset: ro } });
          if (lwAdxChart) lwAdxChart.applyOptions({ timeScale: { rightOffset: ro } });
        } catch (e) { /* noop */ }
        if (stlLastRows.length && stlLastMeta) {
          applyStlData(stlLastRows.slice(), stlLastMeta).catch((err) => console.warn('STL overlay restore failed', err));
        }
        syncStlOverlayVisibility();
        return lwChart;
      }
      function handleFetchEvent(data) {
        if (!data) return;
        debugLog('[WS] fetch event', data);
        if (data.status === 'scheduled' && data.background) {
          status(`Background fetch scheduled (${data.symbol} ${data.timeframe})`);
          return;
        }
        if (data.status === 'error') {
          status(`Fetch error (${data.symbol} ${data.timeframe}): ${data.error || 'unknown'}`);
          return;
        }
        const symbol = currentSymbol();
        const tf = currentTf();
        const sameSymbol = data.symbol === symbol;
        const sameTf = data.timeframe === tf;
        const inserted = Number(data.inserted || 0);
        if (sameSymbol && sameTf) {
          if (data.background) {
            status(`Background fetch done (${data.symbol} ${data.timeframe}, +${inserted} bars)`);
          }
          scheduleChartRefresh(`${data.symbol}/${data.timeframe}`);
          // Update Tech+AI freshness (bars outdated)
          refreshTechFreshness();
          // Re-run top strategy so the Signal pill reflects the new bars
          try { runStrategyTop(); } catch (e) { /* ignore */ }
        } else if (data.scope === 'symbol_all_tf' && sameSymbol) {
          status(`Background fetch done (${data.symbol} ${data.timeframe})`);
          scheduleChartRefresh(`${data.symbol}/${data.timeframe} [scope symbol_all_tf]`);
          refreshTechFreshness();
          if (data.timeframe === currentTf()) { try { runStrategyTop(); } catch (e) {} }
        } else if (data.scope === 'all_symbols' && data.symbol === symbol) {
          status(`Bulk fetch updated ${data.symbol} ${data.timeframe}`);
          scheduleChartRefresh(`${data.symbol}/${data.timeframe} [scope all_symbols]`);
          refreshTechFreshness();
          if (data.timeframe === currentTf()) { try { runStrategyTop(); } catch (e) {} }
        }
      }

      function handleNewsEvent(data) {
        if (!data) return;
        debugLog('[WS] news event', data);
        const symbol = currentSymbol();
        const eventSymbol = (data.symbol || '').toUpperCase();
        if (eventSymbol && eventSymbol !== symbol) {
          return;
        }
        const count = Number.isFinite(Number(data.items)) ? Number(data.items) : null;
        const scope = data.scope || 'news';
        const prefix = count != null ? `${count} new item${count === 1 ? '' : 's'}` : 'Background update';
        setNewsStatus(`${prefix} (${symbol}, ${scope})`, 'warn');
        scheduleNewsRefresh(data.reason || 'ws_news');
      }

      function handleStlEvent(data) {
        if (!data) return;
        const desc = `${data.symbol} ${data.timeframe}`;
        const sameSymbol = data.symbol === currentSymbol();
        const sameTf = data.timeframe === currentTf();
        const overlayKey = `${data.symbol}__${data.timeframe}`;
        stlOverlayLoading.delete(overlayKey);
        stlOverlayData.delete(overlayKey);
        const wasPending = stlOverlayPending.delete(overlayKey);
        const pendingInput = stlOverlayInputs.get(data.timeframe);
        if (pendingInput && (wasPending || pendingInput.dataset.loading === '1')) {
          pendingInput.dataset.loading = '';
        }
        if (sameSymbol && sameTf && data.status === 'scheduled') {
          stlPendingCompute = true;
        }
        const box = el('stlStatus');
        if (data.status === 'scheduled') {
          if (box) box.textContent = `STL job scheduled (${desc})...`;
          status(`STL scheduled (${desc})`);
          return;
        }
        if (data.status === 'error') {
          const message = `STL error (${desc}): ${data.error || 'unknown'}`;
          if (box) box.textContent = message;
          status(message);
          if (sameSymbol && sameTf) {
            stlPendingCompute = false;
            refreshStlOverlay({ autoCompute: false });
          } else if (sameSymbol && pendingInput && !pendingInput.disabled) {
            pendingInput.checked = false;
          }
          return;
        }
        const rangeInfo = data.start_ts && data.end_ts ? `, ${formatDateShort(data.start_ts)} → ${formatDateShort(data.end_ts)}` : '';
        const metaInfo = `period ${data.period || '—'}${rangeInfo}${data.points ? `, points ${data.points}` : ''}`;
        const note = data.note ? ` • ${data.note}` : '';
        if (box) box.textContent = `STL ${data.status} (${desc}, ${metaInfo}${note})`;
        if (sameSymbol && sameTf && data.status === 'completed') {
          stlPendingCompute = false;
          if (data.run_id) stlSelectedRunId = data.run_id;
          status(`STL updated (${desc}, ${metaInfo})`);
          refreshStlOverlay({ runId: data.run_id || null, autoCompute: false });
        } else if (!sameSymbol || !sameTf) {
          status(`STL ${data.status} (${desc}${note ? `, ${data.note}` : ''})`);
        }
        if (sameSymbol && data.timeframe !== currentTf() && isStlOverlayEnabled(data.timeframe)) {
          loadStlOverlay(data.timeframe);
        }
        syncStlOverlayVisibility();
      }
      function ensureStlOverlaySeries(tf) {
        if (!lwChart) return null;
        if (stlOverlaySeries.has(tf)) return stlOverlaySeries.get(tf);
        const series = lwChart.addLineSeries({
          color: STL_OVERLAY_COLORS[tf] || '#607d8b',
          lineWidth: 1.5,
          priceScaleId: 'right',
          title: `Trend ${tf}`,
        });
        stlOverlaySeries.set(tf, series);
        return series;
      }
      function clearStlOverlaySeries(tf) {
        const series = stlOverlaySeries.get(tf);
        if (series && typeof series.setData === 'function') {
          series.setData([]);
        }
      }
      function clearAllStlOverlaySeries() {
        stlOverlaySeries.forEach((series) => {
          if (series && typeof series.setData === 'function') series.setData([]);
        });
      }
      function isStlOverlayEnabled(tf) {
        const input = stlOverlayInputs.get(tf);
        if (!input) return false;
        if (input.disabled) return input.dataset.locked === 'current';
        return !!input.checked;
      }
      function overlayKey(symbol, tf) {
        return `${symbol}__${tf}`;
      }
      function scheduleStlOverlayCompute(symbol, tf) {
        const key = overlayKey(symbol, tf);
        if (stlOverlayPending.has(key)) return;
        const input = stlOverlayInputs.get(tf);
        if (input) input.dataset.loading = '1';
        stlOverlayPending.add(key);
        status(`Scheduling STL overlay compute (${symbol} ${tf})...`);
        triggerStl('current', {
          symbol,
          timeframe: tf,
          silent: true,
          skipPref: true,
          allData: true,
        })
          .then(() => {
            debugLog('[STL overlay] compute scheduled', symbol, tf);
          })
          .catch((err) => {
            stlOverlayPending.delete(key);
            debugWarn('[STL overlay] compute schedule failed', symbol, tf, err);
            status(`Failed to schedule STL overlay (${symbol} ${tf}).`);
          });
      }
      function applyStoredOverlay(tf) {
        if (curType !== 'candlestick') return;
        const symbol = currentSymbol();
        const key = overlayKey(symbol, tf);
        const data = stlOverlayData.get(key);
        const series = ensureStlOverlaySeries(tf);
        if (!series) return;
        series.setData(Array.isArray(data) ? data : (data && data.trend) || data || []);
      }
      async function loadStlOverlay(tf) {
        if (curType !== 'candlestick') return;
        const symbol = currentSymbol();
        const key = overlayKey(symbol, tf);
        if (stlOverlayData.has(key)) {
          applyStoredOverlay(tf);
          return;
        }
        if (stlOverlayLoading.has(key)) {
          return stlOverlayLoading.get(key);
        }
        const input = stlOverlayInputs.get(tf);
        if (input) input.dataset.loading = '1';
        const limit = Math.max(200, Math.min(1500, currentBarsLimit() * 2));
        const params = new URLSearchParams({
          symbol,
          tf,
          include_data: '1',
          all_data: '1',
          limit: String(limit),
        });
        const promise = (async () => {
          const resp = await fetch(`/api/stl?${params.toString()}`, { cache: 'no-store' });
          const js = await resp.json().catch(() => ({}));
          if (!resp.ok || !js || js.ok !== true) {
            throw new Error(js && js.error ? js.error : resp.statusText || 'overlay fetch failed');
          }
          const rows = Array.isArray(js.rows) ? js.rows : [];
          if (!rows.length) {
            throw new Error('no STL rows');
          }
          const seriesData = rows
            .map((r) => {
              const t = new Date(r.ts).getTime();
              const v = Number(r.trend);
              if (!Number.isFinite(t) || !Number.isFinite(v)) return null;
              return { time: Math.floor(t / 1000), value: v };
            })
            .filter(Boolean);
          if (!seriesData.length) {
            throw new Error('no usable trend points');
          }
          stlOverlayData.set(key, seriesData);
          applyStoredOverlay(tf);
          debugLog(`[STL overlay] loaded ${symbol} ${tf}`);
        })().catch((err) => {
          debugWarn('[STL overlay]', tf, err);
          scheduleStlOverlayCompute(symbol, tf);
          status(`STL overlay pending compute (${symbol} ${tf})`);
        }).finally(() => {
          stlOverlayLoading.delete(key);
          const inputEl = stlOverlayInputs.get(tf);
          if (inputEl) {
            if (stlOverlayPending.has(key)) {
              inputEl.dataset.loading = '1';
            } else {
              inputEl.dataset.loading = '';
            }
          }
        });
        stlOverlayLoading.set(key, promise);
        return promise;
      }
      function syncStlOverlayVisibility() {
        if (!stlOverlayControls) return;
        if (curType !== 'candlestick') {
          clearAllStlOverlaySeries();
          return;
        }
        const symbol = currentSymbol();
        STL_OVERLAY_TFS.forEach((tf) => {
          if (tf === currentTf()) return;
          if (!isStlOverlayEnabled(tf)) {
            clearStlOverlaySeries(tf);
            return;
          }
          const key = overlayKey(symbol, tf);
          if (stlOverlayData.has(key)) {
            applyStoredOverlay(tf);
          } else {
            loadStlOverlay(tf);
          }
        });
      }
      function buildStlOverlayControls() {
        if (!stlOverlayControls) return;
        const symbol = currentSymbol();
        const current = currentTf();
        stlOverlayControls.innerHTML = '';
        stlOverlayInputs.clear();
        // Symbol • Timeframe label then Auto STL switch (per symbol × timeframe)
        const stlCtx = document.createElement('span');
        stlCtx.style.fontSize = '12px';
        stlCtx.style.color = 'var(--muted)';
        stlCtx.style.marginRight = '8px';
        stlCtx.textContent = `${symbol} • ${current}`;
        stlOverlayControls.appendChild(stlCtx);

        // Auto STL switch (per symbol × timeframe)
        const getAutoKey = () => `stl_auto_compute:${symbol}:${current}`;
        const readAuto = () => { try { return (localStorage.getItem(getAutoKey()) === '1'); } catch { return false; } };
        const writeAuto = (val) => { try { localStorage.setItem(getAutoKey(), val ? '1' : '0'); } catch {} };
        const autoWrap = document.createElement('label');
        autoWrap.className = 'switch';
        autoWrap.style.marginRight = '8px';
        const autoChk = document.createElement('input');
        autoChk.type = 'checkbox';
        autoChk.className = 'toggle-input';
        autoChk.id = 'chkStlAutoCompute';
        autoChk.checked = !!readAuto();
        autoChk.addEventListener('change', () => {
          const val = !!autoChk.checked;
          writeAuto(val);
          // Persist to DB preferences under per-symbol×tf key
          try { queuePrefUpdate(getAutoKey(), val ? '1' : '0'); } catch {}
        });
        const autoSlider = document.createElement('span');
        autoSlider.className = 'toggle';
        const autoText = document.createElement('span');
        autoText.textContent = 'Auto STL';
        autoWrap.appendChild(autoChk);
        autoWrap.appendChild(autoSlider);
        autoWrap.appendChild(autoText);
        stlOverlayControls.appendChild(autoWrap);

        // Read server preference (override localStorage if present)
        (async () => {
          try {
            const key = getAutoKey();
            const r = await fetch(`${PREF_ENDPOINT}?keys=${encodeURIComponent(key)}`, { cache: 'no-store' });
            const js = await r.json().catch(() => ({}));
            const serverVal = js && js.prefs && js.prefs[key];
            if (serverVal === '1' || serverVal === '0') {
              const checked = serverVal === '1';
              autoChk.checked = checked;
              writeAuto(checked);
            }
          } catch { /* ignore */ }
        })();

        const label = document.createElement('span');
        label.textContent = 'Overlay STL';
        label.style.fontSize = '12px';
        label.style.fontWeight = '600';
        label.style.color = 'var(--muted)';
        stlOverlayControls.appendChild(label);
        const order = ALL_TFS.slice();
        const currentIdx = order.indexOf(current);
        const overlayList = order.filter((tf) => STL_OVERLAY_TFS.includes(tf) || tf === current);
        overlayList.forEach((tf) => {
          const tfIdx = order.indexOf(tf);
          const isCurrent = tf === current;
          const isLower = currentIdx !== -1 && tfIdx !== -1 && tfIdx < currentIdx;
          const unavailable = tfIdx === -1;
          const wrap = document.createElement('label');
          wrap.style.display = 'flex';
          wrap.style.alignItems = 'center';
          wrap.style.gap = '4px';
          wrap.style.fontSize = '12px';
          wrap.style.color = 'var(--muted)';
          wrap.style.cursor = 'pointer';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = tf;
          input.dataset.tf = tf;
          if (isCurrent) {
            input.checked = true;
            input.disabled = true;
            input.dataset.locked = 'current';
            wrap.style.cursor = 'default';
            wrap.style.opacity = '0.9';
          } else if (unavailable) {
            input.checked = false;
            input.disabled = true;
            input.dataset.locked = 'unsupported';
            wrap.style.cursor = 'not-allowed';
            wrap.style.opacity = '0.3';
          } else if (isLower && currentIdx !== -1) {
            input.checked = false;
            input.disabled = true;
            input.dataset.locked = 'lower';
            wrap.style.cursor = 'not-allowed';
            wrap.style.opacity = '0.35';
            wrap.title = 'Enable lower timeframe trends from their own chart.';
            clearStlOverlaySeries(tf);
          } else {
            const key = overlayKey(symbol, tf);
            if (stlOverlayData.has(key)) {
              input.checked = true;
            }
            input.addEventListener('change', () => {
              if (input.checked) {
                loadStlOverlay(tf);
              } else {
                clearStlOverlaySeries(tf);
              }
            });
          }
          stlOverlayInputs.set(tf, input);
          const badge = document.createElement('span');
          badge.textContent = tf;
          badge.style.padding = '2px 6px';
          badge.style.borderRadius = '4px';
          const color = STL_OVERLAY_COLORS[tf] || '#607d8b';
          badge.style.border = `1px solid ${color}`;
          badge.style.color = color;
          badge.style.fontWeight = '600';
          wrap.appendChild(input);
          wrap.appendChild(badge);
          stlOverlayControls.appendChild(wrap);
        });
        syncStlOverlayVisibility();
      }
      function ensureStlSeries() {
        if (!lwChart) return;
        const dotted = (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dotted !== undefined)
          ? LightweightCharts.LineStyle.Dotted
          : (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Solid !== undefined
              ? LightweightCharts.LineStyle.Solid
              : 2);
        if (!stlTrendSeries) {
          stlTrendSeries = lwChart.addLineSeries({
            color: '#d84315',
            lineWidth: 2,
            priceScaleId: 'right',
            title: 'Trend',
          });
        }
        if (!stlSeasonSeries) {
          stlSeasonSeries = lwChart.addLineSeries({
            color: '#03a9f4',
            lineWidth: 1,
            priceScaleId: 'left',
            title: 'Seasonal',
          });
        }
        if (!stlResidSeries) {
          stlResidSeries = lwChart.addLineSeries({
            color: '#9c27b0',
            lineWidth: 1,
            lineStyle: dotted,
            priceScaleId: 'left',
            title: 'Residual',
          });
        }
        lwChart.priceScale('left').applyOptions({
          visible: true,
          scaleMargins: { top: 0.8, bottom: 0.05 },
        });
      }

      async function applyStlData(rows, meta) {
        const box = el('stlStatus');
        if (!rows || !rows.length) {
          clearStlOverlay('No STL data cached yet. Use Recalculate to compute.');
          return;
        }
        stlLastRows = rows.slice();
        stlLastMeta = meta || null;
        const periodValue = meta && Number(meta.period);
        if (Number.isFinite(periodValue) && periodValue >= 1) {
          stlLastPeriod = periodValue;
          if (stlAutoPeriod) {
            stlManualPeriod = periodValue;
            if (stlPeriodInput) stlPeriodInput.value = stlManualPeriod;
          }
        }
        updateStlInputsFromState();
        if (curType === 'line') {
          clearStlOverlay('Switch to candlestick view to see STL overlay.', true);
          return;
        }
        ensureStlSeries();
        const toSeriesData = (key) =>
          rows
            .map((r) => ({
              time: Math.floor(new Date(r.ts).getTime() / 1000),
              value: Number(r[key]),
            }))
            .filter((pt) => Number.isFinite(pt.value));
        const trendData = toSeriesData('trend');
        const seasonalData = toSeriesData('seasonal');
        const residData = toSeriesData('resid');
        stlTrendPoints = trendData.slice();
        stlSeasonPoints = seasonalData.slice();
        stlResidPoints = residData.slice();
        if (trendData.length && stlTrendSeries) stlTrendSeries.setData(trendData);
        if (seasonalData.length && stlSeasonSeries) stlSeasonSeries.setData(seasonalData);
        if (residData.length && stlResidSeries) stlResidSeries.setData(residData);
        if (trendData.length > 2) {
          const trendValues = trendData.map((pt) => Number(pt.value) || 0);

          stlSpeedPoints = [];
          for (let i = 1; i < trendValues.length; i += 1) {
            const speedVal = trendValues[i] - trendValues[i - 1];
            stlSpeedPoints.push({ time: trendData[i].time, value: speedVal });
          }

          stlAccelPoints = [];
          for (let i = 1; i < stlSpeedPoints.length; i += 1) {
            const accelVal = (stlSpeedPoints[i].value ?? 0) - (stlSpeedPoints[i - 1].value ?? 0);
            stlAccelPoints.push({ time: stlSpeedPoints[i].time, value: accelVal });
          }
        } else {
          stlTrendPoints = [];
          stlSeasonPoints = [];
          stlResidPoints = [];
          stlSpeedPoints = [];
          stlAccelPoints = [];
        }
        updateStlDerivativeSeries();
        const overlayPeriod = periodValue && Number.isFinite(periodValue)
          ? periodValue
          : (stlAutoPeriod ? stlLastPeriod : stlManualPeriod);
        updatePeriodOverlays(overlayPeriod && Number.isFinite(overlayPeriod) ? overlayPeriod : null);
        if (box) {
          const periodLabel = meta && meta.period ? meta.period : '—';
          const rangeLabel = meta && meta.start_ts && meta.end_ts ? ` • ${formatDateShort(meta.start_ts)} → ${formatDateShort(meta.end_ts)}` : '';
          const updatedIso = meta && (meta.updated || meta.created_at);
          const updatedLabel = updatedIso ? ` • run ${formatDateTime(updatedIso)}` : '';
          box.textContent = `STL period ${periodLabel}${rangeLabel} • ${rows.length} points${updatedLabel}`;
        }
        syncStlOverlayVisibility();
      }
      function ensureStlSeries() {
        if (!lwChart) return;
        const dotted = (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Dotted !== undefined)
          ? LightweightCharts.LineStyle.Dotted
          : (typeof LightweightCharts !== 'undefined' && LightweightCharts.LineStyle && LightweightCharts.LineStyle.Solid !== undefined
              ? LightweightCharts.LineStyle.Solid
              : 2);
        if (!stlTrendSeries) {
          stlTrendSeries = lwChart.addLineSeries({
            color: '#d84315',
            lineWidth: 2,
            priceScaleId: 'right',
            title: 'Trend',
          });
        }
        if (!stlSeasonSeries) {
          stlSeasonSeries = lwChart.addLineSeries({
            color: '#03a9f4',
            lineWidth: 1,
            priceScaleId: 'left',
            title: 'Seasonal',
          });
        }
        if (!stlResidSeries) {
          stlResidSeries = lwChart.addLineSeries({
            color: '#9c27b0',
            lineWidth: 1,
            lineStyle: dotted,
            priceScaleId: 'left',
            title: 'Residual',
          });
        }
        lwChart.priceScale('left').applyOptions({
          visible: true,
          scaleMargins: { top: 0.8, bottom: 0.05 },
        });
      }

      function clearStlOverlay(message, preserveData = false) {
        if (stlTrendSeries) stlTrendSeries.setData([]);
        if (stlSeasonSeries) stlSeasonSeries.setData([]);
        if (stlResidSeries) stlResidSeries.setData([]);
        if (!preserveData) {
          stlLastRows = [];
          stlLastMeta = null;
          stlLastPeriod = null;
          updatePeriodOverlays(null);
          stlTrendPoints = [];
          stlSeasonPoints = [];
          stlResidPoints = [];
        } else {
          if (!stlLastMeta) {
            stlLastRows = [];
          }
          updatePeriodOverlays(stlLastPeriod);
        }
        stlSpeedPoints = [];
        stlAccelPoints = [];
        updateStlDerivativeSeries();
        updateStlInputsFromState();
        if (lwChart) {
          lwChart.priceScale('left').applyOptions({ visible: false });
        }
        if (message) {
          const box = el('stlStatus');
          if (box) box.textContent = message;
        }
        syncStlOverlayVisibility();
      }
      async function refreshStlOverlay(options = {}) {
        const { runId = stlSelectedRunId } = options || {};
        const autoCompute = (() => { try { return localStorage.getItem(`stl_auto_compute:${currentSymbol()}:${currentTf()}`) === '1'; } catch { return false; } })();
        const statusBox = el('stlStatus');
        const symbol = currentSymbol();
        const tf = currentTf();
        if (!symbol || !tf) return;
        let startIso = stlAllData ? null : stlTargetStart;
        let endIso = stlAllData ? null : stlTargetEnd;
        if (!stlAllData) {
          if (!startIso && stlStartInput && stlStartInput.value) startIso = localInputToIso(stlStartInput.value);
          if (!endIso && stlEndInput && stlEndInput.value) endIso = localInputToIso(stlEndInput.value);
          if (!startIso || !endIso) {
            clearStlOverlay('Select a start and end datetime for STL.');
            if (statusBox) statusBox.textContent = 'Select a start and end datetime for STL.';
            return;
          }
          if (new Date(startIso) >= new Date(endIso)) {
            clearStlOverlay('STL start must be before end.');
            status('STL range invalid: start must be before end.');
            return;
          }
          stlTargetStart = startIso;
          stlTargetEnd = endIso;
        }
        try {
          const params = new URLSearchParams({
            symbol,
            tf,
            include_runs: '1',
            include_data: '1',
            all_data: stlAllData ? '1' : '0',
          });
          if (!stlAllData) {
            params.set('start', stlTargetStart);
            params.set('end', stlTargetEnd);
          }
          if (runId) params.set('run_id', String(runId));
          const limit = Math.max(10, Number(el('count').value) || 500);
          params.set('limit', String(limit));
          const r = await fetch(`/api/stl?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (!r.ok || !js.ok) {
            const message = `STL fetch failed: ${js.error || r.statusText}`;
            status(message);
            clearStlOverlay(message);
            return;
          }
          stlDatasetRange = js.dataset || stlDatasetRange;
          if (js.target_range) {
            stlAllData = !!js.target_range.all_data;
            stlTargetStart = js.target_range.start_ts || stlTargetStart;
            stlTargetEnd = js.target_range.end_ts || stlTargetEnd;
          } else if (stlAllData && stlDatasetRange) {
            stlTargetStart = stlDatasetRange.start_ts;
            stlTargetEnd = stlDatasetRange.end_ts;
          }
          updateStlInputsFromState();
          if (Array.isArray(js.runs)) {
            populateStlRuns(js.runs, js.selected_run_id || runId || null);
          }
          stlSelectedRunId = js.selected_run_id || runId || null;
          if (stlDeleteBtn) stlDeleteBtn.disabled = !stlSelectedRunId;
          const runMeta = js.selected_run
            ? {
                id: js.selected_run.id,
                period: js.selected_run.period,
                start_ts: js.selected_run.start_ts,
                end_ts: js.selected_run.end_ts,
                updated: js.selected_run.created_at,
                created_at: js.selected_run.created_at,
              }
            : null;
          if (js.rows && js.rows.length) {
            if (curType === 'line') {
              stlLastRows = js.rows.slice();
              stlLastMeta = runMeta;
              clearStlOverlay('Switch to candlestick view to see STL overlay.', true);
            } else {
              await applyStlData(js.rows, runMeta);
            }
          } else {
            const reason = js.reason || (js.needs_compute ? 'needs_compute' : 'no_rows');
            const message =
              reason === 'range_mismatch'
                ? 'No STL run covers the requested range. Use Recalculate to compute.'
                : reason === 'dataset_extended'
                  ? 'New data detected. Re-run STL to refresh.'
                  : 'No STL data cached yet. Use Recalculate to compute.';
            clearStlOverlay(message);
            if (statusBox) statusBox.textContent = message;
          }
          if (js.needs_compute && autoCompute) {
            if (!stlPendingCompute) {
              stlPendingCompute = true;
              triggerStl('current');
            }
          } else if (!js.needs_compute) {
            stlPendingCompute = false;
          }
        } catch (err) {
          console.warn('STL fetch failed', err);
          clearStlOverlay('STL fetch failed.');
          status('STL fetch failed.');
        }
      }
      async function triggerStl(scope, options = {}) {
        const opts = options || {};
        const symbol = opts.symbol || currentSymbol();
        const tf = opts.timeframe || currentTf();
        const silent = !!opts.silent;
        const skipPref = !!opts.skipPref;
        const sameSymbol = symbol === currentSymbol();
        const sameTf = tf === currentTf();
        if (!skipPref && sameSymbol) queuePrefUpdate('last_symbol', symbol);
        if (!skipPref && sameTf) queuePrefUpdate('last_tf', tf);
        const payload = { scope, symbol, timeframe: tf };
        let periodValue = null;
        if (opts.period != null) {
          periodValue = opts.period;
        } else if (sameSymbol && sameTf && !stlAutoPeriod) {
          periodValue = stlManualPeriod;
        }
        if (periodValue != null) {
          if (!Number.isFinite(periodValue) || periodValue < 3) {
            if (!silent) {
              status('STL period must be >= 3.');
              if (sameTf && stlPeriodInput) stlPeriodInput.focus();
            }
            return;
          }
          payload.period = Math.round(periodValue);
          if (!skipPref && sameSymbol && sameTf && !stlAutoPeriod) {
            queuePrefUpdate('stl_manual_period', payload.period);
          }
        }
        let allDataFlag;
        if (opts.allData != null) {
          allDataFlag = opts.allData ? 1 : 0;
        } else {
          allDataFlag = (sameSymbol && sameTf) ? (stlAllData ? 1 : 0) : 1;
        }
        payload.all_data = allDataFlag;
        if (payload.all_data !== 1) {
          const startIso = opts.start || stlTargetStart || (stlStartInput && stlStartInput.value ? localInputToIso(stlStartInput.value) : null);
          const endIso = opts.end || stlTargetEnd || (stlEndInput && stlEndInput.value ? localInputToIso(stlEndInput.value) : null);
          if (!startIso || !endIso) {
            if (!silent) status('Select a start and end datetime before recalculating STL.');
            return;
          }
          if (new Date(startIso) >= new Date(endIso)) {
            if (!silent) status('STL range invalid: start must be before end.');
            return;
          }
          payload.start = startIso;
          payload.end = endIso;
          if (sameSymbol && sameTf) {
            stlTargetStart = startIso;
            stlTargetEnd = endIso;
          }
        }
        if (scope === 'symbol_all_tf') {
          payload.timeframes = ALL_TFS;
        } else if (scope === 'timeframe_all_symbols') {
          payload.symbols = APP_SYMBOLS;
        } else if (scope === 'all') {
          payload.symbols = APP_SYMBOLS;
          payload.timeframes = ALL_TFS;
        }
        const statusBox = !silent ? el('stlStatus') : null;
        if (statusBox) statusBox.textContent = `Scheduling STL (${scope})...`;
        if (sameSymbol && sameTf && !silent) stlPendingCompute = true;
        try {
          const r = await fetch('/api/stl/compute', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            cache: 'no-store',
          });
          const js = await r.json().catch(() => ({}));
          if (!r.ok || !js || js.ok !== true) {
            const message = (js && js.error) || r.statusText || 'STL schedule failed';
            if (statusBox) statusBox.textContent = `STL schedule failed: ${message}`;
            if (!silent) status(`STL schedule failed: ${message}`);
            if (sameSymbol && sameTf) stlPendingCompute = false;
          } else if (!silent) {
            status(`STL tasks scheduled (${js.scheduled} jobs, scope ${js.scope})`);
          }
        } catch (err) {
          if (!silent) {
            console.error('STL schedule failed', err);
            if (statusBox) statusBox.textContent = `STL schedule failed: ${err.message || err}`;
            status(`STL schedule failed: ${err.message || err}`);
          }
          if (sameSymbol && sameTf) stlPendingCompute = false;
        }
      }
      function connectUpdates(retryDelay = 2000) {
        const proto = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${proto}://${window.location.host}/ws/updates`;
        const ws = new WebSocket(wsUrl);

        ws.addEventListener('open', () => {
          debugLog('[WS] connected', wsUrl);
        });

        ws.addEventListener('message', (ev) => {
          let data;
          try {
            data = JSON.parse(ev.data);
          } catch (err) {
            debugWarn('[WS] message parse failed', err);
            return;
          }
          if (!data || !data.type) return;
          if (data.type === 'fetch_complete') {
            handleFetchEvent(data);
          } else if (data.type === 'news_update') {
            handleNewsEvent(data);
          } else if (data.type === 'stl_complete') {
            handleStlEvent(data);
          } else if (data.type === 'balance_update') {
            refreshBalanceSeries();
          } else if (data.type === 'closed_deals_update') {
            refreshClosedDealsSeries();
          }
        });

        ws.addEventListener('close', () => {
          debugLog('[WS] disconnected, retrying in', retryDelay, 'ms');
          setTimeout(() => connectUpdates(Math.min(retryDelay * 1.5, 10000)), retryDelay);
        });

        ws.addEventListener('error', (err) => {
          debugWarn('[WS] error', err);
          ws.close();
        });
      }

      connectUpdates();
      window.addEventListener('load', () => {
        // Initialize charts only after accounts are loaded so PnL respects selection
        requestAnimationFrame(async () => {
          try { await loadAccountsSelect(); } catch {}
          try { await ensureSelectedAccountSession?.(); } catch {}
          ensureBalanceChart();
          await refreshBalanceSeries();
          await refreshClosedDealsSeries();
        });
      });
      // Initialize freshness indicators
      (async () => { try { await refreshHealthFreshness(); } catch {} })();
      (async () => { try { await loadAutoBasicPref(); await loadAutoTechPref(); } catch {} })();
      (async () => { try { await refreshTechFreshness(); } catch {} })();
      (async () => { try { await loadLatestAiPlanPreview(); } catch {} })();

      
      async function refreshChart() {
        const symbol = currentSymbol();
        const tf = currentTf();
        const limit = Math.max(10, currentBarsLimit());
        status(`Loading data (${symbol} ${tf}, limit ${limit})...`);
        try {
          const r = await fetch(`/api/data?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&limit=${encodeURIComponent(limit)}`, { cache: 'no-store' });
          const js = await r.json();
          const rows = js.rows || [];
          lastPriceRows = rows.slice();
          const labels = rows.map((row) => row.ts);
          const closes = rows.map((row) => {
            const v = Number(row.close);
            return Number.isFinite(v) ? v : null;
          });
          const boll = computeBollingerBands(closes);
          if (curType === 'line') {
            if (!chart) { makeChart('line'); }
            chart.data.labels = labels;
            chart.data.datasets[0].data = closes;
            if (chart.data.datasets[1]) chart.data.datasets[1].data = boll.middle;
            if (chart.data.datasets[2]) chart.data.datasets[2].data = boll.upper;
            if (chart.data.datasets[3]) chart.data.datasets[3].data = boll.lower;
            chart.update('none');
          } else {
            if (!lwChart || !lwSeries) { makeChart('candlestick'); }
            const data = rows.map(r => ({
              time: Math.floor(new Date(r.ts).getTime() / 1000),
              open: Number(r.open),
              high: Number(r.high),
              low: Number(r.low),
              close: Number(r.close)
            }));
            lwSeries.setData(data);
            // Cache bar times for precise anchoring
            lwLastTimes = data.map(d => d.time);
            const toLwPoints = (values) =>
              rows
                .map((row, idx) => {
                  const val = values[idx];
                  if (val == null || !Number.isFinite(val)) return null;
                  return { time: Math.floor(new Date(row.ts).getTime() / 1000), value: val };
                })
                .filter(Boolean);
            if (lwBollingerUpper) lwBollingerUpper.setData(toLwPoints(boll.upper));
            if (lwBollingerLower) lwBollingerLower.setData(toLwPoints(boll.lower));
            if (lwBollingerMid) lwBollingerMid.setData(toLwPoints(boll.middle));
            // Recompute boundary times using current period
            const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
            if (Number.isFinite(overlayPeriod)) {
              computePeriodBoundaryTimes(Math.max(1, Math.floor(overlayPeriod)));
            } else {
              periodBoundaryTimes = [];
            }
            redrawPeriodLines();
            const visibleRange = lwChart.timeScale().getVisibleRange();
            const hasRange = visibleRange && visibleRange.from != null && visibleRange.to != null;
            if (!lwInitialFitted || !hasRange) {
              // First render: fit once and rely on subscription to broadcast
              lwSyncing = true;
              lwChart.timeScale().fitContent();
              lwSyncing = false;
              lwInitialFitted = true;
              lwSubscriptionsEnabled = true;
            } else {
              // Preserve user view; do not auto-fit on refresh
              const visibleLogical = lwChart.timeScale().getVisibleLogicalRange();
              currentLogicalRange = visibleLogical || currentLogicalRange || null;
              lwSubscriptionsEnabled = true;
            }
          }
          updateIndicatorCharts(rows);
          const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
          updatePeriodOverlays(overlayPeriod && Number.isFinite(overlayPeriod) ? overlayPeriod : null);
          status(`Loaded ${rows.length} bars for ${symbol} ${tf}`);
          await refreshStlOverlay({});
          syncStlOverlayVisibility();
        } catch (err) {
          console.error('Refresh failed', err);
          status('Refresh failed');
          updateIndicatorCharts([]);
          if (chart && chart.data && chart.data.datasets) {
            chart.data.labels = [];
            chart.data.datasets.forEach((ds) => {
              ds.data = [];
            });
            chart.update('none');
          }
          if (lwBollingerUpper) lwBollingerUpper.setData([]);
          if (lwBollingerLower) lwBollingerLower.setData([]);
          if (lwBollingerMid) lwBollingerMid.setData([]);
          clearStlOverlay('STL unavailable (chart refresh failed).');
        }
      }

      async function fetchAndSave(opts = {}) {
        const isEvent = opts && typeof opts === 'object' && typeof opts.preventDefault === 'function';
        if (isEvent) {
          opts.preventDefault();
        }
        const options = isEvent ? {} : (opts || {});
        const symbol = currentSymbol();
        const tf = currentTf();
        const count = el('count').value;
        const mode = (options.mode || 'inc').toString();
        const background = options.background !== false;
        const refreshFirst = options.refreshFirst !== false;
        queuePrefUpdate('last_symbol', symbol);
        queuePrefUpdate('last_tf', tf);
        queuePrefUpdate('last_count', count);
        if (refreshFirst) {
          try {
            status(`Loading cached data (${symbol} ${tf})...`);
            await refreshChart();
          } catch (err) {
            console.warn('[App] Cached refresh failed', err);
          }
        }
        status(background ? `Scheduling background fetch (${symbol} ${tf})...` : `Fetching from MT5 (${symbol} ${tf})...`);
        try {
          const params = new URLSearchParams({
            symbol,
            tf,
            count,
            mode,
          });
          params.set('persist', '1');
          if (background) params.set('background', '1');
          const r = await fetch(`/api/fetch?${params.toString()}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js.ok) {
            const note = js.note ? ` ${js.note}` : '';
            if (background) {
              if (js.scheduled || (!js.inserted && !js.fetched)) {
                status(`Background fetch scheduled for ${symbol} ${tf}.${note}`);
              } else if ((js.inserted || 0) > 0) {
                status(`Background fetch completed immediately (${symbol} ${tf}, +${js.inserted || 0} bars).`);
                scheduleChartRefresh(`${symbol}/${tf} immediate`);
              } else {
                status(`Background fetch acknowledged for ${symbol} ${tf}.${note}`);
              }
            } else {
              status(`Inserted/updated ${js.inserted || 0} bars for ${symbol} ${tf}`);
              await refreshChart();
            }
          } else {
            status(`Fetch error: ${js.error || r.statusText}`);
          }
        } catch (e) {
          console.error('Fetch failed', e);
          status(`Fetch failed: ${e.message || e}`);
        }
      }

      async function backgroundFetch(scope, opts = {}) {
        const symbol = currentSymbol();
        const tf = currentTf();
        const count = el('count').value;
        queuePrefUpdate('last_symbol', symbol);
        queuePrefUpdate('last_tf', tf);
        queuePrefUpdate('last_count', count);
        const payload = {
          scope,
          symbol,
          count,
          mode: opts.mode || 'inc'
        };
        if (scope === 'symbol_tf') {
          payload.timeframe = tf;
        }
        if (opts.timeframes) {
          payload.timeframes = opts.timeframes.join(',');
        }
        status(`Scheduling background fetch (${scope})...`);
        try {
          const r = await fetch('/api/fetch_bulk', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            cache: 'no-store'
          });
          const js = await r.json().catch(() => ({}));
          if (r.ok && js.ok) {
            status(`Background fetch queued (${js.jobs || 0} jobs, scope ${scope}).`);
          } else {
            status(`Background fetch error: ${js.error || r.statusText}`);
          }
        } catch (e) {
          console.error('Bulk fetch failed', e);
          status(`Background fetch failed: ${e.message || e}`);
        }
      }

      // Controls
      el('btnFetch').addEventListener('click', fetchAndSave);
      el('btnRefresh').addEventListener('click', refreshChart);
      // Auto-fetch when user changes symbol or timeframe
      el('symbol').addEventListener('change', async () => {
        try { localStorage.setItem('last_symbol', currentSymbol()); } catch {}
        stlSelectedRunId = null;
        stlPendingCompute = false;
        stlLastRows = [];
        stlLastMeta = null;
        stlOverlayData.clear();
        stlOverlayLoading.clear();
        clearAllStlOverlaySeries();
        buildStlOverlayControls();
        applyTechWindowDefault(false);
        ensureStrategyForKind(isFxPair(currentSymbol()) ? 'forex_pair' : 'stock');
        queuePrefUpdate('last_symbol', currentSymbol());
        try {
          debugLog('[App] Auto-fetch on symbol change');
          lwInitialFitted = false;
          await fetchAndSave();
          await refreshPositions();
        } catch (e) {
          debugWarn('[App] Auto-fetch failed', e);
        } finally {
          await refreshNews();
          await refreshHealthFreshness();
          await loadAutoBasicPref();
          await loadAutoTechPref();
          await loadAutoPeriodicPrefs();
          await loadLatestAiPlanPreview();
          if (autoTimer) startAuto({ announce: false });
          ensureAutoPeriodicTimer();
          // Inline AI trade plan preview disabled on symbol change (run from modal Start)
        }
      });
      const tfSel = document.getElementById('tf');
      if (tfSel) tfSel.addEventListener('change', async () => {
        try { localStorage.setItem('last_tf', currentTf()); } catch {}
        stlSelectedRunId = null;
        stlPendingCompute = false;
        stlLastRows = [];
        stlLastMeta = null;
        stlOverlayData.clear();
        stlOverlayLoading.clear();
        clearAllStlOverlaySeries();
        buildStlOverlayControls();
        applyTechWindowDefault(false);
        ensureStrategyForKind(isFxPair(currentSymbol()) ? 'forex_pair' : 'stock');
        queuePrefUpdate('last_tf', currentTf());
        try {
          debugLog('[App] Auto-fetch on timeframe change');
          lwInitialFitted = false;
          await fetchAndSave();
        } catch (e) {
          debugWarn('[App] Auto-fetch failed', e);
        } finally {
          await refreshNews();
          await refreshHealthFreshness();
          await loadAutoBasicPref();
          await loadAutoTechPref();
          await loadAutoPeriodicPrefs();
          await loadLatestAiPlanPreview();
          if (autoTimer) startAuto({ announce: false });
          ensureAutoPeriodicTimer();
          // Inline AI trade plan preview disabled on timeframe change (run from modal Start)
        }
      });
      if (chartShiftInput) {
        chartShiftOn = !!chartShiftInput.checked;
        chartShiftInput.addEventListener('change', () => {
          chartShiftOn = !!chartShiftInput.checked;
          const ro = getRightOffset();
          try {
            if (lwChart) lwChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwVolChart) lwVolChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwRsiChart) lwRsiChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwMacdChart) lwMacdChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwDerivChart) lwDerivChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwAtrChart) lwAtrChart.applyOptions({ timeScale: { rightOffset: ro } });
            if (lwAdxChart) lwAdxChart.applyOptions({ timeScale: { rightOffset: ro } });
          } catch (e) { /* ignore */ }
          // persist preference
          try { queuePrefUpdate('chart_shift', chartShiftOn ? '1' : '0'); } catch (e) {}
        });
      }
      const countSel = document.getElementById('count');
      if (countSel) countSel.addEventListener('change', async () => {
        queuePrefUpdate('last_count', el('count').value);
        try {
          debugLog('[App] Bars limit changed');
          await refreshChart();
          // Kick off a deeper background fill for this symbol/timeframe
          await backgroundFetch('symbol_tf', { mode: 'full_async' });
        } catch (e) { console.warn('[App] Count change refresh failed', e); }
      });
      const btnFetchCurrentBg = document.getElementById('btnFetchCurrentBg');
      if (btnFetchCurrentBg) btnFetchCurrentBg.addEventListener('click', () => backgroundFetch('symbol_tf', { mode: 'full_async' }));
      const btnFetchSymbolAll = document.getElementById('btnFetchSymbolAll');
      if (btnFetchSymbolAll) btnFetchSymbolAll.addEventListener('click', () => backgroundFetch('symbol_all_tf', { mode: 'inc' }));
      const btnFetchAll = document.getElementById('btnFetchAll');
      if (btnFetchAll) btnFetchAll.addEventListener('click', () => backgroundFetch('all_symbols', { mode: 'inc' }));
      const btnStlCurrent = el('btnStlCurrent');
      if (btnStlCurrent) btnStlCurrent.addEventListener('click', () => triggerStl('current'));
      if (stlPeriodLinesToggle) stlPeriodLinesToggle.addEventListener('change', () => {
        showPeriodLines = !!stlPeriodLinesToggle.checked;
        const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
        const effPeriod = overlayPeriod && Number.isFinite(overlayPeriod) ? Math.max(1, Math.floor(overlayPeriod)) : null;
        if (effPeriod) computePeriodBoundaryTimes(effPeriod);
        updatePeriodOverlays(effPeriod);
        redrawPeriodLines();
      });
      if (stlDerivativeToggle) stlDerivativeToggle.addEventListener('change', () => {
        updateStlDerivativeSeries();
      });
      if (stlAccelerationToggle) stlAccelerationToggle.addEventListener('change', () => {
        updateStlDerivativeSeries();
      });
      const btnStlSymbolAll = el('btnStlSymbolAll');
      if (btnStlSymbolAll) btnStlSymbolAll.addEventListener('click', () => triggerStl('symbol_all_tf'));
      const btnStlTfAll = el('btnStlTfAll');
      if (btnStlTfAll) btnStlTfAll.addEventListener('click', () => triggerStl('timeframe_all_symbols'));
      const btnStlAll = el('btnStlAll');
      if (btnStlAll) btnStlAll.addEventListener('click', () => triggerStl('all'));
      if (stlAllToggle) stlAllToggle.addEventListener('change', () => {
        stlAllData = !!stlAllToggle.checked;
        if (stlAllData && stlDatasetRange) {
          stlTargetStart = stlDatasetRange.start_ts;
          stlTargetEnd = stlDatasetRange.end_ts;
        }
        updateStlInputsFromState();
        refreshStlOverlay({});
      });
      if (stlAutoToggle) stlAutoToggle.addEventListener('change', () => {
        stlAutoPeriod = !!stlAutoToggle.checked;
        queuePrefUpdate('stl_auto_period', stlAutoPeriod ? '1' : '0');
        if (stlAutoPeriod && Number.isFinite(stlLastPeriod) && stlLastPeriod >= 1) {
          stlManualPeriod = stlLastPeriod;
          if (stlPeriodInput) stlPeriodInput.value = stlManualPeriod;
        }
        updateStlInputsFromState();
        const overlayPeriod = stlAutoPeriod ? stlLastPeriod : stlManualPeriod;
        const effPeriod2 = overlayPeriod && Number.isFinite(overlayPeriod) ? Math.max(1, Math.floor(overlayPeriod)) : null;
        if (effPeriod2) computePeriodBoundaryTimes(effPeriod2);
        updatePeriodOverlays(effPeriod2);
      });
      if (stlPeriodInput) stlPeriodInput.addEventListener('change', () => {
        const val = Number(stlPeriodInput.value);
        if (!Number.isFinite(val) || val < 3) {
          status('STL period must be >= 3.');
          stlPeriodInput.value = stlManualPeriod;
          return;
        }
        stlManualPeriod = Math.round(val);
        stlPeriodInput.value = stlManualPeriod;
        queuePrefUpdate('stl_manual_period', stlManualPeriod);
        if (!stlAutoPeriod) updatePeriodOverlays(stlManualPeriod);
      });
      if (stlStartInput) stlStartInput.addEventListener('change', () => {
        if (stlAllData) return;
        const iso = localInputToIso(stlStartInput.value);
        if (!iso) { status('Invalid STL start time.'); return; }
        stlTargetStart = iso;
        if (stlTargetEnd && new Date(stlTargetStart) >= new Date(stlTargetEnd)) {
          status('STL range invalid: start must be before end.');
          return;
        }
        refreshStlOverlay({});
      });
      if (stlEndInput) stlEndInput.addEventListener('change', () => {
        if (stlAllData) return;
        const iso = localInputToIso(stlEndInput.value);
        if (!iso) { status('Invalid STL end time.'); return; }
        stlTargetEnd = iso;
        if (stlTargetStart && new Date(stlTargetStart) >= new Date(stlTargetEnd)) {
          status('STL range invalid: start must be before end.');
          return;
        }
        refreshStlOverlay({});
      });
      if (stlRunsSelect) stlRunsSelect.addEventListener('change', () => {
        const val = stlRunsSelect.value;
        if (val === '__more__') {
          stlRunsShown = Math.min(stlRunsAll.length, stlRunsShown + stlRunsPageSize);
          renderStlRunsList(stlSelectedRunId);
          // keep selection on 'Latest (auto)'
          stlRunsSelect.value = '';
          if (stlDeleteBtn) stlDeleteBtn.disabled = true;
          return;
        }
        stlSelectedRunId = val ? Number(val) : null;
        if (stlDeleteBtn) stlDeleteBtn.disabled = !stlSelectedRunId;
        refreshStlOverlay({ runId: stlSelectedRunId });
      });
      if (stlDeleteBtn) stlDeleteBtn.addEventListener('click', async () => {
        const selected = stlRunsSelect && stlRunsSelect.value ? stlRunsSelect.value : '';
        if (!selected) {
          status('Select a saved STL run to delete.');
          return;
        }
        if (typeof window.confirm === 'function' && !window.confirm(`Delete STL run ${selected}?`)) return;
        try {
          const resp = await fetch(`/api/stl/run/${encodeURIComponent(selected)}`, { method: 'DELETE', cache: 'no-store' });
          const js = await resp.json().catch(() => ({}));
          if (!resp.ok || !js.ok) {
            status(`Delete failed: ${js.error || resp.statusText}`);
          } else {
            status(`Deleted STL run ${selected}`);
            stlSelectedRunId = null;
            stlLastRows = [];
            stlLastMeta = null;
            refreshStlOverlay({});
          }
        } catch (err) {
          status(`Delete failed: ${err.message || err}`);
        }
      });
      const volumeInput = el('volume');
      if (volumeInput) volumeInput.addEventListener('change', () => queuePrefUpdate('last_volume', volumeInput.value));
      const slInput = el('sl');
      if (slInput) slInput.addEventListener('change', () => queuePrefUpdate('last_sl', slInput.value));
      const tpInput = el('tp');
      if (tpInput) tpInput.addEventListener('change', () => queuePrefUpdate('last_tp', tpInput.value));
      const fastInput = el('fast');
      if (fastInput) fastInput.addEventListener('change', () => queuePrefUpdate('last_fast', fastInput.value));
      const slowInput = el('slow');
      if (slowInput) slowInput.addEventListener('change', () => queuePrefUpdate('last_slow', slowInput.value));
      document.querySelectorAll('input[name="ctype"]').forEach(r => r.addEventListener('change', (e) => {
        queuePrefUpdate('chart_type', e.target.value);
        const nextType = e.target.value;
        // Disable LW subscriptions while switching chart type to avoid spurious sync
        lwSubscriptionsEnabled = false;
        makeChart(nextType);
        refreshChart();
        // Re-enable only for candlestick once data is applied in refreshChart
      }));

      let autoTimer = null;
      const btnAuto = el('btnAuto');
      const computeAutoInterval = () => {
        const tfEl = el('tf');
        const tf = tfEl && tfEl.value ? tfEl.value : 'M1';
        const minuteMs = 60000;
        if (tf.startsWith('M')) return minuteMs;
        if (tf.startsWith('H')) return 60 * minuteMs;
        return 15 * minuteMs;
      };
      const updateAutoUi = (running) => {
        if (btnAuto) btnAuto.textContent = running ? 'Stop Auto' : 'Start Auto';
      };
      const stopAuto = ({ announce = true } = {}) => {
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        updateAutoUi(false);
        if (announce) status('Auto stopped');
      };
      const startAuto = ({ announce = true, immediate = false } = {}) => {
        const ms = computeAutoInterval();
        if (!ms) return;
        if (autoTimer) clearInterval(autoTimer);
        autoTimer = setInterval(fetchAndSave, ms);
        updateAutoUi(true);
        if (announce) status('Auto started');
        if (immediate) fetchAndSave();
      };
      if (btnAuto) {
        btnAuto.addEventListener('click', () => {
          if (autoTimer) {
            stopAuto();
          } else {
            startAuto({ announce: true, immediate: true });
          }
        });
      }

      async function trade(side, ctx = {}) {
        const symbol = currentSymbol();
        const volume = el('volume').value;
        queuePrefUpdate('last_volume', volume);
        queuePrefUpdate('last_sl', el('sl').value);
        queuePrefUpdate('last_tp', el('tp').value);
        const tf = currentTf();
        status(`${side.toUpperCase()} submitting…`);
        // Respect global account selection
        try {
          const acct = resolveSelectedAccountValue();
          if (acct) {
            status(`Switching account → ${acct}`);
            const rlogin = await fetch('/api/account/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ login: acct }), cache:'no-store' });
            const jlogin = await rlogin.json().catch(()=>({}));
            if (!rlogin.ok || !(jlogin && jlogin.ok)) { status('Account login failed — using current session'); }
          }
        } catch {}
        const sl = el('sl').value; const tp = el('tp').value;
        const body = new URLSearchParams({ symbol, side, volume, sl, tp, tf });
        // Optional signal context
        if (ctx && typeof ctx === 'object') {
          if (ctx.strategy) body.set('strategy', String(ctx.strategy));
          if (ctx.fast != null) body.set('fast', String(ctx.fast));
          if (ctx.slow != null) body.set('slow', String(ctx.slow));
          if (ctx.reason) body.set('reason', String(ctx.reason));
          if (ctx.source) body.set('source', String(ctx.source));
        }
        const r = await fetch(`/api/trade`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body, cache: 'no-store' });
        const js = await r.json().catch(() => ({}));
        if (js.ok) {
          const ord = js && js.result ? ` order=${js.result.order||''} deal=${js.result.deal||''}` : '';
          status(`${side.toUpperCase()} ok${ord}`);
          await refreshChart();
          await refreshPositions();
          // Open history modal to show most recent executed orders for this symbol/TF
          try { openSignalHistoryModal({ auto: true }); } catch (_) {}
        } else {
          status(`Trade error: ${js.error || r.statusText}`);
        }
      }

      function openCloseModal(defaultScope = 'current') {
        const modal = el('closeModal');
        if (!modal) return;
        const sym = currentSymbol();
        const txt = el('closeModalText');
        if (txt) txt.textContent = `Close all open positions for ${sym} (Current) or across ALL symbols?`;
        modal.dataset.scope = (defaultScope === 'all') ? 'all' : 'current';
        console.log('[Close] open modal scope=', modal.dataset.scope);
        // reset toggles
        const cL = el('chkCloseLong'); if (cL) cL.checked = false;
        const cS = el('chkCloseShort'); if (cS) cS.checked = false;
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden','false');
      }

      function hideCloseModal() { const m = el('closeModal'); if (m) { m.style.display = 'none'; m.setAttribute('aria-hidden','true'); } }

      async function doClose(scope) {
        const symbol = currentSymbol();
        const effScope = scope || (el('closeModal') && el('closeModal').dataset.scope) || 'current';
        const cL = el('chkCloseLong'); const cS = el('chkCloseShort');
        const wantLong = !!(cL && cL.checked); const wantShort = !!(cS && cS.checked);
        if (!wantLong && !wantShort) { status('Select at least one side (Long/Short) to close.'); return; }
        const sideParam = (wantLong && wantShort) ? 'both' : (wantLong ? 'long' : 'short');
        status(`Closing positions (${effScope}, ${sideParam})...`);
        console.log('[Close] confirm scope=', effScope, 'symbol=', symbol);
        // simple effect: disable buttons while closing
        const btnCur = document.getElementById('btnConfirmCloseCurrent');
        const btnAll = document.getElementById('btnConfirmCloseAll');
        const prevCur = btnCur ? btnCur.textContent : '';
        const prevAll = btnAll ? btnAll.textContent : '';
        if (btnCur) { btnCur.disabled = true; btnCur.textContent = 'Closing…'; }
        if (btnAll) { btnAll.disabled = true; btnAll.textContent = 'Closing…'; }
        try {
          let url;
          let opts;
          if (effScope === 'all') {
            url = `/api/close?scope=all&side=${encodeURIComponent(sideParam)}`;
            opts = { method:'POST', cache:'no-store' };
          } else {
            const body = new URLSearchParams({ symbol });
            url = `/api/close?side=${encodeURIComponent(sideParam)}`;
            opts = { method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' }, body, cache:'no-store' };
          }
          const r = await fetch(url, opts);
          const js = await r.json().catch(()=>({}));
          if (r.ok && js && js.ok) {
            const n = Number.isFinite(Number(js.closed_count)) ? Number(js.closed_count) : (Array.isArray(js.closed) ? js.closed.length : 0);
            status(`Closed ${n} position(s) [${js.scope||effScope}]`);
            try { console.log('[Close] response', js); } catch {}
            // If detailed closed array present, log a compact summary of retcodes
            try {
              if (Array.isArray(js.closed)) {
                const codes = js.closed.map(x => (x && typeof x === 'object' ? x.retcode : null)).filter(x => x != null);
                console.log('[Close] retcodes', codes);
              }
            } catch {}
            await refreshChart();
            await refreshPositions();
          } else {
            status(`Close error: ${js.error || r.statusText}`);
          }
        } catch (e) {
          status(`Close error: ${e && e.message || e}`);
        } finally {
          if (btnCur) { btnCur.disabled = false; btnCur.textContent = prevCur; }
          if (btnAll) { btnAll.disabled = false; btnAll.textContent = prevAll; }
          hideCloseModal();
        }
      }

      async function refreshPositions() {
        const symbol = currentSymbol();
        try { await ensureSelectedAccountSession?.(); } catch {}
        const r = await fetch(`/api/positions?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
        const js = await r.json().catch(() => ({}));
        if (js.ok) {
          const list = (js.positions || []).map(p => `#${p.ticket} ${p.type===0?'BUY':'SELL'} vol=${p.volume} @ ${p.price_open} pnl=${p.profit}`);
          el('positionsBox').textContent = list.length ? list.join('\n') : 'No open positions.';
        } else {
          el('positionsBox').textContent = `Positions error: ${js.error || r.statusText}`;
        }
      }
      async function runStrategyTop() {
        const symbol = currentSymbol();
        const tf = currentTf();
        const fast = 20, slow = 50;
        const btn = document.getElementById('btnRunStratTop');
        const dot = document.getElementById('signalDot');
        const prev = btn ? btn.textContent : '';
        if (btn) { btn.disabled = true; btn.textContent = 'Running…'; }
        try {
          const r = await fetch(`/api/strategy/run?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&fast=${fast}&slow=${slow}`, { cache:'no-store' });
          const js = await r.json();
          const sig = js && js.signal ? (js.signal.signal || js.signal) : 'hold';
          lastSignal = sig;
          updateSignalUI(sig, js.signal && js.signal.reason);
          // brief visual feedback
          if (dot) { dot.classList.remove('pulse'); void dot.offsetWidth; dot.classList.add('pulse'); }
          if (btn) { btn.textContent = `Run ✓ ${sig.toString().toUpperCase()}`; }
          setTimeout(() => { if (btn) { btn.textContent = prev || 'Run'; btn.disabled = false; } }, 900);
          if (typeof tradeState !== 'undefined' && tradeState) {
            if (sig === 'buy') tradeState.action = 'BUY';
            else if (sig === 'sell') tradeState.action = 'SELL';
          }
        } catch (e) {
          console.error('Strategy fetch failed', e);
          updateSignalUI('hold', 'error');
          if (btn) { btn.textContent = 'Run ✕ Error'; setTimeout(()=>{ btn.textContent = prev || 'Run'; btn.disabled = false; }, 1200); }
        }
      }
      document.getElementById('btnRunStratTop').addEventListener('click', runStrategyTop);
      document.getElementById('btnTradeSignalTop').addEventListener('click', () => {
        if (lastSignal === 'buy' || lastSignal === 'sell') trade(lastSignal, { source: 'topbar', strategy: 'sma_crossover', fast: 20, slow: 50, reason: lastSignalReason });
      });
      document.getElementById('btnAutoStrat').addEventListener('click', (ev) => {
        if (autoStratTimer) {
          clearInterval(autoStratTimer); autoStratTimer = null; ev.target.textContent = 'Auto Off';
        } else {
          runStrategyTop();
          autoStratTimer = setInterval(runStrategyTop, 15000); // every 15s
          ev.target.textContent = 'Auto On';
        }
      });
      // initial strategy read
      runStrategyTop();
      // Always fetch latest AI trade plan for current symbol/TF
      setTimeout(() => { try { loadLatestAiPlanPreview(); } catch (_) {} }, 200);

      // Strategy panel actions
      async function runStrategy() {
        const symbol = currentSymbol();
        const tf = currentTf();
        const fast = el('fast').value || '20';
        const slow = el('slow').value || '50';
        queuePrefUpdate('last_fast', fast);
        queuePrefUpdate('last_slow', slow);
        try {
          const r = await fetch(`/api/strategy/run?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&fast=${encodeURIComponent(fast)}&slow=${encodeURIComponent(slow)}`, { cache:'no-store' });
          const js = await r.json().catch(() => ({}));
          if (js && js.signal) {
            lastSignal = js.signal.signal || js.signal;
            const reason = js.signal.reason ? ` (${js.signal.reason})` : '';
            el('stratStatus').textContent = `Signal: ${lastSignal.toUpperCase()}${reason}`;
            el('btnTradeSignal').disabled = !(lastSignal === 'buy' || lastSignal === 'sell');
          } else {
            el('stratStatus').textContent = `Strategy error: ${js.error || r.statusText}`;
            el('btnTradeSignal').disabled = true;
          }
        } catch (err) {
          console.error('Strategy fetch failed', err);
          el('stratStatus').textContent = 'Strategy error';
          el('btnTradeSignal').disabled = true;
        }
      }
      const btnRunStrat = document.getElementById('btnRunStrat');
      if (btnRunStrat) btnRunStrat.addEventListener('click', runStrategy);
      const btnTradeSignal = document.getElementById('btnTradeSignal');
      if (btnTradeSignal) btnTradeSignal.addEventListener('click', () => {
        if (lastSignal === 'buy' || lastSignal === 'sell') {
          const f = Number(el('fast').value || 20);
          const s = Number(el('slow').value || 50);
          trade(lastSignal, { source: 'panel', strategy: 'sma_crossover', fast: f, slow: s, reason: lastSignalReason });
        }
      });
      // Closed orders controls
      const btnFetchClosed = document.getElementById('btnFetchClosed');
      const btnPurgeClosed = document.getElementById('btnPurgeClosed');
      if (btnFetchClosed) btnFetchClosed.addEventListener('click', async () => {
        const prev = btnFetchClosed.textContent;
        btnFetchClosed.disabled = true; btnFetchClosed.textContent = 'Fetching…';
        try {
          // Hit MT5 to upsert latest into DB for selected account, then reload
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : '';
          let url = '/api/account/closed_deals?days=5000&source=mt5&debug=1&nonzero=1';
          if (acct) url += `&account=${encodeURIComponent(acct)}`;
          const mt5Res = await fetch(url, { cache: 'no-store' });
          const mt5Js = await mt5Res.json().catch(()=>({}));
          try {
            console.debug('[PnL] mt5 fetch deals=', (mt5Js.deals||[]).length, 'cum=', (mt5Js.cum||[]).length);
            const deals = Array.isArray(mt5Js.deals) ? mt5Js.deals : [];
            const samp = deals.slice(-10).map(d => ({ ts: d.ts, sym: d.symbol, profit: Number(d.profit||0) }));
            console.debug('[PnL] mt5 deals sample (last 10)=', samp);
          } catch {}
          await refreshClosedDealsSeries();
        } catch (e) { /* ignore */ }
        finally { btnFetchClosed.disabled = false; btnFetchClosed.textContent = prev; }
      });
      if (btnPurgeClosed) btnPurgeClosed.addEventListener('click', async () => {
        if (!window.confirm('Purge PnL rows for the selected account and refetch from MT5?')) return;
        const prev = btnPurgeClosed.textContent;
        btnPurgeClosed.disabled = true; btnPurgeClosed.textContent = 'Purging…';
        try {
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : '';
          if (!acct) { alert('No account selected'); return; }
          // Purge selected account rows
          const r = await fetch(`/api/account/closed_deals_purge?account=${encodeURIComponent(acct)}&confirm=1`, { method:'POST' });
          const js = await r.json().catch(()=>({}));
          console.debug('[PnL] purge result', js);
          // Fetch latest from MT5 then refresh chart
          let url = `/api/account/closed_deals?days=5000&source=mt5&debug=1&nonzero=1&account=${encodeURIComponent(acct)}`;
          const mt5Res = await fetch(url, { cache:'no-store' });
          const mt5Js = await mt5Res.json().catch(()=>({}));
          console.debug('[PnL] after purge, mt5 fetch deals=', (mt5Js.deals||[]).length, 'cum=', (mt5Js.cum||[]).length);
          await refreshClosedDealsSeries();
          status('Purge + Refetch completed');
        } catch (e) {
          console.error('Purge failed', e);
          status('Purge failed');
        } finally {
          btnPurgeClosed.disabled = false; btnPurgeClosed.textContent = prev;
        }
      });
      const btnSyncClosed = document.getElementById('btnSyncClosed');
      if (btnSyncClosed) btnSyncClosed.addEventListener('click', async () => {
        const prev = btnSyncClosed.textContent;
        btnSyncClosed.disabled = true; btnSyncClosed.textContent = 'Syncing…';
        try {
          const acct = (typeof resolveSelectedAccountValue === 'function') ? resolveSelectedAccountValue() : '';
          const url = acct ? `/api/account/closed_deals_sync?account=${encodeURIComponent(acct)}&purge=1` : '/api/account/closed_deals_sync?purge=1';
          const r = await fetch(url, { method:'POST' });
          const js = await r.json().catch(()=>({}));
          if (js && js.ok) { status('Closed orders sync scheduled.'); }
          else { status(`Closed sync error: ${js && js.error ? js.error : r.statusText}`); }
        } catch (e) { status('Closed sync error'); }
        finally { btnSyncClosed.disabled = false; btnSyncClosed.textContent = prev; }
      });
      // Unified Save for both intervals
      const btnSaveIntervals = document.getElementById('btnSaveIntervals');
      if (btnSaveIntervals) btnSaveIntervals.addEventListener('click', async () => {
        const closedMin = Math.max(1, Math.floor(Number(document.getElementById('closedPollMin').value || 30)));
        const balanceMin = Math.max(1, Math.floor(Number(document.getElementById('balancePollMin').value || 60)));
        const prev = btnSaveIntervals.textContent;
        btnSaveIntervals.disabled = true; btnSaveIntervals.textContent = 'Saving…';
        try {
          await fetch('/api/preferences', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              closed_orders_poll_min: String(closedMin),
              balance_poll_min: String(balanceMin),
            }),
          }).then(r=>r.json()).catch(()=>({}));
          // Kick immediate updates
          try { await fetch('/api/account/balance_series?user=lachlan&limit=1000&refresh=1', { cache: 'no-store' }); } catch {}
          await refreshBalanceSeries();
          await refreshClosedDealsSeries();
          status('Intervals saved.');
        } catch (e) {
          status('Failed to save intervals.');
        } finally {
          btnSaveIntervals.disabled = false; btnSaveIntervals.textContent = prev || 'Save';
        }
      });

      // Signal Trade History helpers
      let signalHistoryOffset = 0;
      const signalHistoryLimit = 5;
      function renderSignalTradeItem(item) {
        const ts = item.ts ? new Date(item.ts).toLocaleString() : '';
        const fields = [];
        if (item.strategy) fields.push(`strat=${esc(item.strategy)}`);
        if (item.fast != null && item.slow != null) fields.push(`(${item.fast}/${item.slow})`);
        if (item.volume != null) fields.push(`vol=${item.volume}`);
        if (item.sl != null) fields.push(`SL=${item.sl}`);
        if (item.tp != null) fields.push(`TP=${item.tp}`);
        if (item.order_id) fields.push(`#${item.order_id}`);
        if (item.deal_id) fields.push(`deal=${item.deal_id}`);
        if (item.retcode != null) fields.push(`ret=${item.retcode}`);
        if (item.reason) fields.push(`reason=${esc(item.reason)}`);
        return `<div class="row" style="justify-content:space-between; border-bottom:1px dashed var(--line); padding:6px 0;">
          <div><strong>${esc(item.symbol)}</strong> ${esc(item.timeframe||'')} • <span class="pill" style="background:${item.action==='buy'?'rgba(46,204,113,0.12)':'rgba(231,76,60,0.12)'}; border-color:${item.action==='buy'?'#2ecc71':'#e74c3c'};">${item.action.toUpperCase()}</span></div>
          <div style="color:var(--muted); font-size:12px;">${esc(ts)}</div>
        </div>
        <div style="color:var(--muted); font-size:12px; margin:4px 0 8px 0;">${fields.map(esc).join(' · ')}</div>`;
      }
      async function loadSignalTrades({ append = false } = {}) {
        const symbol = currentSymbol();
        const tf = currentTf();
        const r = await fetch(`/api/trades/signal?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}&limit=${signalHistoryLimit}&offset=${signalHistoryOffset}`, { cache: 'no-store' });
        const js = await r.json().catch(()=>({}));
        const list = el('signalHistoryList');
        if (!list) return;
        if (!append) list.innerHTML = '';
        const rows = (js && js.rows) || [];
        if (rows.length === 0 && !append) {
          list.innerHTML = '<div style="color:var(--muted);">No recent signal trades.</div>';
        } else {
          list.insertAdjacentHTML('beforeend', rows.map(renderSignalTradeItem).join(''));
        }
        // Manage more button
        const btnMore = el('btnSignalHistoryMore');
        if (btnMore) btnMore.disabled = rows.length < signalHistoryLimit;
        if (rows.length > 0) signalHistoryOffset += rows.length;
      }
      function openSignalHistoryModal({ auto = false } = {}) {
        signalHistoryOffset = 0;
        const modal = el('signalHistoryModal');
        if (!modal) return;
        const symbol = currentSymbol();
        const tf = currentTf();
        const info = el('signalHistoryInfo');
        if (info) info.textContent = `${symbol} • TF ${tf}`;
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden','false');
        loadSignalTrades({ append: false });
      }
      function hideSignalHistoryModal() { const m = el('signalHistoryModal'); if (m) { m.style.display = 'none'; m.setAttribute('aria-hidden','true'); } }
      const btnSigHist = document.getElementById('btnSignalHistory');
      if (btnSigHist) btnSigHist.addEventListener('click', () => openSignalHistoryModal());
      const btnSigHistClose = document.getElementById('btnSignalHistoryClose');
      if (btnSigHistClose) btnSigHistClose.addEventListener('click', hideSignalHistoryModal);
      const btnSigHistMore = document.getElementById('btnSignalHistoryMore');
      if (btnSigHistMore) btnSigHistMore.addEventListener('click', () => loadSignalTrades({ append: true }));

      // Initial load
      // News & intel helpers
      const htmlEscape = (str) => {
        if (typeof str !== 'string') return '';
        return str.replace(/[&<>\"']/g, (ch) => ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
        })[ch] || ch);
      };
      const isFiniteNumber = (val) => val !== null && val !== undefined && val !== '' && Number.isFinite(Number(val));
      const niceNumber = (val, opts = {}) => {
        if (!isFiniteNumber(val)) return '—';
        return Number(val).toLocaleString(undefined, opts);
      };
      const formatBigNumber = (val) => {
        if (!isFiniteNumber(val)) return '—';
        const num = Number(val);
        const abs = Math.abs(num);
        if (abs >= 1e12) return `${(num / 1e12).toFixed(2)}T`;
        if (abs >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
        if (abs >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
        if (abs >= 1e3) return `${(num / 1e3).toFixed(2)}K`;
        return num.toLocaleString();
      };
      const priceDigits = (sym, type) => {
        const upper = (sym || '').toUpperCase();
        if (type === 'forex') {
          if (upper.startsWith('XAU') || upper.startsWith('XAG') || upper.startsWith('XPT') || upper.startsWith('XPD')) {
            return 2;
          }
          return 5;
        }
        return 2;
      };

      function renderSymbolInfo(snapshot) {
        const box = el('symbolInfoBox');
        if (!box) return;
        if (!snapshot || Object.keys(snapshot).length === 0) {
          box.innerHTML = '<em style="color:var(--muted)">Provide FMP/Alpha Vantage API keys in <code>.env</code> to enable symbol intelligence.</em>';
          return;
        }
        const type = snapshot.type || 'equity';
        const symbol = snapshot.symbol || currentSymbol();
        const name = snapshot.name || symbol;
        const priceVal = isFiniteNumber(snapshot.price) ? Number(snapshot.price) : null;
        const changeVal = isFiniteNumber(snapshot.change) ? Number(snapshot.change) : null;
        const pctVal = isFiniteNumber(snapshot.changesPercentage) ? Number(snapshot.changesPercentage) : null;
        const fractionDigits = priceDigits(symbol, type);
        const priceStr = niceNumber(priceVal, { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits });
        const changePieces = [];
        if (changeVal !== null) changePieces.push(niceNumber(changeVal, { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits }));
        if (pctVal !== null) changePieces.push(`${niceNumber(pctVal, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%`);
        const changeColor = changeVal !== null
          ? (changeVal > 0 ? 'var(--buy)' : changeVal < 0 ? 'var(--sell)' : 'var(--muted)')
          : (pctVal !== null ? (pctVal > 0 ? 'var(--buy)' : pctVal < 0 ? 'var(--sell)' : 'var(--muted)') : 'var(--muted)');

        const details = [];
        if (snapshot.exchange) details.push(`Exchange: ${htmlEscape(snapshot.exchange)}`);
        if (snapshot.sector) details.push(`Sector: ${htmlEscape(snapshot.sector)}`);
        if (snapshot.industry) details.push(`Industry: ${htmlEscape(snapshot.industry)}`);
        if (isFiniteNumber(snapshot.marketCap)) details.push(`Mkt Cap: ${formatBigNumber(snapshot.marketCap)}`);
        if (isFiniteNumber(snapshot.volume)) details.push(`Vol: ${formatBigNumber(snapshot.volume)}`);
        if (isFiniteNumber(snapshot.avgVolume)) details.push(`Avg Vol: ${formatBigNumber(snapshot.avgVolume)}`);
        if (type === 'forex') {
          if (isFiniteNumber(snapshot.dayHigh) || isFiniteNumber(snapshot.dayLow)) {
            details.push(`Day: ${niceNumber(snapshot.dayLow, { maximumFractionDigits: fractionDigits })} → ${niceNumber(snapshot.dayHigh, { maximumFractionDigits: fractionDigits })}`);
          }
          if (isFiniteNumber(snapshot.yearLow) || isFiniteNumber(snapshot.yearHigh)) {
            details.push(`52w: ${niceNumber(snapshot.yearLow, { maximumFractionDigits: fractionDigits })} → ${niceNumber(snapshot.yearHigh, { maximumFractionDigits: fractionDigits })}`);
          }
        }
        let desc = '';
        if (snapshot.description) {
          const fullDesc = String(snapshot.description);
          const trimmed = fullDesc.slice(0, 280);
          desc = `<div style="font-size:12px; color:var(--muted); margin-top:4px;">${htmlEscape(trimmed)}${fullDesc.length > trimmed.length ? '…' : ''}</div>`;
        }
        if (snapshot.website) {
          details.push(`<a href="${htmlEscape(snapshot.website)}" target="_blank" rel="noopener">Website</a>`);
        }
        box.innerHTML = `
          <div style="display:flex; flex-direction:column; gap:4px;">
            <div style="font-weight:600; color:var(--text);">${htmlEscape(name)} <span style="font-weight:500; color:var(--muted);">(${htmlEscape(symbol)})</span></div>
            <div style="display:flex; gap:10px; align-items:baseline; flex-wrap:wrap;">
              <span style="font-size:20px; font-weight:600; color:var(--text);">${priceStr}</span>
              <span style="font-weight:600; color:${changeColor};">${changePieces.join(' · ')}</span>
            </div>
            ${details.length ? `<div style="font-size:12px; color:var(--muted); display:flex; flex-wrap:wrap; gap:6px;">${details.join(' • ')}</div>` : ''}
            ${desc}
          </div>
        `;
      }

      function renderNews(items) {
        const box = el('newsBox');
        if (!box) return;
        box.innerHTML = '';
        if (!items || !items.length) {
          box.innerHTML = '<em style="color:var(--muted)">No recent news found for this symbol.</em>';
          return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          const card = document.createElement('div');
          card.className = 'news-card';

          const titleText = item.title || item.headline || '(no title)';
          const titleEl = document.createElement('h4');
          const titleLink = document.createElement('a');
          titleLink.textContent = titleText;
          if (item.url) {
            titleLink.href = item.url;
            titleLink.target = '_blank';
            titleLink.rel = 'noopener';
          } else {
            titleLink.href = '#';
          }
          titleLink.style.color = 'var(--accent)';
          titleLink.style.textDecoration = 'none';
          titleEl.appendChild(titleLink);
          card.appendChild(titleEl);

          const metaParts = [];
          if (item.source || item.site) metaParts.push(item.source || item.site);
          if (item.publishedAt || item.publishedDate || item.date) {
            metaParts.push(item.publishedAt || item.publishedDate || item.date);
          }
          if (metaParts.length) {
            const metaEl = document.createElement('div');
            metaEl.className = 'news-meta';
            metaEl.textContent = metaParts.join(' • ');
            card.appendChild(metaEl);
          }

          const summaryText = NEWS_SHOW_FULL ? (item.body || item.summary || item.description || item.snippet || '') : (item.summary || item.description || item.snippet || '');
          if (summaryText) {
            const summaryEl = document.createElement('div');
            summaryEl.className = 'news-summary';
            summaryEl.textContent = summaryText;
            card.appendChild(summaryEl);
          }

          const fallbackKey = [titleText, summaryText, metaParts.join('|')].filter(Boolean).join('|');

          const actionsEl = document.createElement('div');
          actionsEl.className = 'news-actions';
          // Read button to open full text in modal
          const readBtn = document.createElement('button');
          readBtn.type = 'button';
          readBtn.className = 'btn secondary';
          readBtn.textContent = 'Read';
          readBtn.addEventListener('click', () => {
            const fullBody = (item.body || item.text || item.summary || item.description || item.snippet || '').toString();
            openNewsModal(titleText, fullBody);
          });

          const aiBtn = document.createElement('button');
          aiBtn.type = 'button';
          aiBtn.className = 'btn secondary news-ai-btn';
          // Keep the button visible but disabled per request
          aiBtn.textContent = 'Ask AI (30 checks)';
          aiBtn.disabled = true;
          actionsEl.appendChild(readBtn);
          actionsEl.appendChild(aiBtn);
          card.appendChild(actionsEl);

          const answersWrap = document.createElement('div');
          answersWrap.className = 'news-answers';
          card.appendChild(answersWrap);

          const cacheKey = newsArticleKey(item) || fallbackKey || titleText;
          if (NEWS_AI_AVAILABLE) {
            aiBtn.addEventListener('click', () => requestNewsAnalysis(item, cacheKey, aiBtn, answersWrap));
            if (newsAnalysisCache.has(cacheKey)) {
              renderNewsAnswers(answersWrap, newsAnalysisCache.get(cacheKey));
            }
          }

          fragment.appendChild(card);
        });
        box.appendChild(fragment);
      }

      function renderNewsAnswers(container, answers) {
        if (!container) return;
        container.innerHTML = '';
        if (!answers || !answers.length) {
          container.classList.remove('active');
          return;
        }
        container.classList.add('active');
        answers.forEach((ans) => {
          const pill = document.createElement('span');
          const answerValue = (ans && ans.answer) ? String(ans.answer).toLowerCase() : 'no';
          pill.className = `news-answer ${answerValue}`;
          const labelText = ans && ans.label ? ans.label : ans.id || 'Question';
          pill.textContent = `${labelText}: ${answerValue.toUpperCase()}`;
          if (ans && ans.question) {
            pill.title = ans.question;
          }
          container.appendChild(pill);
        });
      }

      function setNewsAnalysisUnavailable(container, message) {
        if (!container) return;
        container.classList.add('active');
        container.innerHTML = '';
        const pill = document.createElement('span');
        pill.className = 'news-answer unknown';
        pill.textContent = message || 'Analysis unavailable';
        container.appendChild(pill);
      }

      async function requestNewsAnalysis(article, cacheKey, button, container) {
        if (!NEWS_AI_AVAILABLE) {
          status('LLM analysis unavailable (set OPENAI_API_KEY).');
          setNewsAnalysisUnavailable(container, 'AI unavailable');
          return;
        }
        if (!article) return;
        if (cacheKey && newsAnalysisCache.has(cacheKey)) {
          renderNewsAnswers(container, newsAnalysisCache.get(cacheKey));
          return;
        }
        if (button) {
          button.disabled = true;
          button.textContent = 'Analyzing…';
        }
        if (container) {
          container.classList.add('active');
          container.innerHTML = '<span class="news-answer unknown">Analyzing…</span>';
        }
        const payload = {
          article_id: cacheKey,
          title: article.title || article.headline || '',
          summary: article.summary || article.description || '',
          body: article.content || article.text || '',
          url: article.url || '',
          source: article.source || article.site || '',
          published_at: article.publishedAt || article.publishedDate || article.date || '',
          symbol: currentSymbol(),
        };
        try {
          const resp = await fetch('/api/news/analyze', {
            method: 'POST',
            cache: 'no-store',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const js = await resp.json().catch(() => ({}));
          if (!resp.ok || !js.ok) {
            const msg = js.error || resp.statusText || 'AI analysis failed';
            status(msg);
            setNewsAnalysisUnavailable(container, msg);
            return;
          }
          const answers = js.answers || [];
          if (cacheKey) {
            newsAnalysisCache.set(cacheKey, answers);
          }
          renderNewsAnswers(container, answers);
          status('AI micro-checks completed for news article.');
        } catch (err) {
          status(`AI analysis failed: ${err.message || err}`);
          setNewsAnalysisUnavailable(container, 'Analysis failed');
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = 'Ask AI (30 checks)';
          }
        }
      }

      let NEWS_SHOW_FULL = false;
      // Affiliate widget visibility controls
      const RF_TOP_KEY = 'rfTopQuotesHidden';
      const RF_BOT_KEY = 'rfBottomBannerHidden';
      const RF_BR_KEY = 'rfRightForecastsHidden';
      const RF_WIDGET_IDS = ['rfBottomBanner', 'rfRightForecasts'];
      const rfOptIn = (() => {
        try {
          const v = localStorage.getItem('rfWidgetsOptIn');
          // Default to ON when unset; user can still hide per-widget.
          return v === null || v === '1';
        } catch (_) {
          return true;
        }
      })();
      const teardownRfWidget = (id) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.querySelectorAll('[data-rf-content]').forEach((node) => node.remove());
        delete el.dataset.rfMounted;
        const placeholderText = el.dataset.rfPlaceholder || 'RoboForex widget disabled.';
        if (!el.querySelector('.rf-placeholder')) {
          const target = el.dataset.rfType === 'img' ? el.querySelector('a') || el : el;
          const placeholderTag = el.dataset.rfType === 'img' ? 'span' : 'div';
          const placeholder = document.createElement(placeholderTag);
          placeholder.className = 'rf-placeholder';
          placeholder.textContent = placeholderText;
          if (el.dataset.rfType === 'iframe') {
            const head = el.querySelector('.rf-head');
            if (head) {
              head.insertAdjacentElement('afterend', placeholder);
            } else {
              el.appendChild(placeholder);
            }
          } else {
            target.appendChild(placeholder);
          }
        }
      };
      const mountRfWidget = (id) => {
        const el = document.getElementById(id);
        if (!el || el.dataset.rfMounted === '1' || el.classList.contains('rf-hidden')) return;
        const type = el.dataset.rfType;
        const src = el.dataset.rfSrc;
        if (!type || !src) return;
        const width = el.dataset.rfWidth || '100%';
        const height = el.dataset.rfHeight || '200';
        el.querySelectorAll('.rf-placeholder').forEach((node) => node.remove());
        if (type === 'iframe') {
          const iframe = document.createElement('iframe');
          iframe.setAttribute('data-rf-content', '1');
          iframe.frameBorder = '0';
          iframe.loading = 'lazy';
          iframe.className = 'efx';
          iframe.width = width;
          iframe.height = height;
          iframe.src = src;
          const head = el.querySelector('.rf-head');
          const closeBtn = el.querySelector('.rf-btn') || el.querySelector('button');
          if (head && head.parentNode === el) {
            head.insertAdjacentElement('afterend', iframe);
          } else if (closeBtn && closeBtn.parentNode === el) {
            el.insertBefore(iframe, closeBtn);
          } else {
            el.insertBefore(iframe, el.firstChild);
          }
        } else if (type === 'img') {
          const anchor = el.querySelector('a');
          if (!anchor) return;
          const img = document.createElement('img');
          img.setAttribute('data-rf-content', '1');
          img.loading = 'lazy';
          img.src = src;
          const w = parseInt(width, 10);
          const h = parseInt(height, 10);
          if (!Number.isNaN(w)) img.width = w;
          if (!Number.isNaN(h)) img.height = h;
          img.alt = 'RoboForex';
          anchor.appendChild(img);
        }
        el.dataset.rfMounted = '1';
        el.classList.remove('rf-hidden');
      };
      const setRfHidden = (id, key) => {
        const el = document.getElementById(id);
        if (el) {
          teardownRfWidget(id);
          el.classList.add('rf-hidden');
        }
        try { localStorage.setItem(key, '1'); } catch {}
      };
      const initRfWidget = (id, key, btnId) => {
        const el = document.getElementById(id);
        const btn = document.getElementById(btnId);
        if (!el) return;
        let hidden = false;
        try {
          hidden = localStorage.getItem(key) === '1';
        } catch {}
        // Always allow showing now (do not clear the stored flag),
        // but remove CSS hidden class so widget can render.
        try { el.classList.remove('rf-hidden'); } catch {}
        if (btn) btn.addEventListener('click', () => setRfHidden(id, key));
        if (rfOptIn) {
          mountRfWidget(id);
        }
      };
      if (!rfOptIn) {
        RF_WIDGET_IDS.forEach((id) => {
          const el = document.getElementById(id);
          if (el) {
            teardownRfWidget(id);
            el.classList.add('rf-hidden');
          }
        });
        window.enableRoboForexWidgets = () => {
          try { localStorage.setItem('rfWidgetsOptIn', '1'); } catch {}
          window.location.reload();
        };
      } else {
        RF_WIDGET_IDS.forEach((id) => mountRfWidget(id));
        window.disableRoboForexWidgets = () => {
          try { localStorage.setItem('rfWidgetsOptIn', '0'); } catch {}
          window.location.reload();
        };
      }
      initRfWidget('rfTopQuotes', RF_TOP_KEY, 'rfTopQuotesClose');
      initRfWidget('rfBottomBanner', RF_BOT_KEY, 'rfBottomBannerClose');
      initRfWidget('rfRightForecasts', RF_BR_KEY, 'rfRightForecastsClose');
      // Modal helpers for full news text
      const modalEl = document.getElementById('newsModal');
      const modalTitleEl = document.getElementById('newsModalTitle');
      const modalBodyEl = document.getElementById('newsModalBody');
      const modalCloseEl = document.getElementById('newsModalClose');
      const openNewsModal = (title, body) => {
        if (modalTitleEl) modalTitleEl.textContent = title || 'Full Article';
        if (modalBodyEl) modalBodyEl.textContent = (body || '').toString();
        if (modalEl) {
          modalEl.style.display = 'flex';
          modalEl.setAttribute('aria-hidden', 'false');
        }
      };
      const closeNewsModal = () => {
        if (modalEl) {
          modalEl.style.display = 'none';
          modalEl.setAttribute('aria-hidden', 'true');
        }
        if (modalTitleEl) modalTitleEl.textContent = '';
        if (modalBodyEl) modalBodyEl.textContent = '';
      };
      if (modalCloseEl) modalCloseEl.addEventListener('click', closeNewsModal);
      if (modalEl) modalEl.addEventListener('click', (e) => { if (e.target === modalEl) closeNewsModal(); });

      // (Affiliate Backlinks panel removed per request)

      async function refreshNews(arg = {}) {
        let opts = {};
        if (arg && typeof arg.preventDefault === 'function') {
          arg.preventDefault();
        } else if (arg && typeof arg === 'object' && arg !== null) {
          opts = arg;
        }
        const symbol = currentSymbol();
        const reason = opts.reason || 'manual';
        const disableButton = !!opts.disableButton;
        const silent = !!opts.silent;
        const newsBox = el('newsBox');
        debugLog('[App] Refresh news/intel for', symbol, 'reason=', reason);
        if (!silent) {
          setNewsStatus(`Refreshing news for ${symbol}…`, 'info');
        }
        if (newsBox && !opts.skipPlaceholder) {
          newsBox.innerHTML = '<em style="color:var(--muted)">Loading latest news…</em>';
        }
        if (disableButton && btnNews) {
          btnNews.disabled = true;
          btnNews.textContent = 'Refreshing…';
        }
        try {
          // Live fetch only when explicitly requested (manual click);
          // otherwise read DB (no provider call).
          const useLive = !!opts.forceLive;
          const url = `/api/news?symbol=${encodeURIComponent(symbol)}` + (useLive ? `&refresh=1` : '');
          const r = await fetch(url, { cache: 'no-store' });
          const js = await r.json();
          if (js && js.ok) {
            const items = js.news || [];
            renderSymbolInfo(js.snapshot || {});
            renderNews(items);
            lastNewsUpdatedAt = new Date();
            if (!silent) {
              const ts = lastNewsUpdatedAt.toLocaleTimeString();
              setNewsStatus(`Updated ${ts} • ${items.length} item${items.length === 1 ? '' : 's'}`, 'ok');
            }
            debugLog(`[App] News result ok=true count=${items.length} snapshot=${!!js.snapshot}`);
          } else {
            renderSymbolInfo({});
            renderNews([]);
            if (!silent) {
              setNewsStatus('News refresh failed (server error).', 'error');
            }
            debugWarn(`[App] News result ok=false for ${symbol}`, js);
          }
        } catch (e) {
          debugWarn('News fetch failed', e);
          renderSymbolInfo({});
          renderNews([]);
          if (!silent) {
            setNewsStatus(`News refresh failed: ${e.message || e}`, 'error');
          }
        } finally {
          if (disableButton && btnNews) {
            btnNews.disabled = false;
            btnNews.textContent = NEWS_BUTTON_DEFAULT;
          }
          // Update Basic Health freshness indicator
          try { await refreshHealthFreshness(); } catch {}
        }
      }
      if (btnNews) btnNews.addEventListener('click', (ev) => {
        ev.preventDefault();
        // Manual click: force provider fetch, then DB render
        refreshNews({ disableButton: true, reason: 'manual_click', forceLive: true });
      });
      if (btnNewsFull) btnNewsFull.addEventListener('click', () => {
        NEWS_SHOW_FULL = !NEWS_SHOW_FULL;
        btnNewsFull.textContent = NEWS_SHOW_FULL ? 'Summaries' : 'Full Text';
        // Re-render using cached last news list by refetching from DOM cache if available
        // Simpler: just call refreshNews to rebuild with full text toggle
        refreshNews({ reason: 'toggle_full_text' });
      });

      // Trading controls
      const btnBuyEl = document.getElementById('btnBuy');
      const btnSellEl = document.getElementById('btnSell');
      const btnCloseEl = document.getElementById('btnClose');
      const btnCloseAllEl = document.getElementById('btnCloseAll');
      const btnPosEl = document.getElementById('btnPos');
      if (btnBuyEl) btnBuyEl.addEventListener('click', () => trade('buy'));
      if (btnSellEl) btnSellEl.addEventListener('click', () => trade('sell'));
      if (btnCloseEl) btnCloseEl.addEventListener('click', () => openCloseModal('current'));
      if (btnCloseAllEl) btnCloseAllEl.addEventListener('click', () => openCloseModal('all'));
      if (btnPosEl) btnPosEl.addEventListener('click', refreshPositions);

      // (Old per-interval save removed; unified Save handles both)

      // Close modal actions
      const btnCloseModalX = document.getElementById('btnCloseModalX');
      const btnCloseModalCancel = document.getElementById('btnCloseModalCancel');
      const btnConfirmCloseCurrent = document.getElementById('btnConfirmCloseCurrent');
      const btnConfirmCloseAll = document.getElementById('btnConfirmCloseAll');
      if (btnCloseModalX) btnCloseModalX.addEventListener('click', hideCloseModal);
      if (btnCloseModalCancel) btnCloseModalCancel.addEventListener('click', hideCloseModal);
      if (btnConfirmCloseCurrent) btnConfirmCloseCurrent.addEventListener('click', () => doClose('current'));
      if (btnConfirmCloseAll) btnConfirmCloseAll.addEventListener('click', () => doClose('all'));

      // Ticker poll (bid/ask + update button labels)
      let tickTimer = null;
      let autoStratTimer = null;
      async function pollTick() {
        const symbol = currentSymbol();
        try {
          const r = await fetch(`/api/tick?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
          const js = await r.json().catch(() => ({}));
          if (js && js.ok && js.tick) {
            const { bid, ask } = js.tick;
            const spr = (Number(ask) - Number(bid));
            const sprStr = Number.isFinite(spr) ? spr.toFixed(3) : '—';
            const bidStr = Number.isFinite(Number(bid)) ? Number(bid).toFixed(3) : '—';
            const askStr = Number.isFinite(Number(ask)) ? Number(ask).toFixed(3) : '—';
            const tk = document.getElementById('ticker');
            if (tk) tk.textContent = `${symbol}  Bid ${bidStr}  Ask ${askStr}  Spr ${sprStr}`;
            const b = document.getElementById('btnBuy');
            const s = document.getElementById('btnSell');
            if (b) b.textContent = `Buy @ ${askStr}`;
            if (s) s.textContent = `Sell @ ${bidStr}`;
          }
        } catch (e) {
          // ignore transient errors
        }
      }
      let __loginRetryAt = 0;
      async function startTickPoll() {
        if (tickTimer) clearInterval(tickTimer);
        try { await ensureSelectedAccountSession(); } catch {}
        if (!__lastLoginSession) {
          // backoff retry if login not ready yet
          const now = Date.now();
          if (now < __loginRetryAt) return;
          __loginRetryAt = now + 5000;
          setTimeout(startTickPoll, 1500);
          return;
        }
        // immediate update then interval once logged in
        try { await pollTick(); } catch {}
        tickTimer = setInterval(pollTick, 2000);
      }
      // restart ticker when symbol changes
      const symSel = document.getElementById('symbol');
      if (symSel) symSel.addEventListener('change', () => { try { localStorage.setItem('last_symbol', currentSymbol()); } catch {} startTickPoll(); });

      // Initial loads
      buildStlOverlayControls();
      updateStlInputsFromState();
      updateStlDerivativeSeries();
      refreshChart();
      refreshNews();
      refreshPositions();
      startAuto({ announce: false });
      startTickPoll();

      // Auto AI Trade history loader and modal opener (moved inside script)
      async function loadAutoHistory(limit=5, offset=0) {
        if (!autoHistoryBox) return;
        if (offset === 0) autoHistoryBox.innerHTML = '<em style="color:var(--muted)">Loading…</em>';
        const sym = currentSymbol();
        const tf = currentTf();
        const params = new URLSearchParams();
        if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
        else { params.set('kind','stock'); params.set('symbol', sym); }
        params.set('strategy','auto_ai_trade'); params.set('tf', tf); params.set('limit', String(limit)); params.set('offset', String(offset));
        try {
          const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
          const js = await r.json().catch(()=>({}));
          const runs = Array.isArray(js.runs) ? js.runs : [];
          if (offset === 0) autoHistoryBox.innerHTML = '';
          if (!runs.length && offset === 0) {
            // Fallback: try group=auto with tf filter
            const p2 = new URLSearchParams();
            if (isFxPair(sym)) { const pq = splitPair(sym); p2.set('kind','forex_pair'); p2.set('base', pq.base); p2.set('quote', pq.quote); } else { p2.set('kind','stock'); p2.set('symbol', sym); }
            p2.set('group','auto'); p2.set('tf', tf); p2.set('limit', String(limit)); p2.set('offset', String(offset));
            const r2 = await fetch(`/api/health/runs?${p2.toString()}`, { cache:'no-store' });
            const j2 = await r2.json().catch(()=>({}));
            const runs2 = Array.isArray(j2.runs) ? j2.runs : [];
            if (!runs2.length) {
              // Final fallback: drop tf filter
              const p3 = new URLSearchParams();
              if (isFxPair(sym)) { const pq = splitPair(sym); p3.set('kind','forex_pair'); p3.set('base', pq.base); p3.set('quote', pq.quote); } else { p3.set('kind','stock'); p3.set('symbol', sym); }
              p3.set('group','auto'); p3.set('limit', String(limit)); p3.set('offset', String(offset));
              const r3 = await fetch(`/api/health/runs?${p3.toString()}`, { cache:'no-store' });
              const j3 = await r3.json().catch(()=>({}));
              const runs3 = Array.isArray(j3.runs) ? j3.runs : [];
              if (!runs3.length) { autoHistoryBox.innerHTML = '<em style="color:var(--muted)">No recent auto logs</em>'; return; }
          const html3 = runs3.map(r => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ans = r.answers || r.answers_json || {};
            const meta = ans.meta || {};
            const order = (meta.order_result && (meta.order_result.order || meta.order_result.deal)) ? (meta.order_result.order || meta.order_result.deal) : null;
            const last = Array.isArray(ans.log) && ans.log.length ? ans.log[ans.log.length-1].message : '';
            const orderStr = order ? ` • order ${esc(order)}` : '';
            const cls = meta && meta.skipped ? ' auto-row-skip' : '';
            return `<div class=\"row${cls}\" style=\"justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n              <span style=\"font-size:12px; color:var(--muted);\">${t}${orderStr}</span>\n              <span style=\"font-size:12px; color:var(--muted);\">${esc(last || '')}</span>\n            </div>`;
          }).join('');
              if (html3) autoHistoryBox.insertAdjacentHTML('beforeend', html3);
              return;
            }
            const html2 = runs2.map(r => {
              const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
              const ans = r.answers || r.answers_json || {};
              const meta = ans.meta || {};
              const order = (meta.order_result && (meta.order_result.order || meta.order_result.deal)) ? (meta.order_result.order || meta.order_result.deal) : null;
              const last = Array.isArray(ans.log) && ans.log.length ? ans.log[ans.log.length-1].message : '';
              const orderStr = order ? ` • order ${esc(order)}` : '';
              const cls = meta && meta.skipped ? ' auto-row-skip' : '';
              return `<div class=\"row${cls}\" style=\"justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n              <span style=\"font-size:12px; color:var(--muted);\">${t}${orderStr}</span>\n              <span style=\"font-size:12px; color:var(--muted);\">${esc(last || '')}</span>\n            </div>`;
            }).join('');
            if (html2) autoHistoryBox.insertAdjacentHTML('beforeend', html2);
            return;
          }
          // Cache runs for quick click-detail display
          try { runs.forEach((rr)=> { try { autoHistoryCache.set(Number(rr.id), rr); } catch {} }); } catch {}
          const html = runs.map(r => {
            const t = r.created_at ? new Date(r.created_at).toLocaleString() : '';
            const ans = r.answers || r.answers_json || {};
            const meta = ans.meta || {};
            const order = (meta.order_result && (meta.order_result.order || meta.order_result.deal)) ? (meta.order_result.order || meta.order_result.deal) : null;
            const last = Array.isArray(ans.log) && ans.log.length ? ans.log[ans.log.length-1].message : '';
            const orderStr = order ? ` • order ${esc(order)}` : '';
            const cls = meta && meta.skipped ? ' auto-row-skip' : '';
            return `<div class=\"row auto-item${cls}\" data-run-id=\"${r.id}\" style=\"cursor:pointer; justify-content:space-between; border:1px solid var(--line); border-radius:6px; padding:6px 8px; background:#fff; width:100%;\">\n              <span style=\"font-size:12px; color:var(--muted);\">${t}${orderStr}</span>\n              <span style=\"font-size:12px; color:var(--muted);\">${esc(last || '')}</span>\n            </div>`;
          }).join('');
          if (html) autoHistoryBox.insertAdjacentHTML('beforeend', html);
        } catch (e) {
          if (offset === 0) autoHistoryBox.innerHTML = '<em style="color:var(--muted)">Failed to load</em>';
        }
      }

      // Auto history click: render full details into the modal log box
      const autoHistoryCache = new Map();
      function renderAutoRunDetails(run, id) {
        try {
          const ans = (run && (run.answers || run.answers_json)) || {};
          const meta = ans.meta || {};
          const steps = Array.isArray(ans.log) ? ans.log : [];
          const lines = [];
          lines.push(`<div><strong>Run #${id != null ? esc(String(id)) : esc(String(run && run.id || ''))}</strong></div>`);
          const order = (meta.order_result && (meta.order_result.order || meta.order_result.deal)) ? (meta.order_result.order || meta.order_result.deal) : null;
          lines.push(`<div style=\"margin-top:4px;\">Action: ${esc(meta.action || '—')} • Plan: ${esc(meta.plan_run_id || '—')} • Basic: ${esc(meta.basic_run_id || '—')} • Tech: ${esc(meta.tech_run_id || '—')} ${order? `• Order: ${esc(order)}` : ''}</div>`);
          if (steps.length) {
            lines.push('<div style=\"margin-top:6px;\"><strong>Log</strong></div>');
            for (const s of steps) {
              const ts = s.ts ? new Date(s.ts).toLocaleString() : '';
              const lvl = s.level || 'info';
              const color = lvl === 'error' ? '#e74c3c' : (lvl === 'warn' ? '#ff9800' : 'var(--muted)');
              lines.push(`<div><span style=\"color:${color}\">[${esc(ts)}]</span> ${esc(s.message || '')}</div>`);
            }
          } else {
            lines.push('<div style=\"margin-top:6px; color:var(--muted);\"><em>No log steps captured</em></div>');
          }
          const box = getAutoLogBoxEl();
          if (box) { box.innerHTML = lines.join(''); box.scrollTop = box.scrollHeight; }
        } catch {}
      }
      if (document.getElementById('autoHistoryBox')) {
        document.getElementById('autoHistoryBox').addEventListener('click', (ev)=>{
          const item = ev.target.closest('.auto-item');
          if (!item) return;
          const id = Number(item.getAttribute('data-run-id'));
          if (!Number.isFinite(id)) return;
          // Lookup run in DOM by re-fetching the latest page then find matching id
          (async ()=>{
            try {
              // Use cache first, then fallback to a short fetch if missing
              let run = autoHistoryCache.get(id);
              if (!run) {
                const sym = currentSymbol();
                const tf = currentTf();
                const params = new URLSearchParams();
                if (isFxPair(sym)) { const pq = splitPair(sym); params.set('kind','forex_pair'); params.set('base', pq.base); params.set('quote', pq.quote); }
                else { params.set('kind','stock'); params.set('symbol', sym); }
                params.set('group','auto'); params.set('tf', tf); params.set('limit','100'); params.set('offset','0');
                const r = await fetch(`/api/health/runs?${params.toString()}`, { cache:'no-store' });
                const js = await r.json().catch(()=>({}));
                const runs = Array.isArray(js.runs) ? js.runs : [];
                runs.forEach((rr)=>{ try { autoHistoryCache.set(Number(rr.id), rr); } catch {} });
                run = runs.find(x => Number(x.id) === id);
              }
              if (run) { renderAutoRunDetails(run, id); }
              else {
                const box = getAutoLogBoxEl();
                if (box) box.innerHTML = `<em style="color:var(--muted)">Details unavailable for #${esc(String(id))}</em>`;
              }
            } catch (e) { /* ignore */ }
          })();
        });
      }

      async function openAutoModal() {
        autoHistoryOffset = 0;
        const sym = currentSymbol();
        const tf = currentTf();
        if (autoModal) { autoModal.style.display = 'flex'; autoModal.setAttribute('aria-hidden', 'false'); }
        // meta line: symbol • TF • Open lots • Safe max lots (red)
        try {
          try { await ensureSelectedAccountSession?.(); } catch {}
          const posRes = await fetch(`/api/positions?symbol=${encodeURIComponent(sym)}`, { cache:'no-store' });
          const posJs = await posRes.json().catch(()=>([]));
          const positions = Array.isArray(posJs) ? posJs : (Array.isArray(posJs.positions) ? posJs.positions : []);
          const openLots = positions.reduce((acc,p)=> acc + (Number(p.volume) || 0), 0);
          // safe max pref
          let safe = '';
          try {
            const key = encodeURIComponent(`safe_max_lots:${sym}:${tf}`);
            const prefRes = await fetch(`/api/preferences?keys=${key}`, { cache:'no-store' });
            const prefJs = await prefRes.json().catch(()=>({}));
            const map = (prefJs && prefJs.prefs) || prefJs || {};
            safe = map[`safe_max_lots:${sym}:${tf}`] || '';
          } catch {}
          const safeHtml = safe ? `<span style=\"color:#e74c3c;\">Safe max: ${esc(safe)} lots</span>` : '';
          if (autoMeta) autoMeta.innerHTML = `${esc(sym)} • TF ${esc(tf)} • Open: ${openLots.toFixed(2)} lots ${safeHtml ? '• ' + safeHtml : ''}`;
          // Mirror safe into input; disable Start if breached and show hint
          const safeInput = document.getElementById('autoSafeMaxInput');
          if (safeInput) safeInput.value = String(Number(safe || 0.10) || 0.10);
          const safeNum = Number(safeInput && safeInput.value);
          if (btnAutoStart) btnAutoStart.disabled = Number.isFinite(safeNum) && safeNum > 0 ? (openLots > safeNum) : false;
          const hintEl = document.getElementById('autoSafeHint');
          if (hintEl) hintEl.textContent = `Open ${openLots.toFixed(2)} • Safe ${Number.isFinite(safeNum)&&safeNum>0? safeNum.toFixed(2): '—'}`;
          // Initialize and cross-sync Auto Vol with header Vol and DB (default to 0.01)
          try {
            const volInput = document.getElementById('autoVolumeInput');
            const headerVol = document.getElementById('volume');
            let baseVol = NaN;
            // Prefer stored auto volume
            try {
              const k = encodeURIComponent(`auto_volume:${sym}:${tf}`);
              const r = await fetch(`/api/preferences?keys=${k}`, { cache:'no-store' });
              const js = await r.json().catch(()=>({}));
              const map = (js && js.prefs) || js || {};
              const v = Number(map[`auto_volume:${sym}:${tf}`]);
              if (Number.isFinite(v) && v > 0) baseVol = v;
            } catch {}
            // Else try header value
            if (!Number.isFinite(baseVol) || baseVol <= 0) {
              const hv = Number(headerVol && headerVol.value);
              if (Number.isFinite(hv) && hv > 0) baseVol = hv;
            }
            // Else fall back to default 0.01
            if (!Number.isFinite(baseVol) || baseVol <= 0) baseVol = 0.01;
            // Apply to both UI controls
            if (volInput) volInput.value = String(baseVol.toFixed(2));
            if (headerVol) headerVol.value = String(baseVol.toFixed(2));
            // Persist to DB (both auto and trade volume keys)
            queuePrefUpdate(`auto_volume:${sym}:${tf}`, String(baseVol));
            queuePrefUpdate(`trade_volume:${sym}:${tf}`, String(baseVol));
          } catch {}
          // Initialize SL toggle from preference (default OFF) and mirror to periodic toggle
          try {
            const slT = document.getElementById('autoSlToggle');
            if (slT) {
              const k = encodeURIComponent(`auto_sl_enabled:${sym}:${tf}`);
              const r = await fetch(`/api/preferences?keys=${k}`, { cache:'no-store' });
              const js = await r.json().catch(()=>({}));
              const map = (js && js.prefs) || js || {};
              const on = String(map[`auto_sl_enabled:${sym}:${tf}`] || '0') === '1';
              slT.checked = on;
              try { const pt = document.getElementById('autoPeriodicSlToggle'); if (pt) pt.checked = on; } catch {}
            }
          } catch {}
        } catch {
          if (autoMeta) autoMeta.textContent = `${currentSymbol()} • TF ${currentTf()}`;
        }
        try { await updateAutoMirrors(); } catch {}
        // Update mirror dropdowns and freshness colors on open
        try {
          await updateAutoMirrors();
          const hf = await fetch(`/api/health/freshness?symbol=${encodeURIComponent(sym)}`, { cache:'no-store' });
          const hj = await hf.json().catch(()=>({}));
          const tfq = new URLSearchParams({ symbol: sym, tf });
          const tfres = await fetch(`/api/tech/freshness?${tfq.toString()}`, { cache:'no-store' });
          const tj = await tfres.json().catch(()=>({}));
          setAutoMirrorFreshness(hj, tj);
        } catch {}
        // history and clear log
        if (getAutoLogBoxEl()) getAutoLogBoxEl().innerHTML = '';
        loadAutoHistory(5, 0);
        try { await loadAccountsSelect(); } catch {}
        try { const s = document.getElementById('btnAutoStart'); if (s) s.focus(); } catch {}
      }
      try { window.openAutoModal = openAutoModal; } catch {}
      // Cross-sync: right panel Safe Max and top Volume with Auto modal controls
      (function setupAutoCrossSync(){
        const rightSafe = document.getElementById('safeMaxLotsInput');
        const headerVol = document.getElementById('volume');
        const modalSafe = document.getElementById('autoSafeMaxInput');
        const modalVol = document.getElementById('autoVolumeInput');
        function _syncSafeFromRight(){ if (!modalSafe || !rightSafe) return; modalSafe.value = String(rightSafe.value||''); _saveAutoPrefs(); }
        function _syncSafeFromModal(){ if (!modalSafe || !rightSafe) return; rightSafe.value = String(modalSafe.value||''); _saveAutoPrefs(); }
        function _syncVolFromHeader(){ if (!modalVol || !headerVol) return; const v=String(headerVol.value||''); modalVol.value = v; const sym=currentSymbol(), tf=currentTf(); queuePrefUpdate(`auto_volume:${sym}:${tf}`, v); queuePrefUpdate(`trade_volume:${sym}:${tf}`, v); queuePrefUpdate('last_volume', v); try{ flushPrefQueue(); }catch{} }
        function _syncVolFromModal(){ if (!modalVol || !headerVol) return; const v=String(modalVol.value||''); headerVol.value = v; const sym=currentSymbol(), tf=currentTf(); queuePrefUpdate(`auto_volume:${sym}:${tf}`, v); queuePrefUpdate(`trade_volume:${sym}:${tf}`, v); queuePrefUpdate('last_volume', v); try{ flushPrefQueue(); }catch{} }
        if (rightSafe) rightSafe.addEventListener('change', _syncSafeFromRight);
        if (modalSafe) modalSafe.addEventListener('change', _syncSafeFromModal);
        if (headerVol) headerVol.addEventListener('change', _syncVolFromHeader);
        if (modalVol) modalVol.addEventListener('change', _syncVolFromModal);
      })();
    </script>
  </body>
  </html>
